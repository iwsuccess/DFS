// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: NameNode.proto

#ifndef PROTOBUF_INCLUDED_NameNode_2eproto
#define PROTOBUF_INCLUDED_NameNode_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_NameNode_2eproto 

namespace protobuf_NameNode_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[34];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_NameNode_2eproto
namespace Rpc {
class AppendEntriesArgs;
class AppendEntriesArgsDefaultTypeInternal;
extern AppendEntriesArgsDefaultTypeInternal _AppendEntriesArgs_default_instance_;
class AppendEntriesReply;
class AppendEntriesReplyDefaultTypeInternal;
extern AppendEntriesReplyDefaultTypeInternal _AppendEntriesReply_default_instance_;
class Chunk;
class ChunkDefaultTypeInternal;
extern ChunkDefaultTypeInternal _Chunk_default_instance_;
class CopyChunkReply;
class CopyChunkReplyDefaultTypeInternal;
extern CopyChunkReplyDefaultTypeInternal _CopyChunkReply_default_instance_;
class CopyChunkRequest;
class CopyChunkRequestDefaultTypeInternal;
extern CopyChunkRequestDefaultTypeInternal _CopyChunkRequest_default_instance_;
class DataNode;
class DataNodeDefaultTypeInternal;
extern DataNodeDefaultTypeInternal _DataNode_default_instance_;
class DataNodeLocation;
class DataNodeLocationDefaultTypeInternal;
extern DataNodeLocationDefaultTypeInternal _DataNodeLocation_default_instance_;
class DeleteReply;
class DeleteReplyDefaultTypeInternal;
extern DeleteReplyDefaultTypeInternal _DeleteReply_default_instance_;
class DeleteRequest;
class DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class FindAddrReply;
class FindAddrReplyDefaultTypeInternal;
extern FindAddrReplyDefaultTypeInternal _FindAddrReply_default_instance_;
class FindAddrReply_ReplicaAddrs;
class FindAddrReply_ReplicaAddrsDefaultTypeInternal;
extern FindAddrReply_ReplicaAddrsDefaultTypeInternal _FindAddrReply_ReplicaAddrs_default_instance_;
class FindAddrRequest;
class FindAddrRequestDefaultTypeInternal;
extern FindAddrRequestDefaultTypeInternal _FindAddrRequest_default_instance_;
class GetSubDirNamesReply;
class GetSubDirNamesReplyDefaultTypeInternal;
extern GetSubDirNamesReplyDefaultTypeInternal _GetSubDirNamesReply_default_instance_;
class GetSubDirNamesRequest;
class GetSubDirNamesRequestDefaultTypeInternal;
extern GetSubDirNamesRequestDefaultTypeInternal _GetSubDirNamesRequest_default_instance_;
class GetWriteAddrReply;
class GetWriteAddrReplyDefaultTypeInternal;
extern GetWriteAddrReplyDefaultTypeInternal _GetWriteAddrReply_default_instance_;
class GetWriteAddrReply_ReplicaAddrs;
class GetWriteAddrReply_ReplicaAddrsDefaultTypeInternal;
extern GetWriteAddrReply_ReplicaAddrsDefaultTypeInternal _GetWriteAddrReply_ReplicaAddrs_default_instance_;
class GetWriteAddrRequest;
class GetWriteAddrRequestDefaultTypeInternal;
extern GetWriteAddrRequestDefaultTypeInternal _GetWriteAddrRequest_default_instance_;
class HeartbeatReply;
class HeartbeatReplyDefaultTypeInternal;
extern HeartbeatReplyDefaultTypeInternal _HeartbeatReply_default_instance_;
class HeartbeatRequest;
class HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class LogEntry;
class LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class MkdirReply;
class MkdirReplyDefaultTypeInternal;
extern MkdirReplyDefaultTypeInternal _MkdirReply_default_instance_;
class MkdirRequest;
class MkdirRequestDefaultTypeInternal;
extern MkdirRequestDefaultTypeInternal _MkdirRequest_default_instance_;
class ReadChunkReply;
class ReadChunkReplyDefaultTypeInternal;
extern ReadChunkReplyDefaultTypeInternal _ReadChunkReply_default_instance_;
class ReadChunkRequest;
class ReadChunkRequestDefaultTypeInternal;
extern ReadChunkRequestDefaultTypeInternal _ReadChunkRequest_default_instance_;
class RenameReply;
class RenameReplyDefaultTypeInternal;
extern RenameReplyDefaultTypeInternal _RenameReply_default_instance_;
class RenameRequest;
class RenameRequestDefaultTypeInternal;
extern RenameRequestDefaultTypeInternal _RenameRequest_default_instance_;
class ReportDataNodeReply;
class ReportDataNodeReplyDefaultTypeInternal;
extern ReportDataNodeReplyDefaultTypeInternal _ReportDataNodeReply_default_instance_;
class ReportDataNodeRequest;
class ReportDataNodeRequestDefaultTypeInternal;
extern ReportDataNodeRequestDefaultTypeInternal _ReportDataNodeRequest_default_instance_;
class RequestVoteArgs;
class RequestVoteArgsDefaultTypeInternal;
extern RequestVoteArgsDefaultTypeInternal _RequestVoteArgs_default_instance_;
class RequestVoteReply;
class RequestVoteReplyDefaultTypeInternal;
extern RequestVoteReplyDefaultTypeInternal _RequestVoteReply_default_instance_;
class StatReply;
class StatReplyDefaultTypeInternal;
extern StatReplyDefaultTypeInternal _StatReply_default_instance_;
class StatRequest;
class StatRequestDefaultTypeInternal;
extern StatRequestDefaultTypeInternal _StatRequest_default_instance_;
class WriteChunkReply;
class WriteChunkReplyDefaultTypeInternal;
extern WriteChunkReplyDefaultTypeInternal _WriteChunkReply_default_instance_;
class WriteChunkRequest;
class WriteChunkRequestDefaultTypeInternal;
extern WriteChunkRequestDefaultTypeInternal _WriteChunkRequest_default_instance_;
}  // namespace Rpc
namespace google {
namespace protobuf {
template<> ::Rpc::AppendEntriesArgs* Arena::CreateMaybeMessage<::Rpc::AppendEntriesArgs>(Arena*);
template<> ::Rpc::AppendEntriesReply* Arena::CreateMaybeMessage<::Rpc::AppendEntriesReply>(Arena*);
template<> ::Rpc::Chunk* Arena::CreateMaybeMessage<::Rpc::Chunk>(Arena*);
template<> ::Rpc::CopyChunkReply* Arena::CreateMaybeMessage<::Rpc::CopyChunkReply>(Arena*);
template<> ::Rpc::CopyChunkRequest* Arena::CreateMaybeMessage<::Rpc::CopyChunkRequest>(Arena*);
template<> ::Rpc::DataNode* Arena::CreateMaybeMessage<::Rpc::DataNode>(Arena*);
template<> ::Rpc::DataNodeLocation* Arena::CreateMaybeMessage<::Rpc::DataNodeLocation>(Arena*);
template<> ::Rpc::DeleteReply* Arena::CreateMaybeMessage<::Rpc::DeleteReply>(Arena*);
template<> ::Rpc::DeleteRequest* Arena::CreateMaybeMessage<::Rpc::DeleteRequest>(Arena*);
template<> ::Rpc::FindAddrReply* Arena::CreateMaybeMessage<::Rpc::FindAddrReply>(Arena*);
template<> ::Rpc::FindAddrReply_ReplicaAddrs* Arena::CreateMaybeMessage<::Rpc::FindAddrReply_ReplicaAddrs>(Arena*);
template<> ::Rpc::FindAddrRequest* Arena::CreateMaybeMessage<::Rpc::FindAddrRequest>(Arena*);
template<> ::Rpc::GetSubDirNamesReply* Arena::CreateMaybeMessage<::Rpc::GetSubDirNamesReply>(Arena*);
template<> ::Rpc::GetSubDirNamesRequest* Arena::CreateMaybeMessage<::Rpc::GetSubDirNamesRequest>(Arena*);
template<> ::Rpc::GetWriteAddrReply* Arena::CreateMaybeMessage<::Rpc::GetWriteAddrReply>(Arena*);
template<> ::Rpc::GetWriteAddrReply_ReplicaAddrs* Arena::CreateMaybeMessage<::Rpc::GetWriteAddrReply_ReplicaAddrs>(Arena*);
template<> ::Rpc::GetWriteAddrRequest* Arena::CreateMaybeMessage<::Rpc::GetWriteAddrRequest>(Arena*);
template<> ::Rpc::HeartbeatReply* Arena::CreateMaybeMessage<::Rpc::HeartbeatReply>(Arena*);
template<> ::Rpc::HeartbeatRequest* Arena::CreateMaybeMessage<::Rpc::HeartbeatRequest>(Arena*);
template<> ::Rpc::LogEntry* Arena::CreateMaybeMessage<::Rpc::LogEntry>(Arena*);
template<> ::Rpc::MkdirReply* Arena::CreateMaybeMessage<::Rpc::MkdirReply>(Arena*);
template<> ::Rpc::MkdirRequest* Arena::CreateMaybeMessage<::Rpc::MkdirRequest>(Arena*);
template<> ::Rpc::ReadChunkReply* Arena::CreateMaybeMessage<::Rpc::ReadChunkReply>(Arena*);
template<> ::Rpc::ReadChunkRequest* Arena::CreateMaybeMessage<::Rpc::ReadChunkRequest>(Arena*);
template<> ::Rpc::RenameReply* Arena::CreateMaybeMessage<::Rpc::RenameReply>(Arena*);
template<> ::Rpc::RenameRequest* Arena::CreateMaybeMessage<::Rpc::RenameRequest>(Arena*);
template<> ::Rpc::ReportDataNodeReply* Arena::CreateMaybeMessage<::Rpc::ReportDataNodeReply>(Arena*);
template<> ::Rpc::ReportDataNodeRequest* Arena::CreateMaybeMessage<::Rpc::ReportDataNodeRequest>(Arena*);
template<> ::Rpc::RequestVoteArgs* Arena::CreateMaybeMessage<::Rpc::RequestVoteArgs>(Arena*);
template<> ::Rpc::RequestVoteReply* Arena::CreateMaybeMessage<::Rpc::RequestVoteReply>(Arena*);
template<> ::Rpc::StatReply* Arena::CreateMaybeMessage<::Rpc::StatReply>(Arena*);
template<> ::Rpc::StatRequest* Arena::CreateMaybeMessage<::Rpc::StatRequest>(Arena*);
template<> ::Rpc::WriteChunkReply* Arena::CreateMaybeMessage<::Rpc::WriteChunkReply>(Arena*);
template<> ::Rpc::WriteChunkRequest* Arena::CreateMaybeMessage<::Rpc::WriteChunkRequest>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace Rpc {

// ===================================================================

class LogEntry : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.LogEntry) */ {
 public:
  LogEntry();
  virtual ~LogEntry();

  LogEntry(const LogEntry& from);

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LogEntry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(LogEntry* other);
  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LogEntry* New() const final {
    return CreateMaybeMessage<LogEntry>(NULL);
  }

  LogEntry* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LogEntry& from);
  void MergeFrom(const LogEntry& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filepath = 6;
  void clear_filepath();
  static const int kFilepathFieldNumber = 6;
  const ::std::string& filepath() const;
  void set_filepath(const ::std::string& value);
  #if LANG_CXX11
  void set_filepath(::std::string&& value);
  #endif
  void set_filepath(const char* value);
  void set_filepath(const char* value, size_t size);
  ::std::string* mutable_filepath();
  ::std::string* release_filepath();
  void set_allocated_filepath(::std::string* filepath);

  // string src = 7;
  void clear_src();
  static const int kSrcFieldNumber = 7;
  const ::std::string& src() const;
  void set_src(const ::std::string& value);
  #if LANG_CXX11
  void set_src(::std::string&& value);
  #endif
  void set_src(const char* value);
  void set_src(const char* value, size_t size);
  ::std::string* mutable_src();
  ::std::string* release_src();
  void set_allocated_src(::std::string* src);

  // string des = 8;
  void clear_des();
  static const int kDesFieldNumber = 8;
  const ::std::string& des() const;
  void set_des(const ::std::string& value);
  #if LANG_CXX11
  void set_des(::std::string&& value);
  #endif
  void set_des(const char* value);
  void set_des(const char* value, size_t size);
  ::std::string* mutable_des();
  ::std::string* release_des();
  void set_allocated_des(::std::string* des);

  // .Rpc.GetWriteAddrRequest getw = 3;
  bool has_getw() const;
  void clear_getw();
  static const int kGetwFieldNumber = 3;
  private:
  const ::Rpc::GetWriteAddrRequest& _internal_getw() const;
  public:
  const ::Rpc::GetWriteAddrRequest& getw() const;
  ::Rpc::GetWriteAddrRequest* release_getw();
  ::Rpc::GetWriteAddrRequest* mutable_getw();
  void set_allocated_getw(::Rpc::GetWriteAddrRequest* getw);

  // .Rpc.RenameRequest rename = 4;
  bool has_rename() const;
  void clear_rename();
  static const int kRenameFieldNumber = 4;
  private:
  const ::Rpc::RenameRequest& _internal_rename() const;
  public:
  const ::Rpc::RenameRequest& rename() const;
  ::Rpc::RenameRequest* release_rename();
  ::Rpc::RenameRequest* mutable_rename();
  void set_allocated_rename(::Rpc::RenameRequest* rename);

  // .Rpc.DeleteRequest del = 5;
  bool has_del() const;
  void clear_del();
  static const int kDelFieldNumber = 5;
  private:
  const ::Rpc::DeleteRequest& _internal_del() const;
  public:
  const ::Rpc::DeleteRequest& del() const;
  ::Rpc::DeleteRequest* release_del();
  ::Rpc::DeleteRequest* mutable_del();
  void set_allocated_del(::Rpc::DeleteRequest* del);

  // int32 Term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // int32 command = 2;
  void clear_command();
  static const int kCommandFieldNumber = 2;
  ::google::protobuf::int32 command() const;
  void set_command(::google::protobuf::int32 value);

  // int64 size = 9;
  void clear_size();
  static const int kSizeFieldNumber = 9;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.LogEntry)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filepath_;
  ::google::protobuf::internal::ArenaStringPtr src_;
  ::google::protobuf::internal::ArenaStringPtr des_;
  ::Rpc::GetWriteAddrRequest* getw_;
  ::Rpc::RenameRequest* rename_;
  ::Rpc::DeleteRequest* del_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 command_;
  ::google::protobuf::int64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppendEntriesArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.AppendEntriesArgs) */ {
 public:
  AppendEntriesArgs();
  virtual ~AppendEntriesArgs();

  AppendEntriesArgs(const AppendEntriesArgs& from);

  inline AppendEntriesArgs& operator=(const AppendEntriesArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesArgs(AppendEntriesArgs&& from) noexcept
    : AppendEntriesArgs() {
    *this = ::std::move(from);
  }

  inline AppendEntriesArgs& operator=(AppendEntriesArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesArgs* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesArgs*>(
               &_AppendEntriesArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(AppendEntriesArgs* other);
  friend void swap(AppendEntriesArgs& a, AppendEntriesArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesArgs* New() const final {
    return CreateMaybeMessage<AppendEntriesArgs>(NULL);
  }

  AppendEntriesArgs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntriesArgs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AppendEntriesArgs& from);
  void MergeFrom(const AppendEntriesArgs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .Rpc.LogEntry Entries = 1;
  int entries_size() const;
  void clear_entries();
  static const int kEntriesFieldNumber = 1;
  ::Rpc::LogEntry* mutable_entries(int index);
  ::google::protobuf::RepeatedPtrField< ::Rpc::LogEntry >*
      mutable_entries();
  const ::Rpc::LogEntry& entries(int index) const;
  ::Rpc::LogEntry* add_entries();
  const ::google::protobuf::RepeatedPtrField< ::Rpc::LogEntry >&
      entries() const;

  // int32 ATerm = 2;
  void clear_aterm();
  static const int kATermFieldNumber = 2;
  ::google::protobuf::int32 aterm() const;
  void set_aterm(::google::protobuf::int32 value);

  // int32 LeaderId = 3;
  void clear_leaderid();
  static const int kLeaderIdFieldNumber = 3;
  ::google::protobuf::int32 leaderid() const;
  void set_leaderid(::google::protobuf::int32 value);

  // int32 PrevLogIndex = 4;
  void clear_prevlogindex();
  static const int kPrevLogIndexFieldNumber = 4;
  ::google::protobuf::int32 prevlogindex() const;
  void set_prevlogindex(::google::protobuf::int32 value);

  // int32 PrevLogTerm = 5;
  void clear_prevlogterm();
  static const int kPrevLogTermFieldNumber = 5;
  ::google::protobuf::int32 prevlogterm() const;
  void set_prevlogterm(::google::protobuf::int32 value);

  // int32 LeaderCommit = 6;
  void clear_leadercommit();
  static const int kLeaderCommitFieldNumber = 6;
  ::google::protobuf::int32 leadercommit() const;
  void set_leadercommit(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rpc.AppendEntriesArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::Rpc::LogEntry > entries_;
  ::google::protobuf::int32 aterm_;
  ::google::protobuf::int32 leaderid_;
  ::google::protobuf::int32 prevlogindex_;
  ::google::protobuf::int32 prevlogterm_;
  ::google::protobuf::int32 leadercommit_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AppendEntriesReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.AppendEntriesReply) */ {
 public:
  AppendEntriesReply();
  virtual ~AppendEntriesReply();

  AppendEntriesReply(const AppendEntriesReply& from);

  inline AppendEntriesReply& operator=(const AppendEntriesReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AppendEntriesReply(AppendEntriesReply&& from) noexcept
    : AppendEntriesReply() {
    *this = ::std::move(from);
  }

  inline AppendEntriesReply& operator=(AppendEntriesReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const AppendEntriesReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AppendEntriesReply* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesReply*>(
               &_AppendEntriesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(AppendEntriesReply* other);
  friend void swap(AppendEntriesReply& a, AppendEntriesReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AppendEntriesReply* New() const final {
    return CreateMaybeMessage<AppendEntriesReply>(NULL);
  }

  AppendEntriesReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AppendEntriesReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AppendEntriesReply& from);
  void MergeFrom(const AppendEntriesReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 Term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // bool Success = 2;
  void clear_success();
  static const int kSuccessFieldNumber = 2;
  bool success() const;
  void set_success(bool value);

  // int32 UpNextIndex = 3;
  void clear_upnextindex();
  static const int kUpNextIndexFieldNumber = 3;
  ::google::protobuf::int32 upnextindex() const;
  void set_upnextindex(::google::protobuf::int32 value);

  // int32 AppendEntriesState = 4;
  void clear_appendentriesstate();
  static const int kAppendEntriesStateFieldNumber = 4;
  ::google::protobuf::int32 appendentriesstate() const;
  void set_appendentriesstate(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rpc.AppendEntriesReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 term_;
  bool success_;
  ::google::protobuf::int32 upnextindex_;
  ::google::protobuf::int32 appendentriesstate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestVoteArgs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.RequestVoteArgs) */ {
 public:
  RequestVoteArgs();
  virtual ~RequestVoteArgs();

  RequestVoteArgs(const RequestVoteArgs& from);

  inline RequestVoteArgs& operator=(const RequestVoteArgs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteArgs(RequestVoteArgs&& from) noexcept
    : RequestVoteArgs() {
    *this = ::std::move(from);
  }

  inline RequestVoteArgs& operator=(RequestVoteArgs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteArgs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteArgs* internal_default_instance() {
    return reinterpret_cast<const RequestVoteArgs*>(
               &_RequestVoteArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(RequestVoteArgs* other);
  friend void swap(RequestVoteArgs& a, RequestVoteArgs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteArgs* New() const final {
    return CreateMaybeMessage<RequestVoteArgs>(NULL);
  }

  RequestVoteArgs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteArgs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestVoteArgs& from);
  void MergeFrom(const RequestVoteArgs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteArgs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // int32 candidateId = 2;
  void clear_candidateid();
  static const int kCandidateIdFieldNumber = 2;
  ::google::protobuf::int32 candidateid() const;
  void set_candidateid(::google::protobuf::int32 value);

  // int32 lastLogindex = 3;
  void clear_lastlogindex();
  static const int kLastLogindexFieldNumber = 3;
  ::google::protobuf::int32 lastlogindex() const;
  void set_lastlogindex(::google::protobuf::int32 value);

  // int32 lastLogterm = 4;
  void clear_lastlogterm();
  static const int kLastLogtermFieldNumber = 4;
  ::google::protobuf::int32 lastlogterm() const;
  void set_lastlogterm(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Rpc.RequestVoteArgs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 term_;
  ::google::protobuf::int32 candidateid_;
  ::google::protobuf::int32 lastlogindex_;
  ::google::protobuf::int32 lastlogterm_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RequestVoteReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.RequestVoteReply) */ {
 public:
  RequestVoteReply();
  virtual ~RequestVoteReply();

  RequestVoteReply(const RequestVoteReply& from);

  inline RequestVoteReply& operator=(const RequestVoteReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RequestVoteReply(RequestVoteReply&& from) noexcept
    : RequestVoteReply() {
    *this = ::std::move(from);
  }

  inline RequestVoteReply& operator=(RequestVoteReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RequestVoteReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RequestVoteReply* internal_default_instance() {
    return reinterpret_cast<const RequestVoteReply*>(
               &_RequestVoteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(RequestVoteReply* other);
  friend void swap(RequestVoteReply& a, RequestVoteReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RequestVoteReply* New() const final {
    return CreateMaybeMessage<RequestVoteReply>(NULL);
  }

  RequestVoteReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RequestVoteReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RequestVoteReply& from);
  void MergeFrom(const RequestVoteReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 term = 1;
  void clear_term();
  static const int kTermFieldNumber = 1;
  ::google::protobuf::int32 term() const;
  void set_term(::google::protobuf::int32 value);

  // bool votegranted = 2;
  void clear_votegranted();
  static const int kVotegrantedFieldNumber = 2;
  bool votegranted() const;
  void set_votegranted(bool value);

  // @@protoc_insertion_point(class_scope:Rpc.RequestVoteReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 term_;
  bool votegranted_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindAddrRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.FindAddrRequest) */ {
 public:
  FindAddrRequest();
  virtual ~FindAddrRequest();

  FindAddrRequest(const FindAddrRequest& from);

  inline FindAddrRequest& operator=(const FindAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindAddrRequest(FindAddrRequest&& from) noexcept
    : FindAddrRequest() {
    *this = ::std::move(from);
  }

  inline FindAddrRequest& operator=(FindAddrRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindAddrRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindAddrRequest* internal_default_instance() {
    return reinterpret_cast<const FindAddrRequest*>(
               &_FindAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FindAddrRequest* other);
  friend void swap(FindAddrRequest& a, FindAddrRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindAddrRequest* New() const final {
    return CreateMaybeMessage<FindAddrRequest>(NULL);
  }

  FindAddrRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindAddrRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindAddrRequest& from);
  void MergeFrom(const FindAddrRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filepath = 1;
  void clear_filepath();
  static const int kFilepathFieldNumber = 1;
  const ::std::string& filepath() const;
  void set_filepath(const ::std::string& value);
  #if LANG_CXX11
  void set_filepath(::std::string&& value);
  #endif
  void set_filepath(const char* value);
  void set_filepath(const char* value, size_t size);
  ::std::string* mutable_filepath();
  ::std::string* release_filepath();
  void set_allocated_filepath(::std::string* filepath);

  // @@protoc_insertion_point(class_scope:Rpc.FindAddrRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filepath_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindAddrReply_ReplicaAddrs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.FindAddrReply.ReplicaAddrs) */ {
 public:
  FindAddrReply_ReplicaAddrs();
  virtual ~FindAddrReply_ReplicaAddrs();

  FindAddrReply_ReplicaAddrs(const FindAddrReply_ReplicaAddrs& from);

  inline FindAddrReply_ReplicaAddrs& operator=(const FindAddrReply_ReplicaAddrs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindAddrReply_ReplicaAddrs(FindAddrReply_ReplicaAddrs&& from) noexcept
    : FindAddrReply_ReplicaAddrs() {
    *this = ::std::move(from);
  }

  inline FindAddrReply_ReplicaAddrs& operator=(FindAddrReply_ReplicaAddrs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindAddrReply_ReplicaAddrs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindAddrReply_ReplicaAddrs* internal_default_instance() {
    return reinterpret_cast<const FindAddrReply_ReplicaAddrs*>(
               &_FindAddrReply_ReplicaAddrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FindAddrReply_ReplicaAddrs* other);
  friend void swap(FindAddrReply_ReplicaAddrs& a, FindAddrReply_ReplicaAddrs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindAddrReply_ReplicaAddrs* New() const final {
    return CreateMaybeMessage<FindAddrReply_ReplicaAddrs>(NULL);
  }

  FindAddrReply_ReplicaAddrs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindAddrReply_ReplicaAddrs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindAddrReply_ReplicaAddrs& from);
  void MergeFrom(const FindAddrReply_ReplicaAddrs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrReply_ReplicaAddrs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ip_ports = 1;
  int ip_ports_size() const;
  void clear_ip_ports();
  static const int kIpPortsFieldNumber = 1;
  const ::std::string& ip_ports(int index) const;
  ::std::string* mutable_ip_ports(int index);
  void set_ip_ports(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ip_ports(int index, ::std::string&& value);
  #endif
  void set_ip_ports(int index, const char* value);
  void set_ip_ports(int index, const char* value, size_t size);
  ::std::string* add_ip_ports();
  void add_ip_ports(const ::std::string& value);
  #if LANG_CXX11
  void add_ip_ports(::std::string&& value);
  #endif
  void add_ip_ports(const char* value);
  void add_ip_ports(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_ports() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_ports();

  // @@protoc_insertion_point(class_scope:Rpc.FindAddrReply.ReplicaAddrs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_ports_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class FindAddrReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.FindAddrReply) */ {
 public:
  FindAddrReply();
  virtual ~FindAddrReply();

  FindAddrReply(const FindAddrReply& from);

  inline FindAddrReply& operator=(const FindAddrReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindAddrReply(FindAddrReply&& from) noexcept
    : FindAddrReply() {
    *this = ::std::move(from);
  }

  inline FindAddrReply& operator=(FindAddrReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const FindAddrReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindAddrReply* internal_default_instance() {
    return reinterpret_cast<const FindAddrReply*>(
               &_FindAddrReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FindAddrReply* other);
  friend void swap(FindAddrReply& a, FindAddrReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindAddrReply* New() const final {
    return CreateMaybeMessage<FindAddrReply>(NULL);
  }

  FindAddrReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindAddrReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindAddrReply& from);
  void MergeFrom(const FindAddrReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FindAddrReply_ReplicaAddrs ReplicaAddrs;

  // accessors -------------------------------------------------------

  // repeated int64 chunk_handles = 1;
  int chunk_handles_size() const;
  void clear_chunk_handles();
  static const int kChunkHandlesFieldNumber = 1;
  ::google::protobuf::int64 chunk_handles(int index) const;
  void set_chunk_handles(int index, ::google::protobuf::int64 value);
  void add_chunk_handles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      chunk_handles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_chunk_handles();

  // repeated .Rpc.FindAddrReply.ReplicaAddrs addrs = 2;
  int addrs_size() const;
  void clear_addrs();
  static const int kAddrsFieldNumber = 2;
  ::Rpc::FindAddrReply_ReplicaAddrs* mutable_addrs(int index);
  ::google::protobuf::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >*
      mutable_addrs();
  const ::Rpc::FindAddrReply_ReplicaAddrs& addrs(int index) const;
  ::Rpc::FindAddrReply_ReplicaAddrs* add_addrs();
  const ::google::protobuf::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >&
      addrs() const;

  // @@protoc_insertion_point(class_scope:Rpc.FindAddrReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > chunk_handles_;
  mutable int _chunk_handles_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs > addrs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWriteAddrRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.GetWriteAddrRequest) */ {
 public:
  GetWriteAddrRequest();
  virtual ~GetWriteAddrRequest();

  GetWriteAddrRequest(const GetWriteAddrRequest& from);

  inline GetWriteAddrRequest& operator=(const GetWriteAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWriteAddrRequest(GetWriteAddrRequest&& from) noexcept
    : GetWriteAddrRequest() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrRequest& operator=(GetWriteAddrRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWriteAddrRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWriteAddrRequest* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrRequest*>(
               &_GetWriteAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(GetWriteAddrRequest* other);
  friend void swap(GetWriteAddrRequest& a, GetWriteAddrRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWriteAddrRequest* New() const final {
    return CreateMaybeMessage<GetWriteAddrRequest>(NULL);
  }

  GetWriteAddrRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWriteAddrRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWriteAddrRequest& from);
  void MergeFrom(const GetWriteAddrRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string remote_file_path = 1;
  void clear_remote_file_path();
  static const int kRemoteFilePathFieldNumber = 1;
  const ::std::string& remote_file_path() const;
  void set_remote_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_file_path(::std::string&& value);
  #endif
  void set_remote_file_path(const char* value);
  void set_remote_file_path(const char* value, size_t size);
  ::std::string* mutable_remote_file_path();
  ::std::string* release_remote_file_path();
  void set_allocated_remote_file_path(::std::string* remote_file_path);

  // int64 write_data_size = 2;
  void clear_write_data_size();
  static const int kWriteDataSizeFieldNumber = 2;
  ::google::protobuf::int64 write_data_size() const;
  void set_write_data_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.GetWriteAddrRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr remote_file_path_;
  ::google::protobuf::int64 write_data_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWriteAddrReply_ReplicaAddrs : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.GetWriteAddrReply.ReplicaAddrs) */ {
 public:
  GetWriteAddrReply_ReplicaAddrs();
  virtual ~GetWriteAddrReply_ReplicaAddrs();

  GetWriteAddrReply_ReplicaAddrs(const GetWriteAddrReply_ReplicaAddrs& from);

  inline GetWriteAddrReply_ReplicaAddrs& operator=(const GetWriteAddrReply_ReplicaAddrs& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWriteAddrReply_ReplicaAddrs(GetWriteAddrReply_ReplicaAddrs&& from) noexcept
    : GetWriteAddrReply_ReplicaAddrs() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrReply_ReplicaAddrs& operator=(GetWriteAddrReply_ReplicaAddrs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWriteAddrReply_ReplicaAddrs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWriteAddrReply_ReplicaAddrs* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrReply_ReplicaAddrs*>(
               &_GetWriteAddrReply_ReplicaAddrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(GetWriteAddrReply_ReplicaAddrs* other);
  friend void swap(GetWriteAddrReply_ReplicaAddrs& a, GetWriteAddrReply_ReplicaAddrs& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWriteAddrReply_ReplicaAddrs* New() const final {
    return CreateMaybeMessage<GetWriteAddrReply_ReplicaAddrs>(NULL);
  }

  GetWriteAddrReply_ReplicaAddrs* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWriteAddrReply_ReplicaAddrs>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWriteAddrReply_ReplicaAddrs& from);
  void MergeFrom(const GetWriteAddrReply_ReplicaAddrs& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrReply_ReplicaAddrs* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ip_ports = 1;
  int ip_ports_size() const;
  void clear_ip_ports();
  static const int kIpPortsFieldNumber = 1;
  const ::std::string& ip_ports(int index) const;
  ::std::string* mutable_ip_ports(int index);
  void set_ip_ports(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ip_ports(int index, ::std::string&& value);
  #endif
  void set_ip_ports(int index, const char* value);
  void set_ip_ports(int index, const char* value, size_t size);
  ::std::string* add_ip_ports();
  void add_ip_ports(const ::std::string& value);
  #if LANG_CXX11
  void add_ip_ports(::std::string&& value);
  #endif
  void add_ip_ports(const char* value);
  void add_ip_ports(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ip_ports() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ip_ports();

  // @@protoc_insertion_point(class_scope:Rpc.GetWriteAddrReply.ReplicaAddrs)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ip_ports_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetWriteAddrReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.GetWriteAddrReply) */ {
 public:
  GetWriteAddrReply();
  virtual ~GetWriteAddrReply();

  GetWriteAddrReply(const GetWriteAddrReply& from);

  inline GetWriteAddrReply& operator=(const GetWriteAddrReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetWriteAddrReply(GetWriteAddrReply&& from) noexcept
    : GetWriteAddrReply() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrReply& operator=(GetWriteAddrReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetWriteAddrReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetWriteAddrReply* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrReply*>(
               &_GetWriteAddrReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(GetWriteAddrReply* other);
  friend void swap(GetWriteAddrReply& a, GetWriteAddrReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetWriteAddrReply* New() const final {
    return CreateMaybeMessage<GetWriteAddrReply>(NULL);
  }

  GetWriteAddrReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetWriteAddrReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetWriteAddrReply& from);
  void MergeFrom(const GetWriteAddrReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetWriteAddrReply_ReplicaAddrs ReplicaAddrs;

  // accessors -------------------------------------------------------

  // repeated int64 chunk_handles = 1;
  int chunk_handles_size() const;
  void clear_chunk_handles();
  static const int kChunkHandlesFieldNumber = 1;
  ::google::protobuf::int64 chunk_handles(int index) const;
  void set_chunk_handles(int index, ::google::protobuf::int64 value);
  void add_chunk_handles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      chunk_handles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_chunk_handles();

  // repeated .Rpc.GetWriteAddrReply.ReplicaAddrs addrs = 2;
  int addrs_size() const;
  void clear_addrs();
  static const int kAddrsFieldNumber = 2;
  ::Rpc::GetWriteAddrReply_ReplicaAddrs* mutable_addrs(int index);
  ::google::protobuf::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >*
      mutable_addrs();
  const ::Rpc::GetWriteAddrReply_ReplicaAddrs& addrs(int index) const;
  ::Rpc::GetWriteAddrReply_ReplicaAddrs* add_addrs();
  const ::google::protobuf::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >&
      addrs() const;

  // @@protoc_insertion_point(class_scope:Rpc.GetWriteAddrReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > chunk_handles_;
  mutable int _chunk_handles_cached_byte_size_;
  ::google::protobuf::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs > addrs_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubDirNamesRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.GetSubDirNamesRequest) */ {
 public:
  GetSubDirNamesRequest();
  virtual ~GetSubDirNamesRequest();

  GetSubDirNamesRequest(const GetSubDirNamesRequest& from);

  inline GetSubDirNamesRequest& operator=(const GetSubDirNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubDirNamesRequest(GetSubDirNamesRequest&& from) noexcept
    : GetSubDirNamesRequest() {
    *this = ::std::move(from);
  }

  inline GetSubDirNamesRequest& operator=(GetSubDirNamesRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubDirNamesRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubDirNamesRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubDirNamesRequest*>(
               &_GetSubDirNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(GetSubDirNamesRequest* other);
  friend void swap(GetSubDirNamesRequest& a, GetSubDirNamesRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubDirNamesRequest* New() const final {
    return CreateMaybeMessage<GetSubDirNamesRequest>(NULL);
  }

  GetSubDirNamesRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSubDirNamesRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSubDirNamesRequest& from);
  void MergeFrom(const GetSubDirNamesRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubDirNamesRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_path = 1;
  void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  const ::std::string& file_path() const;
  void set_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_file_path(::std::string&& value);
  #endif
  void set_file_path(const char* value);
  void set_file_path(const char* value, size_t size);
  ::std::string* mutable_file_path();
  ::std::string* release_file_path();
  void set_allocated_file_path(::std::string* file_path);

  // @@protoc_insertion_point(class_scope:Rpc.GetSubDirNamesRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class GetSubDirNamesReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.GetSubDirNamesReply) */ {
 public:
  GetSubDirNamesReply();
  virtual ~GetSubDirNamesReply();

  GetSubDirNamesReply(const GetSubDirNamesReply& from);

  inline GetSubDirNamesReply& operator=(const GetSubDirNamesReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetSubDirNamesReply(GetSubDirNamesReply&& from) noexcept
    : GetSubDirNamesReply() {
    *this = ::std::move(from);
  }

  inline GetSubDirNamesReply& operator=(GetSubDirNamesReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const GetSubDirNamesReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetSubDirNamesReply* internal_default_instance() {
    return reinterpret_cast<const GetSubDirNamesReply*>(
               &_GetSubDirNamesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(GetSubDirNamesReply* other);
  friend void swap(GetSubDirNamesReply& a, GetSubDirNamesReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetSubDirNamesReply* New() const final {
    return CreateMaybeMessage<GetSubDirNamesReply>(NULL);
  }

  GetSubDirNamesReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetSubDirNamesReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetSubDirNamesReply& from);
  void MergeFrom(const GetSubDirNamesReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubDirNamesReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string subdir_file_names = 1;
  int subdir_file_names_size() const;
  void clear_subdir_file_names();
  static const int kSubdirFileNamesFieldNumber = 1;
  const ::std::string& subdir_file_names(int index) const;
  ::std::string* mutable_subdir_file_names(int index);
  void set_subdir_file_names(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_subdir_file_names(int index, ::std::string&& value);
  #endif
  void set_subdir_file_names(int index, const char* value);
  void set_subdir_file_names(int index, const char* value, size_t size);
  ::std::string* add_subdir_file_names();
  void add_subdir_file_names(const ::std::string& value);
  #if LANG_CXX11
  void add_subdir_file_names(::std::string&& value);
  #endif
  void add_subdir_file_names(const char* value);
  void add_subdir_file_names(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& subdir_file_names() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_subdir_file_names();

  // @@protoc_insertion_point(class_scope:Rpc.GetSubDirNamesReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> subdir_file_names_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MkdirRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.MkdirRequest) */ {
 public:
  MkdirRequest();
  virtual ~MkdirRequest();

  MkdirRequest(const MkdirRequest& from);

  inline MkdirRequest& operator=(const MkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MkdirRequest(MkdirRequest&& from) noexcept
    : MkdirRequest() {
    *this = ::std::move(from);
  }

  inline MkdirRequest& operator=(MkdirRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MkdirRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MkdirRequest* internal_default_instance() {
    return reinterpret_cast<const MkdirRequest*>(
               &_MkdirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(MkdirRequest* other);
  friend void swap(MkdirRequest& a, MkdirRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MkdirRequest* New() const final {
    return CreateMaybeMessage<MkdirRequest>(NULL);
  }

  MkdirRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MkdirRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MkdirRequest& from);
  void MergeFrom(const MkdirRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string new_file_path = 1;
  void clear_new_file_path();
  static const int kNewFilePathFieldNumber = 1;
  const ::std::string& new_file_path() const;
  void set_new_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_new_file_path(::std::string&& value);
  #endif
  void set_new_file_path(const char* value);
  void set_new_file_path(const char* value, size_t size);
  ::std::string* mutable_new_file_path();
  ::std::string* release_new_file_path();
  void set_allocated_new_file_path(::std::string* new_file_path);

  // @@protoc_insertion_point(class_scope:Rpc.MkdirRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr new_file_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MkdirReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.MkdirReply) */ {
 public:
  MkdirReply();
  virtual ~MkdirReply();

  MkdirReply(const MkdirReply& from);

  inline MkdirReply& operator=(const MkdirReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MkdirReply(MkdirReply&& from) noexcept
    : MkdirReply() {
    *this = ::std::move(from);
  }

  inline MkdirReply& operator=(MkdirReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MkdirReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MkdirReply* internal_default_instance() {
    return reinterpret_cast<const MkdirReply*>(
               &_MkdirReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(MkdirReply* other);
  friend void swap(MkdirReply& a, MkdirReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MkdirReply* New() const final {
    return CreateMaybeMessage<MkdirReply>(NULL);
  }

  MkdirReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MkdirReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MkdirReply& from);
  void MergeFrom(const MkdirReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.MkdirReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RenameRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.RenameRequest) */ {
 public:
  RenameRequest();
  virtual ~RenameRequest();

  RenameRequest(const RenameRequest& from);

  inline RenameRequest& operator=(const RenameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RenameRequest(RenameRequest&& from) noexcept
    : RenameRequest() {
    *this = ::std::move(from);
  }

  inline RenameRequest& operator=(RenameRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RenameRequest* internal_default_instance() {
    return reinterpret_cast<const RenameRequest*>(
               &_RenameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(RenameRequest* other);
  friend void swap(RenameRequest& a, RenameRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RenameRequest* New() const final {
    return CreateMaybeMessage<RenameRequest>(NULL);
  }

  RenameRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RenameRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RenameRequest& from);
  void MergeFrom(const RenameRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string src_path = 1;
  void clear_src_path();
  static const int kSrcPathFieldNumber = 1;
  const ::std::string& src_path() const;
  void set_src_path(const ::std::string& value);
  #if LANG_CXX11
  void set_src_path(::std::string&& value);
  #endif
  void set_src_path(const char* value);
  void set_src_path(const char* value, size_t size);
  ::std::string* mutable_src_path();
  ::std::string* release_src_path();
  void set_allocated_src_path(::std::string* src_path);

  // string des_path = 2;
  void clear_des_path();
  static const int kDesPathFieldNumber = 2;
  const ::std::string& des_path() const;
  void set_des_path(const ::std::string& value);
  #if LANG_CXX11
  void set_des_path(::std::string&& value);
  #endif
  void set_des_path(const char* value);
  void set_des_path(const char* value, size_t size);
  ::std::string* mutable_des_path();
  ::std::string* release_des_path();
  void set_allocated_des_path(::std::string* des_path);

  // @@protoc_insertion_point(class_scope:Rpc.RenameRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr src_path_;
  ::google::protobuf::internal::ArenaStringPtr des_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RenameReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.RenameReply) */ {
 public:
  RenameReply();
  virtual ~RenameReply();

  RenameReply(const RenameReply& from);

  inline RenameReply& operator=(const RenameReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RenameReply(RenameReply&& from) noexcept
    : RenameReply() {
    *this = ::std::move(from);
  }

  inline RenameReply& operator=(RenameReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const RenameReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RenameReply* internal_default_instance() {
    return reinterpret_cast<const RenameReply*>(
               &_RenameReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(RenameReply* other);
  friend void swap(RenameReply& a, RenameReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RenameReply* New() const final {
    return CreateMaybeMessage<RenameReply>(NULL);
  }

  RenameReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RenameReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RenameReply& from);
  void MergeFrom(const RenameReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.RenameReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.DeleteRequest) */ {
 public:
  DeleteRequest();
  virtual ~DeleteRequest();

  DeleteRequest(const DeleteRequest& from);

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(DeleteRequest* other);
  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRequest* New() const final {
    return CreateMaybeMessage<DeleteRequest>(NULL);
  }

  DeleteRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRequest& from);
  void MergeFrom(const DeleteRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string remote_file_path = 1;
  void clear_remote_file_path();
  static const int kRemoteFilePathFieldNumber = 1;
  const ::std::string& remote_file_path() const;
  void set_remote_file_path(const ::std::string& value);
  #if LANG_CXX11
  void set_remote_file_path(::std::string&& value);
  #endif
  void set_remote_file_path(const char* value);
  void set_remote_file_path(const char* value, size_t size);
  ::std::string* mutable_remote_file_path();
  ::std::string* release_remote_file_path();
  void set_allocated_remote_file_path(::std::string* remote_file_path);

  // @@protoc_insertion_point(class_scope:Rpc.DeleteRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr remote_file_path_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.DeleteReply) */ {
 public:
  DeleteReply();
  virtual ~DeleteReply();

  DeleteReply(const DeleteReply& from);

  inline DeleteReply& operator=(const DeleteReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteReply(DeleteReply&& from) noexcept
    : DeleteReply() {
    *this = ::std::move(from);
  }

  inline DeleteReply& operator=(DeleteReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteReply* internal_default_instance() {
    return reinterpret_cast<const DeleteReply*>(
               &_DeleteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(DeleteReply* other);
  friend void swap(DeleteReply& a, DeleteReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteReply* New() const final {
    return CreateMaybeMessage<DeleteReply>(NULL);
  }

  DeleteReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteReply& from);
  void MergeFrom(const DeleteReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.DeleteReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.StatRequest) */ {
 public:
  StatRequest();
  virtual ~StatRequest();

  StatRequest(const StatRequest& from);

  inline StatRequest& operator=(const StatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatRequest(StatRequest&& from) noexcept
    : StatRequest() {
    *this = ::std::move(from);
  }

  inline StatRequest& operator=(StatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatRequest* internal_default_instance() {
    return reinterpret_cast<const StatRequest*>(
               &_StatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(StatRequest* other);
  friend void swap(StatRequest& a, StatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatRequest* New() const final {
    return CreateMaybeMessage<StatRequest>(NULL);
  }

  StatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatRequest& from);
  void MergeFrom(const StatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string filepath = 1;
  void clear_filepath();
  static const int kFilepathFieldNumber = 1;
  const ::std::string& filepath() const;
  void set_filepath(const ::std::string& value);
  #if LANG_CXX11
  void set_filepath(::std::string&& value);
  #endif
  void set_filepath(const char* value);
  void set_filepath(const char* value, size_t size);
  ::std::string* mutable_filepath();
  ::std::string* release_filepath();
  void set_allocated_filepath(::std::string* filepath);

  // @@protoc_insertion_point(class_scope:Rpc.StatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr filepath_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.StatReply) */ {
 public:
  StatReply();
  virtual ~StatReply();

  StatReply(const StatReply& from);

  inline StatReply& operator=(const StatReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StatReply(StatReply&& from) noexcept
    : StatReply() {
    *this = ::std::move(from);
  }

  inline StatReply& operator=(StatReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StatReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StatReply* internal_default_instance() {
    return reinterpret_cast<const StatReply*>(
               &_StatReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(StatReply* other);
  friend void swap(StatReply& a, StatReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StatReply* New() const final {
    return CreateMaybeMessage<StatReply>(NULL);
  }

  StatReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StatReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StatReply& from);
  void MergeFrom(const StatReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string file_name = 2;
  void clear_file_name();
  static const int kFileNameFieldNumber = 2;
  const ::std::string& file_name() const;
  void set_file_name(const ::std::string& value);
  #if LANG_CXX11
  void set_file_name(::std::string&& value);
  #endif
  void set_file_name(const char* value);
  void set_file_name(const char* value, size_t size);
  ::std::string* mutable_file_name();
  ::std::string* release_file_name();
  void set_allocated_file_name(::std::string* file_name);

  // uint64 file_size = 3;
  void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  ::google::protobuf::uint64 file_size() const;
  void set_file_size(::google::protobuf::uint64 value);

  // bool existed = 1;
  void clear_existed();
  static const int kExistedFieldNumber = 1;
  bool existed() const;
  void set_existed(bool value);

  // @@protoc_insertion_point(class_scope:Rpc.StatReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr file_name_;
  ::google::protobuf::uint64 file_size_;
  bool existed_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteChunkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.WriteChunkRequest) */ {
 public:
  WriteChunkRequest();
  virtual ~WriteChunkRequest();

  WriteChunkRequest(const WriteChunkRequest& from);

  inline WriteChunkRequest& operator=(const WriteChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteChunkRequest(WriteChunkRequest&& from) noexcept
    : WriteChunkRequest() {
    *this = ::std::move(from);
  }

  inline WriteChunkRequest& operator=(WriteChunkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteChunkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteChunkRequest* internal_default_instance() {
    return reinterpret_cast<const WriteChunkRequest*>(
               &_WriteChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(WriteChunkRequest* other);
  friend void swap(WriteChunkRequest& a, WriteChunkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteChunkRequest* New() const final {
    return CreateMaybeMessage<WriteChunkRequest>(NULL);
  }

  WriteChunkRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteChunkRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteChunkRequest& from);
  void MergeFrom(const WriteChunkRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteChunkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string locations = 5;
  int locations_size() const;
  void clear_locations();
  static const int kLocationsFieldNumber = 5;
  const ::std::string& locations(int index) const;
  ::std::string* mutable_locations(int index);
  void set_locations(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_locations(int index, ::std::string&& value);
  #endif
  void set_locations(int index, const char* value);
  void set_locations(int index, const char* value, size_t size);
  ::std::string* add_locations();
  void add_locations(const ::std::string& value);
  #if LANG_CXX11
  void add_locations(::std::string&& value);
  #endif
  void add_locations(const char* value);
  void add_locations(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& locations() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_locations();

  // string data = 6;
  void clear_data();
  static const int kDataFieldNumber = 6;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int64 client_id = 1;
  void clear_client_id();
  static const int kClientIdFieldNumber = 1;
  ::google::protobuf::int64 client_id() const;
  void set_client_id(::google::protobuf::int64 value);

  // int64 chunkhandle = 2;
  void clear_chunkhandle();
  static const int kChunkhandleFieldNumber = 2;
  ::google::protobuf::int64 chunkhandle() const;
  void set_chunkhandle(::google::protobuf::int64 value);

  // int64 offset = 3;
  void clear_offset();
  static const int kOffsetFieldNumber = 3;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int64 length = 4;
  void clear_length();
  static const int kLengthFieldNumber = 4;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.WriteChunkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> locations_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 client_id_;
  ::google::protobuf::int64 chunkhandle_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class WriteChunkReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.WriteChunkReply) */ {
 public:
  WriteChunkReply();
  virtual ~WriteChunkReply();

  WriteChunkReply(const WriteChunkReply& from);

  inline WriteChunkReply& operator=(const WriteChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  WriteChunkReply(WriteChunkReply&& from) noexcept
    : WriteChunkReply() {
    *this = ::std::move(from);
  }

  inline WriteChunkReply& operator=(WriteChunkReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const WriteChunkReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const WriteChunkReply* internal_default_instance() {
    return reinterpret_cast<const WriteChunkReply*>(
               &_WriteChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(WriteChunkReply* other);
  friend void swap(WriteChunkReply& a, WriteChunkReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline WriteChunkReply* New() const final {
    return CreateMaybeMessage<WriteChunkReply>(NULL);
  }

  WriteChunkReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<WriteChunkReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const WriteChunkReply& from);
  void MergeFrom(const WriteChunkReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteChunkReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 bytes_read = 2;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 2;
  ::google::protobuf::int64 bytes_read() const;
  void set_bytes_read(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.WriteChunkReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 bytes_read_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadChunkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.ReadChunkRequest) */ {
 public:
  ReadChunkRequest();
  virtual ~ReadChunkRequest();

  ReadChunkRequest(const ReadChunkRequest& from);

  inline ReadChunkRequest& operator=(const ReadChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadChunkRequest(ReadChunkRequest&& from) noexcept
    : ReadChunkRequest() {
    *this = ::std::move(from);
  }

  inline ReadChunkRequest& operator=(ReadChunkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadChunkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadChunkRequest* internal_default_instance() {
    return reinterpret_cast<const ReadChunkRequest*>(
               &_ReadChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(ReadChunkRequest* other);
  friend void swap(ReadChunkRequest& a, ReadChunkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadChunkRequest* New() const final {
    return CreateMaybeMessage<ReadChunkRequest>(NULL);
  }

  ReadChunkRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadChunkRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadChunkRequest& from);
  void MergeFrom(const ReadChunkRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChunkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int64 chunkhandle = 1;
  void clear_chunkhandle();
  static const int kChunkhandleFieldNumber = 1;
  ::google::protobuf::int64 chunkhandle() const;
  void set_chunkhandle(::google::protobuf::int64 value);

  // int64 offset = 2;
  void clear_offset();
  static const int kOffsetFieldNumber = 2;
  ::google::protobuf::int64 offset() const;
  void set_offset(::google::protobuf::int64 value);

  // int64 length = 3;
  void clear_length();
  static const int kLengthFieldNumber = 3;
  ::google::protobuf::int64 length() const;
  void set_length(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.ReadChunkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int64 chunkhandle_;
  ::google::protobuf::int64 offset_;
  ::google::protobuf::int64 length_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReadChunkReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.ReadChunkReply) */ {
 public:
  ReadChunkReply();
  virtual ~ReadChunkReply();

  ReadChunkReply(const ReadChunkReply& from);

  inline ReadChunkReply& operator=(const ReadChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReadChunkReply(ReadChunkReply&& from) noexcept
    : ReadChunkReply() {
    *this = ::std::move(from);
  }

  inline ReadChunkReply& operator=(ReadChunkReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReadChunkReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReadChunkReply* internal_default_instance() {
    return reinterpret_cast<const ReadChunkReply*>(
               &_ReadChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(ReadChunkReply* other);
  friend void swap(ReadChunkReply& a, ReadChunkReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReadChunkReply* New() const final {
    return CreateMaybeMessage<ReadChunkReply>(NULL);
  }

  ReadChunkReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReadChunkReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReadChunkReply& from);
  void MergeFrom(const ReadChunkReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChunkReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string data = 1;
  void clear_data();
  static const int kDataFieldNumber = 1;
  const ::std::string& data() const;
  void set_data(const ::std::string& value);
  #if LANG_CXX11
  void set_data(::std::string&& value);
  #endif
  void set_data(const char* value);
  void set_data(const char* value, size_t size);
  ::std::string* mutable_data();
  ::std::string* release_data();
  void set_allocated_data(::std::string* data);

  // int64 bytes_read = 2;
  void clear_bytes_read();
  static const int kBytesReadFieldNumber = 2;
  ::google::protobuf::int64 bytes_read() const;
  void set_bytes_read(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.ReadChunkReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr data_;
  ::google::protobuf::int64 bytes_read_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataNodeLocation : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.DataNodeLocation) */ {
 public:
  DataNodeLocation();
  virtual ~DataNodeLocation();

  DataNodeLocation(const DataNodeLocation& from);

  inline DataNodeLocation& operator=(const DataNodeLocation& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataNodeLocation(DataNodeLocation&& from) noexcept
    : DataNodeLocation() {
    *this = ::std::move(from);
  }

  inline DataNodeLocation& operator=(DataNodeLocation&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataNodeLocation& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataNodeLocation* internal_default_instance() {
    return reinterpret_cast<const DataNodeLocation*>(
               &_DataNodeLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(DataNodeLocation* other);
  friend void swap(DataNodeLocation& a, DataNodeLocation& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataNodeLocation* New() const final {
    return CreateMaybeMessage<DataNodeLocation>(NULL);
  }

  DataNodeLocation* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataNodeLocation>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataNodeLocation& from);
  void MergeFrom(const DataNodeLocation& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataNodeLocation* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // @@protoc_insertion_point(class_scope:Rpc.DataNodeLocation)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DataNode : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.DataNode) */ {
 public:
  DataNode();
  virtual ~DataNode();

  DataNode(const DataNode& from);

  inline DataNode& operator=(const DataNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DataNode(DataNode&& from) noexcept
    : DataNode() {
    *this = ::std::move(from);
  }

  inline DataNode& operator=(DataNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const DataNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DataNode* internal_default_instance() {
    return reinterpret_cast<const DataNode*>(
               &_DataNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(DataNode* other);
  friend void swap(DataNode& a, DataNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DataNode* New() const final {
    return CreateMaybeMessage<DataNode>(NULL);
  }

  DataNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DataNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DataNode& from);
  void MergeFrom(const DataNode& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 stored_chunk_handles = 3;
  int stored_chunk_handles_size() const;
  void clear_stored_chunk_handles();
  static const int kStoredChunkHandlesFieldNumber = 3;
  ::google::protobuf::int64 stored_chunk_handles(int index) const;
  void set_stored_chunk_handles(int index, ::google::protobuf::int64 value);
  void add_stored_chunk_handles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      stored_chunk_handles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_stored_chunk_handles();

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // uint32 available_size = 2;
  void clear_available_size();
  static const int kAvailableSizeFieldNumber = 2;
  ::google::protobuf::uint32 available_size() const;
  void set_available_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Rpc.DataNode)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > stored_chunk_handles_;
  mutable int _stored_chunk_handles_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::uint32 available_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Chunk : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.Chunk) */ {
 public:
  Chunk();
  virtual ~Chunk();

  Chunk(const Chunk& from);

  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Chunk(Chunk&& from) noexcept
    : Chunk() {
    *this = ::std::move(from);
  }

  inline Chunk& operator=(Chunk&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Chunk& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Chunk* internal_default_instance() {
    return reinterpret_cast<const Chunk*>(
               &_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(Chunk* other);
  friend void swap(Chunk& a, Chunk& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Chunk* New() const final {
    return CreateMaybeMessage<Chunk>(NULL);
  }

  Chunk* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Chunk>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Chunk& from);
  void MergeFrom(const Chunk& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chunk* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string location = 2;
  int location_size() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  const ::std::string& location(int index) const;
  ::std::string* mutable_location(int index);
  void set_location(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_location(int index, ::std::string&& value);
  #endif
  void set_location(int index, const char* value);
  void set_location(int index, const char* value, size_t size);
  ::std::string* add_location();
  void add_location(const ::std::string& value);
  #if LANG_CXX11
  void add_location(::std::string&& value);
  #endif
  void add_location(const char* value);
  void add_location(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& location() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_location();

  // int64 chunk_handle = 1;
  void clear_chunk_handle();
  static const int kChunkHandleFieldNumber = 1;
  ::google::protobuf::int64 chunk_handle() const;
  void set_chunk_handle(::google::protobuf::int64 value);

  // int64 size = 3;
  void clear_size();
  static const int kSizeFieldNumber = 3;
  ::google::protobuf::int64 size() const;
  void set_size(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.Chunk)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> location_;
  ::google::protobuf::int64 chunk_handle_;
  ::google::protobuf::int64 size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportDataNodeRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.ReportDataNodeRequest) */ {
 public:
  ReportDataNodeRequest();
  virtual ~ReportDataNodeRequest();

  ReportDataNodeRequest(const ReportDataNodeRequest& from);

  inline ReportDataNodeRequest& operator=(const ReportDataNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportDataNodeRequest(ReportDataNodeRequest&& from) noexcept
    : ReportDataNodeRequest() {
    *this = ::std::move(from);
  }

  inline ReportDataNodeRequest& operator=(ReportDataNodeRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportDataNodeRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportDataNodeRequest* internal_default_instance() {
    return reinterpret_cast<const ReportDataNodeRequest*>(
               &_ReportDataNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(ReportDataNodeRequest* other);
  friend void swap(ReportDataNodeRequest& a, ReportDataNodeRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportDataNodeRequest* New() const final {
    return CreateMaybeMessage<ReportDataNodeRequest>(NULL);
  }

  ReportDataNodeRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportDataNodeRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReportDataNodeRequest& from);
  void MergeFrom(const ReportDataNodeRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportDataNodeRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 stored_chunk_handles = 3;
  int stored_chunk_handles_size() const;
  void clear_stored_chunk_handles();
  static const int kStoredChunkHandlesFieldNumber = 3;
  ::google::protobuf::int64 stored_chunk_handles(int index) const;
  void set_stored_chunk_handles(int index, ::google::protobuf::int64 value);
  void add_stored_chunk_handles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      stored_chunk_handles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_stored_chunk_handles();

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // uint32 available_size = 2;
  void clear_available_size();
  static const int kAvailableSizeFieldNumber = 2;
  ::google::protobuf::uint32 available_size() const;
  void set_available_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:Rpc.ReportDataNodeRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > stored_chunk_handles_;
  mutable int _stored_chunk_handles_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::uint32 available_size_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ReportDataNodeReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.ReportDataNodeReply) */ {
 public:
  ReportDataNodeReply();
  virtual ~ReportDataNodeReply();

  ReportDataNodeReply(const ReportDataNodeReply& from);

  inline ReportDataNodeReply& operator=(const ReportDataNodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ReportDataNodeReply(ReportDataNodeReply&& from) noexcept
    : ReportDataNodeReply() {
    *this = ::std::move(from);
  }

  inline ReportDataNodeReply& operator=(ReportDataNodeReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const ReportDataNodeReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ReportDataNodeReply* internal_default_instance() {
    return reinterpret_cast<const ReportDataNodeReply*>(
               &_ReportDataNodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  void Swap(ReportDataNodeReply* other);
  friend void swap(ReportDataNodeReply& a, ReportDataNodeReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ReportDataNodeReply* New() const final {
    return CreateMaybeMessage<ReportDataNodeReply>(NULL);
  }

  ReportDataNodeReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ReportDataNodeReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ReportDataNodeReply& from);
  void MergeFrom(const ReportDataNodeReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportDataNodeReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.ReportDataNodeReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.HeartbeatRequest) */ {
 public:
  HeartbeatRequest();
  virtual ~HeartbeatRequest();

  HeartbeatRequest(const HeartbeatRequest& from);

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  void Swap(HeartbeatRequest* other);
  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatRequest* New() const final {
    return CreateMaybeMessage<HeartbeatRequest>(NULL);
  }

  HeartbeatRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatRequest& from);
  void MergeFrom(const HeartbeatRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.HeartbeatRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class HeartbeatReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.HeartbeatReply) */ {
 public:
  HeartbeatReply();
  virtual ~HeartbeatReply();

  HeartbeatReply(const HeartbeatReply& from);

  inline HeartbeatReply& operator=(const HeartbeatReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  HeartbeatReply(HeartbeatReply&& from) noexcept
    : HeartbeatReply() {
    *this = ::std::move(from);
  }

  inline HeartbeatReply& operator=(HeartbeatReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const HeartbeatReply* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReply*>(
               &_HeartbeatReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  void Swap(HeartbeatReply* other);
  friend void swap(HeartbeatReply& a, HeartbeatReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline HeartbeatReply* New() const final {
    return CreateMaybeMessage<HeartbeatReply>(NULL);
  }

  HeartbeatReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<HeartbeatReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const HeartbeatReply& from);
  void MergeFrom(const HeartbeatReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .Rpc.HeartbeatRequest request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  private:
  const ::Rpc::HeartbeatRequest& _internal_request() const;
  public:
  const ::Rpc::HeartbeatRequest& request() const;
  ::Rpc::HeartbeatRequest* release_request();
  ::Rpc::HeartbeatRequest* mutable_request();
  void set_allocated_request(::Rpc::HeartbeatRequest* request);

  // @@protoc_insertion_point(class_scope:Rpc.HeartbeatReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::Rpc::HeartbeatRequest* request_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CopyChunkRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkRequest) */ {
 public:
  CopyChunkRequest();
  virtual ~CopyChunkRequest();

  CopyChunkRequest(const CopyChunkRequest& from);

  inline CopyChunkRequest& operator=(const CopyChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CopyChunkRequest(CopyChunkRequest&& from) noexcept
    : CopyChunkRequest() {
    *this = ::std::move(from);
  }

  inline CopyChunkRequest& operator=(CopyChunkRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CopyChunkRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CopyChunkRequest* internal_default_instance() {
    return reinterpret_cast<const CopyChunkRequest*>(
               &_CopyChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  void Swap(CopyChunkRequest* other);
  friend void swap(CopyChunkRequest& a, CopyChunkRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CopyChunkRequest* New() const final {
    return CreateMaybeMessage<CopyChunkRequest>(NULL);
  }

  CopyChunkRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CopyChunkRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CopyChunkRequest& from);
  void MergeFrom(const CopyChunkRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyChunkRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string location = 1;
  void clear_location();
  static const int kLocationFieldNumber = 1;
  const ::std::string& location() const;
  void set_location(const ::std::string& value);
  #if LANG_CXX11
  void set_location(::std::string&& value);
  #endif
  void set_location(const char* value);
  void set_location(const char* value, size_t size);
  ::std::string* mutable_location();
  ::std::string* release_location();
  void set_allocated_location(::std::string* location);

  // int64 chunk_handle = 2;
  void clear_chunk_handle();
  static const int kChunkHandleFieldNumber = 2;
  ::google::protobuf::int64 chunk_handle() const;
  void set_chunk_handle(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr location_;
  ::google::protobuf::int64 chunk_handle_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class CopyChunkReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkReply) */ {
 public:
  CopyChunkReply();
  virtual ~CopyChunkReply();

  CopyChunkReply(const CopyChunkReply& from);

  inline CopyChunkReply& operator=(const CopyChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  CopyChunkReply(CopyChunkReply&& from) noexcept
    : CopyChunkReply() {
    *this = ::std::move(from);
  }

  inline CopyChunkReply& operator=(CopyChunkReply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const CopyChunkReply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const CopyChunkReply* internal_default_instance() {
    return reinterpret_cast<const CopyChunkReply*>(
               &_CopyChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  void Swap(CopyChunkReply* other);
  friend void swap(CopyChunkReply& a, CopyChunkReply& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline CopyChunkReply* New() const final {
    return CreateMaybeMessage<CopyChunkReply>(NULL);
  }

  CopyChunkReply* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<CopyChunkReply>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const CopyChunkReply& from);
  void MergeFrom(const CopyChunkReply& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyChunkReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_NameNode_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogEntry

// int32 Term = 1;
inline void LogEntry::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 LogEntry::term() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.Term)
  return term_;
}
inline void LogEntry::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.Term)
}

// int32 command = 2;
inline void LogEntry::clear_command() {
  command_ = 0;
}
inline ::google::protobuf::int32 LogEntry::command() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.command)
  return command_;
}
inline void LogEntry::set_command(::google::protobuf::int32 value) {
  
  command_ = value;
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.command)
}

// .Rpc.GetWriteAddrRequest getw = 3;
inline bool LogEntry::has_getw() const {
  return this != internal_default_instance() && getw_ != NULL;
}
inline void LogEntry::clear_getw() {
  if (GetArenaNoVirtual() == NULL && getw_ != NULL) {
    delete getw_;
  }
  getw_ = NULL;
}
inline const ::Rpc::GetWriteAddrRequest& LogEntry::_internal_getw() const {
  return *getw_;
}
inline const ::Rpc::GetWriteAddrRequest& LogEntry::getw() const {
  const ::Rpc::GetWriteAddrRequest* p = getw_;
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.getw)
  return p != NULL ? *p : *reinterpret_cast<const ::Rpc::GetWriteAddrRequest*>(
      &::Rpc::_GetWriteAddrRequest_default_instance_);
}
inline ::Rpc::GetWriteAddrRequest* LogEntry::release_getw() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.getw)
  
  ::Rpc::GetWriteAddrRequest* temp = getw_;
  getw_ = NULL;
  return temp;
}
inline ::Rpc::GetWriteAddrRequest* LogEntry::mutable_getw() {
  
  if (getw_ == NULL) {
    auto* p = CreateMaybeMessage<::Rpc::GetWriteAddrRequest>(GetArenaNoVirtual());
    getw_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.getw)
  return getw_;
}
inline void LogEntry::set_allocated_getw(::Rpc::GetWriteAddrRequest* getw) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete getw_;
  }
  if (getw) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      getw = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, getw, submessage_arena);
    }
    
  } else {
    
  }
  getw_ = getw;
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.getw)
}

// .Rpc.RenameRequest rename = 4;
inline bool LogEntry::has_rename() const {
  return this != internal_default_instance() && rename_ != NULL;
}
inline void LogEntry::clear_rename() {
  if (GetArenaNoVirtual() == NULL && rename_ != NULL) {
    delete rename_;
  }
  rename_ = NULL;
}
inline const ::Rpc::RenameRequest& LogEntry::_internal_rename() const {
  return *rename_;
}
inline const ::Rpc::RenameRequest& LogEntry::rename() const {
  const ::Rpc::RenameRequest* p = rename_;
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.rename)
  return p != NULL ? *p : *reinterpret_cast<const ::Rpc::RenameRequest*>(
      &::Rpc::_RenameRequest_default_instance_);
}
inline ::Rpc::RenameRequest* LogEntry::release_rename() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.rename)
  
  ::Rpc::RenameRequest* temp = rename_;
  rename_ = NULL;
  return temp;
}
inline ::Rpc::RenameRequest* LogEntry::mutable_rename() {
  
  if (rename_ == NULL) {
    auto* p = CreateMaybeMessage<::Rpc::RenameRequest>(GetArenaNoVirtual());
    rename_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.rename)
  return rename_;
}
inline void LogEntry::set_allocated_rename(::Rpc::RenameRequest* rename) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete rename_;
  }
  if (rename) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      rename = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, rename, submessage_arena);
    }
    
  } else {
    
  }
  rename_ = rename;
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.rename)
}

// .Rpc.DeleteRequest del = 5;
inline bool LogEntry::has_del() const {
  return this != internal_default_instance() && del_ != NULL;
}
inline void LogEntry::clear_del() {
  if (GetArenaNoVirtual() == NULL && del_ != NULL) {
    delete del_;
  }
  del_ = NULL;
}
inline const ::Rpc::DeleteRequest& LogEntry::_internal_del() const {
  return *del_;
}
inline const ::Rpc::DeleteRequest& LogEntry::del() const {
  const ::Rpc::DeleteRequest* p = del_;
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.del)
  return p != NULL ? *p : *reinterpret_cast<const ::Rpc::DeleteRequest*>(
      &::Rpc::_DeleteRequest_default_instance_);
}
inline ::Rpc::DeleteRequest* LogEntry::release_del() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.del)
  
  ::Rpc::DeleteRequest* temp = del_;
  del_ = NULL;
  return temp;
}
inline ::Rpc::DeleteRequest* LogEntry::mutable_del() {
  
  if (del_ == NULL) {
    auto* p = CreateMaybeMessage<::Rpc::DeleteRequest>(GetArenaNoVirtual());
    del_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.del)
  return del_;
}
inline void LogEntry::set_allocated_del(::Rpc::DeleteRequest* del) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete del_;
  }
  if (del) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      del = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, del, submessage_arena);
    }
    
  } else {
    
  }
  del_ = del;
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.del)
}

// string filepath = 6;
inline void LogEntry::clear_filepath() {
  filepath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::filepath() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.filepath)
  return filepath_.GetNoArena();
}
inline void LogEntry::set_filepath(const ::std::string& value) {
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.filepath)
}
#if LANG_CXX11
inline void LogEntry::set_filepath(::std::string&& value) {
  
  filepath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.LogEntry.filepath)
}
#endif
inline void LogEntry::set_filepath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.LogEntry.filepath)
}
inline void LogEntry::set_filepath(const char* value, size_t size) {
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.LogEntry.filepath)
}
inline ::std::string* LogEntry::mutable_filepath() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.filepath)
  return filepath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_filepath() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.filepath)
  
  return filepath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_filepath(::std::string* filepath) {
  if (filepath != NULL) {
    
  } else {
    
  }
  filepath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filepath);
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.filepath)
}

// string src = 7;
inline void LogEntry::clear_src() {
  src_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::src() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.src)
  return src_.GetNoArena();
}
inline void LogEntry::set_src(const ::std::string& value) {
  
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.src)
}
#if LANG_CXX11
inline void LogEntry::set_src(::std::string&& value) {
  
  src_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.LogEntry.src)
}
#endif
inline void LogEntry::set_src(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.LogEntry.src)
}
inline void LogEntry::set_src(const char* value, size_t size) {
  
  src_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.LogEntry.src)
}
inline ::std::string* LogEntry::mutable_src() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.src)
  return src_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_src() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.src)
  
  return src_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_src(::std::string* src) {
  if (src != NULL) {
    
  } else {
    
  }
  src_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src);
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.src)
}

// string des = 8;
inline void LogEntry::clear_des() {
  des_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LogEntry::des() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.des)
  return des_.GetNoArena();
}
inline void LogEntry::set_des(const ::std::string& value) {
  
  des_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.des)
}
#if LANG_CXX11
inline void LogEntry::set_des(::std::string&& value) {
  
  des_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.LogEntry.des)
}
#endif
inline void LogEntry::set_des(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  des_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.LogEntry.des)
}
inline void LogEntry::set_des(const char* value, size_t size) {
  
  des_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.LogEntry.des)
}
inline ::std::string* LogEntry::mutable_des() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.des)
  return des_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LogEntry::release_des() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.des)
  
  return des_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LogEntry::set_allocated_des(::std::string* des) {
  if (des != NULL) {
    
  } else {
    
  }
  des_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), des);
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.des)
}

// int64 size = 9;
inline void LogEntry::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 LogEntry::size() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.size)
  return size_;
}
inline void LogEntry::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.size)
}

// -------------------------------------------------------------------

// AppendEntriesArgs

// repeated .Rpc.LogEntry Entries = 1;
inline int AppendEntriesArgs::entries_size() const {
  return entries_.size();
}
inline void AppendEntriesArgs::clear_entries() {
  entries_.Clear();
}
inline ::Rpc::LogEntry* AppendEntriesArgs::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.AppendEntriesArgs.Entries)
  return entries_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Rpc::LogEntry >*
AppendEntriesArgs::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.AppendEntriesArgs.Entries)
  return &entries_;
}
inline const ::Rpc::LogEntry& AppendEntriesArgs::entries(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.Entries)
  return entries_.Get(index);
}
inline ::Rpc::LogEntry* AppendEntriesArgs::add_entries() {
  // @@protoc_insertion_point(field_add:Rpc.AppendEntriesArgs.Entries)
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Rpc::LogEntry >&
AppendEntriesArgs::entries() const {
  // @@protoc_insertion_point(field_list:Rpc.AppendEntriesArgs.Entries)
  return entries_;
}

// int32 ATerm = 2;
inline void AppendEntriesArgs::clear_aterm() {
  aterm_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::aterm() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.ATerm)
  return aterm_;
}
inline void AppendEntriesArgs::set_aterm(::google::protobuf::int32 value) {
  
  aterm_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.ATerm)
}

// int32 LeaderId = 3;
inline void AppendEntriesArgs::clear_leaderid() {
  leaderid_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::leaderid() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.LeaderId)
  return leaderid_;
}
inline void AppendEntriesArgs::set_leaderid(::google::protobuf::int32 value) {
  
  leaderid_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.LeaderId)
}

// int32 PrevLogIndex = 4;
inline void AppendEntriesArgs::clear_prevlogindex() {
  prevlogindex_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::prevlogindex() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.PrevLogIndex)
  return prevlogindex_;
}
inline void AppendEntriesArgs::set_prevlogindex(::google::protobuf::int32 value) {
  
  prevlogindex_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.PrevLogIndex)
}

// int32 PrevLogTerm = 5;
inline void AppendEntriesArgs::clear_prevlogterm() {
  prevlogterm_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::prevlogterm() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.PrevLogTerm)
  return prevlogterm_;
}
inline void AppendEntriesArgs::set_prevlogterm(::google::protobuf::int32 value) {
  
  prevlogterm_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.PrevLogTerm)
}

// int32 LeaderCommit = 6;
inline void AppendEntriesArgs::clear_leadercommit() {
  leadercommit_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesArgs::leadercommit() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.LeaderCommit)
  return leadercommit_;
}
inline void AppendEntriesArgs::set_leadercommit(::google::protobuf::int32 value) {
  
  leadercommit_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.LeaderCommit)
}

// -------------------------------------------------------------------

// AppendEntriesReply

// int32 Term = 1;
inline void AppendEntriesReply::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesReply::term() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.Term)
  return term_;
}
inline void AppendEntriesReply::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.Term)
}

// bool Success = 2;
inline void AppendEntriesReply::clear_success() {
  success_ = false;
}
inline bool AppendEntriesReply::success() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.Success)
  return success_;
}
inline void AppendEntriesReply::set_success(bool value) {
  
  success_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.Success)
}

// int32 UpNextIndex = 3;
inline void AppendEntriesReply::clear_upnextindex() {
  upnextindex_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesReply::upnextindex() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.UpNextIndex)
  return upnextindex_;
}
inline void AppendEntriesReply::set_upnextindex(::google::protobuf::int32 value) {
  
  upnextindex_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.UpNextIndex)
}

// int32 AppendEntriesState = 4;
inline void AppendEntriesReply::clear_appendentriesstate() {
  appendentriesstate_ = 0;
}
inline ::google::protobuf::int32 AppendEntriesReply::appendentriesstate() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.AppendEntriesState)
  return appendentriesstate_;
}
inline void AppendEntriesReply::set_appendentriesstate(::google::protobuf::int32 value) {
  
  appendentriesstate_ = value;
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.AppendEntriesState)
}

// -------------------------------------------------------------------

// RequestVoteArgs

// int32 term = 1;
inline void RequestVoteArgs::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::term() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.term)
  return term_;
}
inline void RequestVoteArgs::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.term)
}

// int32 candidateId = 2;
inline void RequestVoteArgs::clear_candidateid() {
  candidateid_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::candidateid() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.candidateId)
  return candidateid_;
}
inline void RequestVoteArgs::set_candidateid(::google::protobuf::int32 value) {
  
  candidateid_ = value;
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.candidateId)
}

// int32 lastLogindex = 3;
inline void RequestVoteArgs::clear_lastlogindex() {
  lastlogindex_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::lastlogindex() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.lastLogindex)
  return lastlogindex_;
}
inline void RequestVoteArgs::set_lastlogindex(::google::protobuf::int32 value) {
  
  lastlogindex_ = value;
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.lastLogindex)
}

// int32 lastLogterm = 4;
inline void RequestVoteArgs::clear_lastlogterm() {
  lastlogterm_ = 0;
}
inline ::google::protobuf::int32 RequestVoteArgs::lastlogterm() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.lastLogterm)
  return lastlogterm_;
}
inline void RequestVoteArgs::set_lastlogterm(::google::protobuf::int32 value) {
  
  lastlogterm_ = value;
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.lastLogterm)
}

// -------------------------------------------------------------------

// RequestVoteReply

// int32 term = 1;
inline void RequestVoteReply::clear_term() {
  term_ = 0;
}
inline ::google::protobuf::int32 RequestVoteReply::term() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteReply.term)
  return term_;
}
inline void RequestVoteReply::set_term(::google::protobuf::int32 value) {
  
  term_ = value;
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteReply.term)
}

// bool votegranted = 2;
inline void RequestVoteReply::clear_votegranted() {
  votegranted_ = false;
}
inline bool RequestVoteReply::votegranted() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteReply.votegranted)
  return votegranted_;
}
inline void RequestVoteReply::set_votegranted(bool value) {
  
  votegranted_ = value;
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteReply.votegranted)
}

// -------------------------------------------------------------------

// FindAddrRequest

// string filepath = 1;
inline void FindAddrRequest::clear_filepath() {
  filepath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& FindAddrRequest::filepath() const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrRequest.filepath)
  return filepath_.GetNoArena();
}
inline void FindAddrRequest::set_filepath(const ::std::string& value) {
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.FindAddrRequest.filepath)
}
#if LANG_CXX11
inline void FindAddrRequest::set_filepath(::std::string&& value) {
  
  filepath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.FindAddrRequest.filepath)
}
#endif
inline void FindAddrRequest::set_filepath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.FindAddrRequest.filepath)
}
inline void FindAddrRequest::set_filepath(const char* value, size_t size) {
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.FindAddrRequest.filepath)
}
inline ::std::string* FindAddrRequest::mutable_filepath() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.FindAddrRequest.filepath)
  return filepath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FindAddrRequest::release_filepath() {
  // @@protoc_insertion_point(field_release:Rpc.FindAddrRequest.filepath)
  
  return filepath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FindAddrRequest::set_allocated_filepath(::std::string* filepath) {
  if (filepath != NULL) {
    
  } else {
    
  }
  filepath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filepath);
  // @@protoc_insertion_point(field_set_allocated:Rpc.FindAddrRequest.filepath)
}

// -------------------------------------------------------------------

// FindAddrReply_ReplicaAddrs

// repeated string ip_ports = 1;
inline int FindAddrReply_ReplicaAddrs::ip_ports_size() const {
  return ip_ports_.size();
}
inline void FindAddrReply_ReplicaAddrs::clear_ip_ports() {
  ip_ports_.Clear();
}
inline const ::std::string& FindAddrReply_ReplicaAddrs::ip_ports(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Get(index);
}
inline ::std::string* FindAddrReply_ReplicaAddrs::mutable_ip_ports(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Mutable(index);
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  ip_ports_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  ip_ports_.Mutable(index)->assign(std::move(value));
}
#endif
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value, size_t size) {
  ip_ports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline ::std::string* FindAddrReply_ReplicaAddrs::add_ip_ports() {
  // @@protoc_insertion_point(field_add_mutable:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Add();
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const ::std::string& value) {
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
#if LANG_CXX11
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(::std::string&& value) {
  ip_ports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
#endif
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const char* value, size_t size) {
  ip_ports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
FindAddrReply_ReplicaAddrs::ip_ports() const {
  // @@protoc_insertion_point(field_list:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
FindAddrReply_ReplicaAddrs::mutable_ip_ports() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return &ip_ports_;
}

// -------------------------------------------------------------------

// FindAddrReply

// repeated int64 chunk_handles = 1;
inline int FindAddrReply::chunk_handles_size() const {
  return chunk_handles_.size();
}
inline void FindAddrReply::clear_chunk_handles() {
  chunk_handles_.Clear();
}
inline ::google::protobuf::int64 FindAddrReply::chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrReply.chunk_handles)
  return chunk_handles_.Get(index);
}
inline void FindAddrReply::set_chunk_handles(int index, ::google::protobuf::int64 value) {
  chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.FindAddrReply.chunk_handles)
}
inline void FindAddrReply::add_chunk_handles(::google::protobuf::int64 value) {
  chunk_handles_.Add(value);
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.chunk_handles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
FindAddrReply::chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.FindAddrReply.chunk_handles)
  return chunk_handles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
FindAddrReply::mutable_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.FindAddrReply.chunk_handles)
  return &chunk_handles_;
}

// repeated .Rpc.FindAddrReply.ReplicaAddrs addrs = 2;
inline int FindAddrReply::addrs_size() const {
  return addrs_.size();
}
inline void FindAddrReply::clear_addrs() {
  addrs_.Clear();
}
inline ::Rpc::FindAddrReply_ReplicaAddrs* FindAddrReply::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.FindAddrReply.addrs)
  return addrs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >*
FindAddrReply::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.FindAddrReply.addrs)
  return &addrs_;
}
inline const ::Rpc::FindAddrReply_ReplicaAddrs& FindAddrReply::addrs(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrReply.addrs)
  return addrs_.Get(index);
}
inline ::Rpc::FindAddrReply_ReplicaAddrs* FindAddrReply::add_addrs() {
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.addrs)
  return addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >&
FindAddrReply::addrs() const {
  // @@protoc_insertion_point(field_list:Rpc.FindAddrReply.addrs)
  return addrs_;
}

// -------------------------------------------------------------------

// GetWriteAddrRequest

// string remote_file_path = 1;
inline void GetWriteAddrRequest::clear_remote_file_path() {
  remote_file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetWriteAddrRequest::remote_file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrRequest.remote_file_path)
  return remote_file_path_.GetNoArena();
}
inline void GetWriteAddrRequest::set_remote_file_path(const ::std::string& value) {
  
  remote_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrRequest.remote_file_path)
}
#if LANG_CXX11
inline void GetWriteAddrRequest::set_remote_file_path(::std::string&& value) {
  
  remote_file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.GetWriteAddrRequest.remote_file_path)
}
#endif
inline void GetWriteAddrRequest::set_remote_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.GetWriteAddrRequest.remote_file_path)
}
inline void GetWriteAddrRequest::set_remote_file_path(const char* value, size_t size) {
  
  remote_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.GetWriteAddrRequest.remote_file_path)
}
inline ::std::string* GetWriteAddrRequest::mutable_remote_file_path() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.GetWriteAddrRequest.remote_file_path)
  return remote_file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetWriteAddrRequest::release_remote_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.GetWriteAddrRequest.remote_file_path)
  
  return remote_file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetWriteAddrRequest::set_allocated_remote_file_path(::std::string* remote_file_path) {
  if (remote_file_path != NULL) {
    
  } else {
    
  }
  remote_file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_file_path);
  // @@protoc_insertion_point(field_set_allocated:Rpc.GetWriteAddrRequest.remote_file_path)
}

// int64 write_data_size = 2;
inline void GetWriteAddrRequest::clear_write_data_size() {
  write_data_size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 GetWriteAddrRequest::write_data_size() const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrRequest.write_data_size)
  return write_data_size_;
}
inline void GetWriteAddrRequest::set_write_data_size(::google::protobuf::int64 value) {
  
  write_data_size_ = value;
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrRequest.write_data_size)
}

// -------------------------------------------------------------------

// GetWriteAddrReply_ReplicaAddrs

// repeated string ip_ports = 1;
inline int GetWriteAddrReply_ReplicaAddrs::ip_ports_size() const {
  return ip_ports_.size();
}
inline void GetWriteAddrReply_ReplicaAddrs::clear_ip_ports() {
  ip_ports_.Clear();
}
inline const ::std::string& GetWriteAddrReply_ReplicaAddrs::ip_ports(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Get(index);
}
inline ::std::string* GetWriteAddrReply_ReplicaAddrs::mutable_ip_ports(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Mutable(index);
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  ip_ports_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  ip_ports_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value, size_t size) {
  ip_ports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline ::std::string* GetWriteAddrReply_ReplicaAddrs::add_ip_ports() {
  // @@protoc_insertion_point(field_add_mutable:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Add();
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const ::std::string& value) {
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
#if LANG_CXX11
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(::std::string&& value) {
  ip_ports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
#endif
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const char* value, size_t size) {
  ip_ports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetWriteAddrReply_ReplicaAddrs::ip_ports() const {
  // @@protoc_insertion_point(field_list:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetWriteAddrReply_ReplicaAddrs::mutable_ip_ports() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return &ip_ports_;
}

// -------------------------------------------------------------------

// GetWriteAddrReply

// repeated int64 chunk_handles = 1;
inline int GetWriteAddrReply::chunk_handles_size() const {
  return chunk_handles_.size();
}
inline void GetWriteAddrReply::clear_chunk_handles() {
  chunk_handles_.Clear();
}
inline ::google::protobuf::int64 GetWriteAddrReply::chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrReply.chunk_handles)
  return chunk_handles_.Get(index);
}
inline void GetWriteAddrReply::set_chunk_handles(int index, ::google::protobuf::int64 value) {
  chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrReply.chunk_handles)
}
inline void GetWriteAddrReply::add_chunk_handles(::google::protobuf::int64 value) {
  chunk_handles_.Add(value);
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.chunk_handles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
GetWriteAddrReply::chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.GetWriteAddrReply.chunk_handles)
  return chunk_handles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
GetWriteAddrReply::mutable_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetWriteAddrReply.chunk_handles)
  return &chunk_handles_;
}

// repeated .Rpc.GetWriteAddrReply.ReplicaAddrs addrs = 2;
inline int GetWriteAddrReply::addrs_size() const {
  return addrs_.size();
}
inline void GetWriteAddrReply::clear_addrs() {
  addrs_.Clear();
}
inline ::Rpc::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.GetWriteAddrReply.addrs)
  return addrs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >*
GetWriteAddrReply::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetWriteAddrReply.addrs)
  return &addrs_;
}
inline const ::Rpc::GetWriteAddrReply_ReplicaAddrs& GetWriteAddrReply::addrs(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrReply.addrs)
  return addrs_.Get(index);
}
inline ::Rpc::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::add_addrs() {
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.addrs)
  return addrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >&
GetWriteAddrReply::addrs() const {
  // @@protoc_insertion_point(field_list:Rpc.GetWriteAddrReply.addrs)
  return addrs_;
}

// -------------------------------------------------------------------

// GetSubDirNamesRequest

// string file_path = 1;
inline void GetSubDirNamesRequest::clear_file_path() {
  file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& GetSubDirNamesRequest::file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.GetSubDirNamesRequest.file_path)
  return file_path_.GetNoArena();
}
inline void GetSubDirNamesRequest::set_file_path(const ::std::string& value) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.GetSubDirNamesRequest.file_path)
}
#if LANG_CXX11
inline void GetSubDirNamesRequest::set_file_path(::std::string&& value) {
  
  file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.GetSubDirNamesRequest.file_path)
}
#endif
inline void GetSubDirNamesRequest::set_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.GetSubDirNamesRequest.file_path)
}
inline void GetSubDirNamesRequest::set_file_path(const char* value, size_t size) {
  
  file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.GetSubDirNamesRequest.file_path)
}
inline ::std::string* GetSubDirNamesRequest::mutable_file_path() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.GetSubDirNamesRequest.file_path)
  return file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GetSubDirNamesRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.GetSubDirNamesRequest.file_path)
  
  return file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GetSubDirNamesRequest::set_allocated_file_path(::std::string* file_path) {
  if (file_path != NULL) {
    
  } else {
    
  }
  file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_path);
  // @@protoc_insertion_point(field_set_allocated:Rpc.GetSubDirNamesRequest.file_path)
}

// -------------------------------------------------------------------

// GetSubDirNamesReply

// repeated string subdir_file_names = 1;
inline int GetSubDirNamesReply::subdir_file_names_size() const {
  return subdir_file_names_.size();
}
inline void GetSubDirNamesReply::clear_subdir_file_names() {
  subdir_file_names_.Clear();
}
inline const ::std::string& GetSubDirNamesReply::subdir_file_names(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetSubDirNamesReply.subdir_file_names)
  return subdir_file_names_.Get(index);
}
inline ::std::string* GetSubDirNamesReply::mutable_subdir_file_names(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.GetSubDirNamesReply.subdir_file_names)
  return subdir_file_names_.Mutable(index);
}
inline void GetSubDirNamesReply::set_subdir_file_names(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Rpc.GetSubDirNamesReply.subdir_file_names)
  subdir_file_names_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GetSubDirNamesReply::set_subdir_file_names(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Rpc.GetSubDirNamesReply.subdir_file_names)
  subdir_file_names_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GetSubDirNamesReply::set_subdir_file_names(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subdir_file_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::set_subdir_file_names(int index, const char* value, size_t size) {
  subdir_file_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline ::std::string* GetSubDirNamesReply::add_subdir_file_names() {
  // @@protoc_insertion_point(field_add_mutable:Rpc.GetSubDirNamesReply.subdir_file_names)
  return subdir_file_names_.Add();
}
inline void GetSubDirNamesReply::add_subdir_file_names(const ::std::string& value) {
  subdir_file_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.GetSubDirNamesReply.subdir_file_names)
}
#if LANG_CXX11
inline void GetSubDirNamesReply::add_subdir_file_names(::std::string&& value) {
  subdir_file_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.GetSubDirNamesReply.subdir_file_names)
}
#endif
inline void GetSubDirNamesReply::add_subdir_file_names(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  subdir_file_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::add_subdir_file_names(const char* value, size_t size) {
  subdir_file_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GetSubDirNamesReply::subdir_file_names() const {
  // @@protoc_insertion_point(field_list:Rpc.GetSubDirNamesReply.subdir_file_names)
  return subdir_file_names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GetSubDirNamesReply::mutable_subdir_file_names() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetSubDirNamesReply.subdir_file_names)
  return &subdir_file_names_;
}

// -------------------------------------------------------------------

// MkdirRequest

// string new_file_path = 1;
inline void MkdirRequest::clear_new_file_path() {
  new_file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& MkdirRequest::new_file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.MkdirRequest.new_file_path)
  return new_file_path_.GetNoArena();
}
inline void MkdirRequest::set_new_file_path(const ::std::string& value) {
  
  new_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.MkdirRequest.new_file_path)
}
#if LANG_CXX11
inline void MkdirRequest::set_new_file_path(::std::string&& value) {
  
  new_file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.MkdirRequest.new_file_path)
}
#endif
inline void MkdirRequest::set_new_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  new_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.MkdirRequest.new_file_path)
}
inline void MkdirRequest::set_new_file_path(const char* value, size_t size) {
  
  new_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.MkdirRequest.new_file_path)
}
inline ::std::string* MkdirRequest::mutable_new_file_path() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.MkdirRequest.new_file_path)
  return new_file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* MkdirRequest::release_new_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.MkdirRequest.new_file_path)
  
  return new_file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void MkdirRequest::set_allocated_new_file_path(::std::string* new_file_path) {
  if (new_file_path != NULL) {
    
  } else {
    
  }
  new_file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), new_file_path);
  // @@protoc_insertion_point(field_set_allocated:Rpc.MkdirRequest.new_file_path)
}

// -------------------------------------------------------------------

// MkdirReply

// -------------------------------------------------------------------

// RenameRequest

// string src_path = 1;
inline void RenameRequest::clear_src_path() {
  src_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RenameRequest::src_path() const {
  // @@protoc_insertion_point(field_get:Rpc.RenameRequest.src_path)
  return src_path_.GetNoArena();
}
inline void RenameRequest::set_src_path(const ::std::string& value) {
  
  src_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.RenameRequest.src_path)
}
#if LANG_CXX11
inline void RenameRequest::set_src_path(::std::string&& value) {
  
  src_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.RenameRequest.src_path)
}
#endif
inline void RenameRequest::set_src_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  src_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.RenameRequest.src_path)
}
inline void RenameRequest::set_src_path(const char* value, size_t size) {
  
  src_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.RenameRequest.src_path)
}
inline ::std::string* RenameRequest::mutable_src_path() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.RenameRequest.src_path)
  return src_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenameRequest::release_src_path() {
  // @@protoc_insertion_point(field_release:Rpc.RenameRequest.src_path)
  
  return src_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenameRequest::set_allocated_src_path(::std::string* src_path) {
  if (src_path != NULL) {
    
  } else {
    
  }
  src_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), src_path);
  // @@protoc_insertion_point(field_set_allocated:Rpc.RenameRequest.src_path)
}

// string des_path = 2;
inline void RenameRequest::clear_des_path() {
  des_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& RenameRequest::des_path() const {
  // @@protoc_insertion_point(field_get:Rpc.RenameRequest.des_path)
  return des_path_.GetNoArena();
}
inline void RenameRequest::set_des_path(const ::std::string& value) {
  
  des_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.RenameRequest.des_path)
}
#if LANG_CXX11
inline void RenameRequest::set_des_path(::std::string&& value) {
  
  des_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.RenameRequest.des_path)
}
#endif
inline void RenameRequest::set_des_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  des_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.RenameRequest.des_path)
}
inline void RenameRequest::set_des_path(const char* value, size_t size) {
  
  des_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.RenameRequest.des_path)
}
inline ::std::string* RenameRequest::mutable_des_path() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.RenameRequest.des_path)
  return des_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RenameRequest::release_des_path() {
  // @@protoc_insertion_point(field_release:Rpc.RenameRequest.des_path)
  
  return des_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RenameRequest::set_allocated_des_path(::std::string* des_path) {
  if (des_path != NULL) {
    
  } else {
    
  }
  des_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), des_path);
  // @@protoc_insertion_point(field_set_allocated:Rpc.RenameRequest.des_path)
}

// -------------------------------------------------------------------

// RenameReply

// -------------------------------------------------------------------

// DeleteRequest

// string remote_file_path = 1;
inline void DeleteRequest::clear_remote_file_path() {
  remote_file_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DeleteRequest::remote_file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.DeleteRequest.remote_file_path)
  return remote_file_path_.GetNoArena();
}
inline void DeleteRequest::set_remote_file_path(const ::std::string& value) {
  
  remote_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.DeleteRequest.remote_file_path)
}
#if LANG_CXX11
inline void DeleteRequest::set_remote_file_path(::std::string&& value) {
  
  remote_file_path_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.DeleteRequest.remote_file_path)
}
#endif
inline void DeleteRequest::set_remote_file_path(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  remote_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.DeleteRequest.remote_file_path)
}
inline void DeleteRequest::set_remote_file_path(const char* value, size_t size) {
  
  remote_file_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.DeleteRequest.remote_file_path)
}
inline ::std::string* DeleteRequest::mutable_remote_file_path() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.DeleteRequest.remote_file_path)
  return remote_file_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DeleteRequest::release_remote_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.DeleteRequest.remote_file_path)
  
  return remote_file_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DeleteRequest::set_allocated_remote_file_path(::std::string* remote_file_path) {
  if (remote_file_path != NULL) {
    
  } else {
    
  }
  remote_file_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), remote_file_path);
  // @@protoc_insertion_point(field_set_allocated:Rpc.DeleteRequest.remote_file_path)
}

// -------------------------------------------------------------------

// DeleteReply

// -------------------------------------------------------------------

// StatRequest

// string filepath = 1;
inline void StatRequest::clear_filepath() {
  filepath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatRequest::filepath() const {
  // @@protoc_insertion_point(field_get:Rpc.StatRequest.filepath)
  return filepath_.GetNoArena();
}
inline void StatRequest::set_filepath(const ::std::string& value) {
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.StatRequest.filepath)
}
#if LANG_CXX11
inline void StatRequest::set_filepath(::std::string&& value) {
  
  filepath_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.StatRequest.filepath)
}
#endif
inline void StatRequest::set_filepath(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.StatRequest.filepath)
}
inline void StatRequest::set_filepath(const char* value, size_t size) {
  
  filepath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.StatRequest.filepath)
}
inline ::std::string* StatRequest::mutable_filepath() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.StatRequest.filepath)
  return filepath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatRequest::release_filepath() {
  // @@protoc_insertion_point(field_release:Rpc.StatRequest.filepath)
  
  return filepath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatRequest::set_allocated_filepath(::std::string* filepath) {
  if (filepath != NULL) {
    
  } else {
    
  }
  filepath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), filepath);
  // @@protoc_insertion_point(field_set_allocated:Rpc.StatRequest.filepath)
}

// -------------------------------------------------------------------

// StatReply

// bool existed = 1;
inline void StatReply::clear_existed() {
  existed_ = false;
}
inline bool StatReply::existed() const {
  // @@protoc_insertion_point(field_get:Rpc.StatReply.existed)
  return existed_;
}
inline void StatReply::set_existed(bool value) {
  
  existed_ = value;
  // @@protoc_insertion_point(field_set:Rpc.StatReply.existed)
}

// string file_name = 2;
inline void StatReply::clear_file_name() {
  file_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatReply::file_name() const {
  // @@protoc_insertion_point(field_get:Rpc.StatReply.file_name)
  return file_name_.GetNoArena();
}
inline void StatReply::set_file_name(const ::std::string& value) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.StatReply.file_name)
}
#if LANG_CXX11
inline void StatReply::set_file_name(::std::string&& value) {
  
  file_name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.StatReply.file_name)
}
#endif
inline void StatReply::set_file_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.StatReply.file_name)
}
inline void StatReply::set_file_name(const char* value, size_t size) {
  
  file_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.StatReply.file_name)
}
inline ::std::string* StatReply::mutable_file_name() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.StatReply.file_name)
  return file_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatReply::release_file_name() {
  // @@protoc_insertion_point(field_release:Rpc.StatReply.file_name)
  
  return file_name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatReply::set_allocated_file_name(::std::string* file_name) {
  if (file_name != NULL) {
    
  } else {
    
  }
  file_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), file_name);
  // @@protoc_insertion_point(field_set_allocated:Rpc.StatReply.file_name)
}

// uint64 file_size = 3;
inline void StatReply::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 StatReply::file_size() const {
  // @@protoc_insertion_point(field_get:Rpc.StatReply.file_size)
  return file_size_;
}
inline void StatReply::set_file_size(::google::protobuf::uint64 value) {
  
  file_size_ = value;
  // @@protoc_insertion_point(field_set:Rpc.StatReply.file_size)
}

// -------------------------------------------------------------------

// WriteChunkRequest

// int64 client_id = 1;
inline void WriteChunkRequest::clear_client_id() {
  client_id_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteChunkRequest::client_id() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.client_id)
  return client_id_;
}
inline void WriteChunkRequest::set_client_id(::google::protobuf::int64 value) {
  
  client_id_ = value;
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.client_id)
}

// int64 chunkhandle = 2;
inline void WriteChunkRequest::clear_chunkhandle() {
  chunkhandle_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteChunkRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.chunkhandle)
  return chunkhandle_;
}
inline void WriteChunkRequest::set_chunkhandle(::google::protobuf::int64 value) {
  
  chunkhandle_ = value;
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.chunkhandle)
}

// int64 offset = 3;
inline void WriteChunkRequest::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteChunkRequest::offset() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.offset)
  return offset_;
}
inline void WriteChunkRequest::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.offset)
}

// int64 length = 4;
inline void WriteChunkRequest::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteChunkRequest::length() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.length)
  return length_;
}
inline void WriteChunkRequest::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.length)
}

// repeated string locations = 5;
inline int WriteChunkRequest::locations_size() const {
  return locations_.size();
}
inline void WriteChunkRequest::clear_locations() {
  locations_.Clear();
}
inline const ::std::string& WriteChunkRequest::locations(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.locations)
  return locations_.Get(index);
}
inline ::std::string* WriteChunkRequest::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.WriteChunkRequest.locations)
  return locations_.Mutable(index);
}
inline void WriteChunkRequest::set_locations(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.locations)
  locations_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void WriteChunkRequest::set_locations(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.locations)
  locations_.Mutable(index)->assign(std::move(value));
}
#endif
inline void WriteChunkRequest::set_locations(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  locations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::set_locations(int index, const char* value, size_t size) {
  locations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.WriteChunkRequest.locations)
}
inline ::std::string* WriteChunkRequest::add_locations() {
  // @@protoc_insertion_point(field_add_mutable:Rpc.WriteChunkRequest.locations)
  return locations_.Add();
}
inline void WriteChunkRequest::add_locations(const ::std::string& value) {
  locations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.WriteChunkRequest.locations)
}
#if LANG_CXX11
inline void WriteChunkRequest::add_locations(::std::string&& value) {
  locations_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.WriteChunkRequest.locations)
}
#endif
inline void WriteChunkRequest::add_locations(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  locations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::add_locations(const char* value, size_t size) {
  locations_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.WriteChunkRequest.locations)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
WriteChunkRequest::locations() const {
  // @@protoc_insertion_point(field_list:Rpc.WriteChunkRequest.locations)
  return locations_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
WriteChunkRequest::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.WriteChunkRequest.locations)
  return &locations_;
}

// string data = 6;
inline void WriteChunkRequest::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& WriteChunkRequest::data() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.data)
  return data_.GetNoArena();
}
inline void WriteChunkRequest::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.data)
}
#if LANG_CXX11
inline void WriteChunkRequest::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.WriteChunkRequest.data)
}
#endif
inline void WriteChunkRequest::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.WriteChunkRequest.data)
}
inline void WriteChunkRequest::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.WriteChunkRequest.data)
}
inline ::std::string* WriteChunkRequest::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.WriteChunkRequest.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* WriteChunkRequest::release_data() {
  // @@protoc_insertion_point(field_release:Rpc.WriteChunkRequest.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void WriteChunkRequest::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Rpc.WriteChunkRequest.data)
}

// -------------------------------------------------------------------

// WriteChunkReply

// int64 bytes_read = 2;
inline void WriteChunkReply::clear_bytes_read() {
  bytes_read_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 WriteChunkReply::bytes_read() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkReply.bytes_read)
  return bytes_read_;
}
inline void WriteChunkReply::set_bytes_read(::google::protobuf::int64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkReply.bytes_read)
}

// -------------------------------------------------------------------

// ReadChunkRequest

// int64 chunkhandle = 1;
inline void ReadChunkRequest::clear_chunkhandle() {
  chunkhandle_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReadChunkRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkRequest.chunkhandle)
  return chunkhandle_;
}
inline void ReadChunkRequest::set_chunkhandle(::google::protobuf::int64 value) {
  
  chunkhandle_ = value;
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkRequest.chunkhandle)
}

// int64 offset = 2;
inline void ReadChunkRequest::clear_offset() {
  offset_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReadChunkRequest::offset() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkRequest.offset)
  return offset_;
}
inline void ReadChunkRequest::set_offset(::google::protobuf::int64 value) {
  
  offset_ = value;
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkRequest.offset)
}

// int64 length = 3;
inline void ReadChunkRequest::clear_length() {
  length_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReadChunkRequest::length() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkRequest.length)
  return length_;
}
inline void ReadChunkRequest::set_length(::google::protobuf::int64 value) {
  
  length_ = value;
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkRequest.length)
}

// -------------------------------------------------------------------

// ReadChunkReply

// string data = 1;
inline void ReadChunkReply::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReadChunkReply::data() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkReply.data)
  return data_.GetNoArena();
}
inline void ReadChunkReply::set_data(const ::std::string& value) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkReply.data)
}
#if LANG_CXX11
inline void ReadChunkReply::set_data(::std::string&& value) {
  
  data_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.ReadChunkReply.data)
}
#endif
inline void ReadChunkReply::set_data(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.ReadChunkReply.data)
}
inline void ReadChunkReply::set_data(const char* value, size_t size) {
  
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.ReadChunkReply.data)
}
inline ::std::string* ReadChunkReply::mutable_data() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.ReadChunkReply.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReadChunkReply::release_data() {
  // @@protoc_insertion_point(field_release:Rpc.ReadChunkReply.data)
  
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReadChunkReply::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    
  } else {
    
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:Rpc.ReadChunkReply.data)
}

// int64 bytes_read = 2;
inline void ReadChunkReply::clear_bytes_read() {
  bytes_read_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReadChunkReply::bytes_read() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkReply.bytes_read)
  return bytes_read_;
}
inline void ReadChunkReply::set_bytes_read(::google::protobuf::int64 value) {
  
  bytes_read_ = value;
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkReply.bytes_read)
}

// -------------------------------------------------------------------

// DataNodeLocation

// string location = 1;
inline void DataNodeLocation::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataNodeLocation::location() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNodeLocation.location)
  return location_.GetNoArena();
}
inline void DataNodeLocation::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.DataNodeLocation.location)
}
#if LANG_CXX11
inline void DataNodeLocation::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.DataNodeLocation.location)
}
#endif
inline void DataNodeLocation::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.DataNodeLocation.location)
}
inline void DataNodeLocation::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.DataNodeLocation.location)
}
inline ::std::string* DataNodeLocation::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.DataNodeLocation.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataNodeLocation::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.DataNodeLocation.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataNodeLocation::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Rpc.DataNodeLocation.location)
}

// -------------------------------------------------------------------

// DataNode

// string location = 1;
inline void DataNode::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DataNode::location() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.location)
  return location_.GetNoArena();
}
inline void DataNode::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.DataNode.location)
}
#if LANG_CXX11
inline void DataNode::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.DataNode.location)
}
#endif
inline void DataNode::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.DataNode.location)
}
inline void DataNode::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.DataNode.location)
}
inline ::std::string* DataNode::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.DataNode.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DataNode::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.DataNode.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DataNode::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Rpc.DataNode.location)
}

// uint32 available_size = 2;
inline void DataNode::clear_available_size() {
  available_size_ = 0u;
}
inline ::google::protobuf::uint32 DataNode::available_size() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.available_size)
  return available_size_;
}
inline void DataNode::set_available_size(::google::protobuf::uint32 value) {
  
  available_size_ = value;
  // @@protoc_insertion_point(field_set:Rpc.DataNode.available_size)
}

// repeated int64 stored_chunk_handles = 3;
inline int DataNode::stored_chunk_handles_size() const {
  return stored_chunk_handles_.size();
}
inline void DataNode::clear_stored_chunk_handles() {
  stored_chunk_handles_.Clear();
}
inline ::google::protobuf::int64 DataNode::stored_chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.stored_chunk_handles)
  return stored_chunk_handles_.Get(index);
}
inline void DataNode::set_stored_chunk_handles(int index, ::google::protobuf::int64 value) {
  stored_chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.DataNode.stored_chunk_handles)
}
inline void DataNode::add_stored_chunk_handles(::google::protobuf::int64 value) {
  stored_chunk_handles_.Add(value);
  // @@protoc_insertion_point(field_add:Rpc.DataNode.stored_chunk_handles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
DataNode::stored_chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.DataNode.stored_chunk_handles)
  return stored_chunk_handles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
DataNode::mutable_stored_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.DataNode.stored_chunk_handles)
  return &stored_chunk_handles_;
}

// -------------------------------------------------------------------

// Chunk

// int64 chunk_handle = 1;
inline void Chunk::clear_chunk_handle() {
  chunk_handle_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Chunk::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.chunk_handle)
  return chunk_handle_;
}
inline void Chunk::set_chunk_handle(::google::protobuf::int64 value) {
  
  chunk_handle_ = value;
  // @@protoc_insertion_point(field_set:Rpc.Chunk.chunk_handle)
}

// repeated string location = 2;
inline int Chunk::location_size() const {
  return location_.size();
}
inline void Chunk::clear_location() {
  location_.Clear();
}
inline const ::std::string& Chunk::location(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.location)
  return location_.Get(index);
}
inline ::std::string* Chunk::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.Chunk.location)
  return location_.Mutable(index);
}
inline void Chunk::set_location(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:Rpc.Chunk.location)
  location_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Chunk::set_location(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:Rpc.Chunk.location)
  location_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Chunk::set_location(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, const char* value, size_t size) {
  location_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.Chunk.location)
}
inline ::std::string* Chunk::add_location() {
  // @@protoc_insertion_point(field_add_mutable:Rpc.Chunk.location)
  return location_.Add();
}
inline void Chunk::add_location(const ::std::string& value) {
  location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.Chunk.location)
}
#if LANG_CXX11
inline void Chunk::add_location(::std::string&& value) {
  location_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.Chunk.location)
}
#endif
inline void Chunk::add_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.Chunk.location)
}
inline void Chunk::add_location(const char* value, size_t size) {
  location_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.Chunk.location)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Chunk::location() const {
  // @@protoc_insertion_point(field_list:Rpc.Chunk.location)
  return location_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Chunk::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.Chunk.location)
  return &location_;
}

// int64 size = 3;
inline void Chunk::clear_size() {
  size_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 Chunk::size() const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.size)
  return size_;
}
inline void Chunk::set_size(::google::protobuf::int64 value) {
  
  size_ = value;
  // @@protoc_insertion_point(field_set:Rpc.Chunk.size)
}

// -------------------------------------------------------------------

// ReportDataNodeRequest

// string location = 1;
inline void ReportDataNodeRequest::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ReportDataNodeRequest::location() const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.location)
  return location_.GetNoArena();
}
inline void ReportDataNodeRequest::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.ReportDataNodeRequest.location)
}
#if LANG_CXX11
inline void ReportDataNodeRequest::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.ReportDataNodeRequest.location)
}
#endif
inline void ReportDataNodeRequest::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.ReportDataNodeRequest.location)
}
inline void ReportDataNodeRequest::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.ReportDataNodeRequest.location)
}
inline ::std::string* ReportDataNodeRequest::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.ReportDataNodeRequest.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ReportDataNodeRequest::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.ReportDataNodeRequest.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ReportDataNodeRequest::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Rpc.ReportDataNodeRequest.location)
}

// uint32 available_size = 2;
inline void ReportDataNodeRequest::clear_available_size() {
  available_size_ = 0u;
}
inline ::google::protobuf::uint32 ReportDataNodeRequest::available_size() const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.available_size)
  return available_size_;
}
inline void ReportDataNodeRequest::set_available_size(::google::protobuf::uint32 value) {
  
  available_size_ = value;
  // @@protoc_insertion_point(field_set:Rpc.ReportDataNodeRequest.available_size)
}

// repeated int64 stored_chunk_handles = 3;
inline int ReportDataNodeRequest::stored_chunk_handles_size() const {
  return stored_chunk_handles_.size();
}
inline void ReportDataNodeRequest::clear_stored_chunk_handles() {
  stored_chunk_handles_.Clear();
}
inline ::google::protobuf::int64 ReportDataNodeRequest::stored_chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.stored_chunk_handles)
  return stored_chunk_handles_.Get(index);
}
inline void ReportDataNodeRequest::set_stored_chunk_handles(int index, ::google::protobuf::int64 value) {
  stored_chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.ReportDataNodeRequest.stored_chunk_handles)
}
inline void ReportDataNodeRequest::add_stored_chunk_handles(::google::protobuf::int64 value) {
  stored_chunk_handles_.Add(value);
  // @@protoc_insertion_point(field_add:Rpc.ReportDataNodeRequest.stored_chunk_handles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
ReportDataNodeRequest::stored_chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.ReportDataNodeRequest.stored_chunk_handles)
  return stored_chunk_handles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
ReportDataNodeRequest::mutable_stored_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.ReportDataNodeRequest.stored_chunk_handles)
  return &stored_chunk_handles_;
}

// -------------------------------------------------------------------

// ReportDataNodeReply

// -------------------------------------------------------------------

// HeartbeatRequest

// -------------------------------------------------------------------

// HeartbeatReply

// .Rpc.HeartbeatRequest request = 1;
inline bool HeartbeatReply::has_request() const {
  return this != internal_default_instance() && request_ != NULL;
}
inline void HeartbeatReply::clear_request() {
  if (GetArenaNoVirtual() == NULL && request_ != NULL) {
    delete request_;
  }
  request_ = NULL;
}
inline const ::Rpc::HeartbeatRequest& HeartbeatReply::_internal_request() const {
  return *request_;
}
inline const ::Rpc::HeartbeatRequest& HeartbeatReply::request() const {
  const ::Rpc::HeartbeatRequest* p = request_;
  // @@protoc_insertion_point(field_get:Rpc.HeartbeatReply.request)
  return p != NULL ? *p : *reinterpret_cast<const ::Rpc::HeartbeatRequest*>(
      &::Rpc::_HeartbeatRequest_default_instance_);
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::release_request() {
  // @@protoc_insertion_point(field_release:Rpc.HeartbeatReply.request)
  
  ::Rpc::HeartbeatRequest* temp = request_;
  request_ = NULL;
  return temp;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::mutable_request() {
  
  if (request_ == NULL) {
    auto* p = CreateMaybeMessage<::Rpc::HeartbeatRequest>(GetArenaNoVirtual());
    request_ = p;
  }
  // @@protoc_insertion_point(field_mutable:Rpc.HeartbeatReply.request)
  return request_;
}
inline void HeartbeatReply::set_allocated_request(::Rpc::HeartbeatRequest* request) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete request_;
  }
  if (request) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      request = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:Rpc.HeartbeatReply.request)
}

// -------------------------------------------------------------------

// CopyChunkRequest

// string location = 1;
inline void CopyChunkRequest::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CopyChunkRequest::location() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkRequest.location)
  return location_.GetNoArena();
}
inline void CopyChunkRequest::set_location(const ::std::string& value) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkRequest.location)
}
#if LANG_CXX11
inline void CopyChunkRequest::set_location(::std::string&& value) {
  
  location_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:Rpc.CopyChunkRequest.location)
}
#endif
inline void CopyChunkRequest::set_location(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:Rpc.CopyChunkRequest.location)
}
inline void CopyChunkRequest::set_location(const char* value, size_t size) {
  
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:Rpc.CopyChunkRequest.location)
}
inline ::std::string* CopyChunkRequest::mutable_location() {
  
  // @@protoc_insertion_point(field_mutable:Rpc.CopyChunkRequest.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CopyChunkRequest::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.CopyChunkRequest.location)
  
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CopyChunkRequest::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    
  } else {
    
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:Rpc.CopyChunkRequest.location)
}

// int64 chunk_handle = 2;
inline void CopyChunkRequest::clear_chunk_handle() {
  chunk_handle_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CopyChunkRequest::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkRequest.chunk_handle)
  return chunk_handle_;
}
inline void CopyChunkRequest::set_chunk_handle(::google::protobuf::int64 value) {
  
  chunk_handle_ = value;
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkRequest.chunk_handle)
}

// -------------------------------------------------------------------

// CopyChunkReply

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Rpc

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_NameNode_2eproto
