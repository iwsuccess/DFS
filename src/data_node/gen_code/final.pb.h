// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: final.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_final_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_final_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_final_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_final_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_final_2eproto;
namespace Rpc {
class AppendEntriesArgs;
struct AppendEntriesArgsDefaultTypeInternal;
extern AppendEntriesArgsDefaultTypeInternal _AppendEntriesArgs_default_instance_;
class AppendEntriesReply;
struct AppendEntriesReplyDefaultTypeInternal;
extern AppendEntriesReplyDefaultTypeInternal _AppendEntriesReply_default_instance_;
class Chunk;
struct ChunkDefaultTypeInternal;
extern ChunkDefaultTypeInternal _Chunk_default_instance_;
class CopyChunkReply;
struct CopyChunkReplyDefaultTypeInternal;
extern CopyChunkReplyDefaultTypeInternal _CopyChunkReply_default_instance_;
class CopyChunkRequest;
struct CopyChunkRequestDefaultTypeInternal;
extern CopyChunkRequestDefaultTypeInternal _CopyChunkRequest_default_instance_;
class CopyChunkWriteReply;
struct CopyChunkWriteReplyDefaultTypeInternal;
extern CopyChunkWriteReplyDefaultTypeInternal _CopyChunkWriteReply_default_instance_;
class CopyChunkWriteRequest;
struct CopyChunkWriteRequestDefaultTypeInternal;
extern CopyChunkWriteRequestDefaultTypeInternal _CopyChunkWriteRequest_default_instance_;
class DataNode;
struct DataNodeDefaultTypeInternal;
extern DataNodeDefaultTypeInternal _DataNode_default_instance_;
class DataNodeLocation;
struct DataNodeLocationDefaultTypeInternal;
extern DataNodeLocationDefaultTypeInternal _DataNodeLocation_default_instance_;
class DeleteReply;
struct DeleteReplyDefaultTypeInternal;
extern DeleteReplyDefaultTypeInternal _DeleteReply_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class FindAddrReply;
struct FindAddrReplyDefaultTypeInternal;
extern FindAddrReplyDefaultTypeInternal _FindAddrReply_default_instance_;
class FindAddrReply_ReplicaAddrs;
struct FindAddrReply_ReplicaAddrsDefaultTypeInternal;
extern FindAddrReply_ReplicaAddrsDefaultTypeInternal _FindAddrReply_ReplicaAddrs_default_instance_;
class FindAddrRequest;
struct FindAddrRequestDefaultTypeInternal;
extern FindAddrRequestDefaultTypeInternal _FindAddrRequest_default_instance_;
class GetSubDirNamesReply;
struct GetSubDirNamesReplyDefaultTypeInternal;
extern GetSubDirNamesReplyDefaultTypeInternal _GetSubDirNamesReply_default_instance_;
class GetSubDirNamesRequest;
struct GetSubDirNamesRequestDefaultTypeInternal;
extern GetSubDirNamesRequestDefaultTypeInternal _GetSubDirNamesRequest_default_instance_;
class GetWriteAddrReply;
struct GetWriteAddrReplyDefaultTypeInternal;
extern GetWriteAddrReplyDefaultTypeInternal _GetWriteAddrReply_default_instance_;
class GetWriteAddrReply_ReplicaAddrs;
struct GetWriteAddrReply_ReplicaAddrsDefaultTypeInternal;
extern GetWriteAddrReply_ReplicaAddrsDefaultTypeInternal _GetWriteAddrReply_ReplicaAddrs_default_instance_;
class GetWriteAddrRequest;
struct GetWriteAddrRequestDefaultTypeInternal;
extern GetWriteAddrRequestDefaultTypeInternal _GetWriteAddrRequest_default_instance_;
class HeartbeatReply;
struct HeartbeatReplyDefaultTypeInternal;
extern HeartbeatReplyDefaultTypeInternal _HeartbeatReply_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class HelloReply;
struct HelloReplyDefaultTypeInternal;
extern HelloReplyDefaultTypeInternal _HelloReply_default_instance_;
class HelloRequest;
struct HelloRequestDefaultTypeInternal;
extern HelloRequestDefaultTypeInternal _HelloRequest_default_instance_;
class LogEntry;
struct LogEntryDefaultTypeInternal;
extern LogEntryDefaultTypeInternal _LogEntry_default_instance_;
class MkdirReply;
struct MkdirReplyDefaultTypeInternal;
extern MkdirReplyDefaultTypeInternal _MkdirReply_default_instance_;
class MkdirRequest;
struct MkdirRequestDefaultTypeInternal;
extern MkdirRequestDefaultTypeInternal _MkdirRequest_default_instance_;
class MultiWriteReply;
struct MultiWriteReplyDefaultTypeInternal;
extern MultiWriteReplyDefaultTypeInternal _MultiWriteReply_default_instance_;
class MultiWriteRequest;
struct MultiWriteRequestDefaultTypeInternal;
extern MultiWriteRequestDefaultTypeInternal _MultiWriteRequest_default_instance_;
class ReadChunkReply;
struct ReadChunkReplyDefaultTypeInternal;
extern ReadChunkReplyDefaultTypeInternal _ReadChunkReply_default_instance_;
class ReadChunkRequest;
struct ReadChunkRequestDefaultTypeInternal;
extern ReadChunkRequestDefaultTypeInternal _ReadChunkRequest_default_instance_;
class RenameReply;
struct RenameReplyDefaultTypeInternal;
extern RenameReplyDefaultTypeInternal _RenameReply_default_instance_;
class RenameRequest;
struct RenameRequestDefaultTypeInternal;
extern RenameRequestDefaultTypeInternal _RenameRequest_default_instance_;
class ReportDataNodeReply;
struct ReportDataNodeReplyDefaultTypeInternal;
extern ReportDataNodeReplyDefaultTypeInternal _ReportDataNodeReply_default_instance_;
class ReportDataNodeRequest;
struct ReportDataNodeRequestDefaultTypeInternal;
extern ReportDataNodeRequestDefaultTypeInternal _ReportDataNodeRequest_default_instance_;
class RequestVoteArgs;
struct RequestVoteArgsDefaultTypeInternal;
extern RequestVoteArgsDefaultTypeInternal _RequestVoteArgs_default_instance_;
class RequestVoteReply;
struct RequestVoteReplyDefaultTypeInternal;
extern RequestVoteReplyDefaultTypeInternal _RequestVoteReply_default_instance_;
class StatReply;
struct StatReplyDefaultTypeInternal;
extern StatReplyDefaultTypeInternal _StatReply_default_instance_;
class StatRequest;
struct StatRequestDefaultTypeInternal;
extern StatRequestDefaultTypeInternal _StatRequest_default_instance_;
class WriteChunkReply;
struct WriteChunkReplyDefaultTypeInternal;
extern WriteChunkReplyDefaultTypeInternal _WriteChunkReply_default_instance_;
class WriteChunkRequest;
struct WriteChunkRequestDefaultTypeInternal;
extern WriteChunkRequestDefaultTypeInternal _WriteChunkRequest_default_instance_;
}  // namespace Rpc
PROTOBUF_NAMESPACE_OPEN
template<> ::Rpc::AppendEntriesArgs* Arena::CreateMaybeMessage<::Rpc::AppendEntriesArgs>(Arena*);
template<> ::Rpc::AppendEntriesReply* Arena::CreateMaybeMessage<::Rpc::AppendEntriesReply>(Arena*);
template<> ::Rpc::Chunk* Arena::CreateMaybeMessage<::Rpc::Chunk>(Arena*);
template<> ::Rpc::CopyChunkReply* Arena::CreateMaybeMessage<::Rpc::CopyChunkReply>(Arena*);
template<> ::Rpc::CopyChunkRequest* Arena::CreateMaybeMessage<::Rpc::CopyChunkRequest>(Arena*);
template<> ::Rpc::CopyChunkWriteReply* Arena::CreateMaybeMessage<::Rpc::CopyChunkWriteReply>(Arena*);
template<> ::Rpc::CopyChunkWriteRequest* Arena::CreateMaybeMessage<::Rpc::CopyChunkWriteRequest>(Arena*);
template<> ::Rpc::DataNode* Arena::CreateMaybeMessage<::Rpc::DataNode>(Arena*);
template<> ::Rpc::DataNodeLocation* Arena::CreateMaybeMessage<::Rpc::DataNodeLocation>(Arena*);
template<> ::Rpc::DeleteReply* Arena::CreateMaybeMessage<::Rpc::DeleteReply>(Arena*);
template<> ::Rpc::DeleteRequest* Arena::CreateMaybeMessage<::Rpc::DeleteRequest>(Arena*);
template<> ::Rpc::FindAddrReply* Arena::CreateMaybeMessage<::Rpc::FindAddrReply>(Arena*);
template<> ::Rpc::FindAddrReply_ReplicaAddrs* Arena::CreateMaybeMessage<::Rpc::FindAddrReply_ReplicaAddrs>(Arena*);
template<> ::Rpc::FindAddrRequest* Arena::CreateMaybeMessage<::Rpc::FindAddrRequest>(Arena*);
template<> ::Rpc::GetSubDirNamesReply* Arena::CreateMaybeMessage<::Rpc::GetSubDirNamesReply>(Arena*);
template<> ::Rpc::GetSubDirNamesRequest* Arena::CreateMaybeMessage<::Rpc::GetSubDirNamesRequest>(Arena*);
template<> ::Rpc::GetWriteAddrReply* Arena::CreateMaybeMessage<::Rpc::GetWriteAddrReply>(Arena*);
template<> ::Rpc::GetWriteAddrReply_ReplicaAddrs* Arena::CreateMaybeMessage<::Rpc::GetWriteAddrReply_ReplicaAddrs>(Arena*);
template<> ::Rpc::GetWriteAddrRequest* Arena::CreateMaybeMessage<::Rpc::GetWriteAddrRequest>(Arena*);
template<> ::Rpc::HeartbeatReply* Arena::CreateMaybeMessage<::Rpc::HeartbeatReply>(Arena*);
template<> ::Rpc::HeartbeatRequest* Arena::CreateMaybeMessage<::Rpc::HeartbeatRequest>(Arena*);
template<> ::Rpc::HelloReply* Arena::CreateMaybeMessage<::Rpc::HelloReply>(Arena*);
template<> ::Rpc::HelloRequest* Arena::CreateMaybeMessage<::Rpc::HelloRequest>(Arena*);
template<> ::Rpc::LogEntry* Arena::CreateMaybeMessage<::Rpc::LogEntry>(Arena*);
template<> ::Rpc::MkdirReply* Arena::CreateMaybeMessage<::Rpc::MkdirReply>(Arena*);
template<> ::Rpc::MkdirRequest* Arena::CreateMaybeMessage<::Rpc::MkdirRequest>(Arena*);
template<> ::Rpc::MultiWriteReply* Arena::CreateMaybeMessage<::Rpc::MultiWriteReply>(Arena*);
template<> ::Rpc::MultiWriteRequest* Arena::CreateMaybeMessage<::Rpc::MultiWriteRequest>(Arena*);
template<> ::Rpc::ReadChunkReply* Arena::CreateMaybeMessage<::Rpc::ReadChunkReply>(Arena*);
template<> ::Rpc::ReadChunkRequest* Arena::CreateMaybeMessage<::Rpc::ReadChunkRequest>(Arena*);
template<> ::Rpc::RenameReply* Arena::CreateMaybeMessage<::Rpc::RenameReply>(Arena*);
template<> ::Rpc::RenameRequest* Arena::CreateMaybeMessage<::Rpc::RenameRequest>(Arena*);
template<> ::Rpc::ReportDataNodeReply* Arena::CreateMaybeMessage<::Rpc::ReportDataNodeReply>(Arena*);
template<> ::Rpc::ReportDataNodeRequest* Arena::CreateMaybeMessage<::Rpc::ReportDataNodeRequest>(Arena*);
template<> ::Rpc::RequestVoteArgs* Arena::CreateMaybeMessage<::Rpc::RequestVoteArgs>(Arena*);
template<> ::Rpc::RequestVoteReply* Arena::CreateMaybeMessage<::Rpc::RequestVoteReply>(Arena*);
template<> ::Rpc::StatReply* Arena::CreateMaybeMessage<::Rpc::StatReply>(Arena*);
template<> ::Rpc::StatRequest* Arena::CreateMaybeMessage<::Rpc::StatRequest>(Arena*);
template<> ::Rpc::WriteChunkReply* Arena::CreateMaybeMessage<::Rpc::WriteChunkReply>(Arena*);
template<> ::Rpc::WriteChunkRequest* Arena::CreateMaybeMessage<::Rpc::WriteChunkRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Rpc {

// ===================================================================

class LogEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.LogEntry) */ {
 public:
  inline LogEntry() : LogEntry(nullptr) {}
  ~LogEntry() override;
  explicit PROTOBUF_CONSTEXPR LogEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogEntry(const LogEntry& from);
  LogEntry(LogEntry&& from) noexcept
    : LogEntry() {
    *this = ::std::move(from);
  }

  inline LogEntry& operator=(const LogEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogEntry& operator=(LogEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogEntry* internal_default_instance() {
    return reinterpret_cast<const LogEntry*>(
               &_LogEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(LogEntry& a, LogEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(LogEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogEntry& from) {
    LogEntry::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.LogEntry";
  }
  protected:
  explicit LogEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilepathFieldNumber = 6,
    kSrcFieldNumber = 7,
    kDesFieldNumber = 8,
    kGetwFieldNumber = 3,
    kRenameFieldNumber = 4,
    kDelFieldNumber = 5,
    kTermFieldNumber = 1,
    kCommandFieldNumber = 2,
    kSizeFieldNumber = 9,
  };
  // string filepath = 6;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // string src = 7;
  void clear_src();
  const std::string& src() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src();
  PROTOBUF_NODISCARD std::string* release_src();
  void set_allocated_src(std::string* src);
  private:
  const std::string& _internal_src() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src(const std::string& value);
  std::string* _internal_mutable_src();
  public:

  // string des = 8;
  void clear_des();
  const std::string& des() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_des(ArgT0&& arg0, ArgT... args);
  std::string* mutable_des();
  PROTOBUF_NODISCARD std::string* release_des();
  void set_allocated_des(std::string* des);
  private:
  const std::string& _internal_des() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_des(const std::string& value);
  std::string* _internal_mutable_des();
  public:

  // .Rpc.GetWriteAddrRequest getw = 3;
  bool has_getw() const;
  private:
  bool _internal_has_getw() const;
  public:
  void clear_getw();
  const ::Rpc::GetWriteAddrRequest& getw() const;
  PROTOBUF_NODISCARD ::Rpc::GetWriteAddrRequest* release_getw();
  ::Rpc::GetWriteAddrRequest* mutable_getw();
  void set_allocated_getw(::Rpc::GetWriteAddrRequest* getw);
  private:
  const ::Rpc::GetWriteAddrRequest& _internal_getw() const;
  ::Rpc::GetWriteAddrRequest* _internal_mutable_getw();
  public:
  void unsafe_arena_set_allocated_getw(
      ::Rpc::GetWriteAddrRequest* getw);
  ::Rpc::GetWriteAddrRequest* unsafe_arena_release_getw();

  // .Rpc.RenameRequest rename = 4;
  bool has_rename() const;
  private:
  bool _internal_has_rename() const;
  public:
  void clear_rename();
  const ::Rpc::RenameRequest& rename() const;
  PROTOBUF_NODISCARD ::Rpc::RenameRequest* release_rename();
  ::Rpc::RenameRequest* mutable_rename();
  void set_allocated_rename(::Rpc::RenameRequest* rename);
  private:
  const ::Rpc::RenameRequest& _internal_rename() const;
  ::Rpc::RenameRequest* _internal_mutable_rename();
  public:
  void unsafe_arena_set_allocated_rename(
      ::Rpc::RenameRequest* rename);
  ::Rpc::RenameRequest* unsafe_arena_release_rename();

  // .Rpc.DeleteRequest del = 5;
  bool has_del() const;
  private:
  bool _internal_has_del() const;
  public:
  void clear_del();
  const ::Rpc::DeleteRequest& del() const;
  PROTOBUF_NODISCARD ::Rpc::DeleteRequest* release_del();
  ::Rpc::DeleteRequest* mutable_del();
  void set_allocated_del(::Rpc::DeleteRequest* del);
  private:
  const ::Rpc::DeleteRequest& _internal_del() const;
  ::Rpc::DeleteRequest* _internal_mutable_del();
  public:
  void unsafe_arena_set_allocated_del(
      ::Rpc::DeleteRequest* del);
  ::Rpc::DeleteRequest* unsafe_arena_release_del();

  // int32 Term = 1;
  void clear_term();
  int32_t term() const;
  void set_term(int32_t value);
  private:
  int32_t _internal_term() const;
  void _internal_set_term(int32_t value);
  public:

  // int32 command = 2;
  void clear_command();
  int32_t command() const;
  void set_command(int32_t value);
  private:
  int32_t _internal_command() const;
  void _internal_set_command(int32_t value);
  public:

  // int64 size = 9;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.LogEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr des_;
    ::Rpc::GetWriteAddrRequest* getw_;
    ::Rpc::RenameRequest* rename_;
    ::Rpc::DeleteRequest* del_;
    int32_t term_;
    int32_t command_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.AppendEntriesArgs) */ {
 public:
  inline AppendEntriesArgs() : AppendEntriesArgs(nullptr) {}
  ~AppendEntriesArgs() override;
  explicit PROTOBUF_CONSTEXPR AppendEntriesArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesArgs(const AppendEntriesArgs& from);
  AppendEntriesArgs(AppendEntriesArgs&& from) noexcept
    : AppendEntriesArgs() {
    *this = ::std::move(from);
  }

  inline AppendEntriesArgs& operator=(const AppendEntriesArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesArgs& operator=(AppendEntriesArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesArgs* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesArgs*>(
               &_AppendEntriesArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AppendEntriesArgs& a, AppendEntriesArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendEntriesArgs& from) {
    AppendEntriesArgs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.AppendEntriesArgs";
  }
  protected:
  explicit AppendEntriesArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kATermFieldNumber = 2,
    kLeaderIdFieldNumber = 3,
    kPrevLogIndexFieldNumber = 4,
    kPrevLogTermFieldNumber = 5,
    kLeaderCommitFieldNumber = 6,
  };
  // repeated .Rpc.LogEntry Entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::Rpc::LogEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::LogEntry >*
      mutable_entries();
  private:
  const ::Rpc::LogEntry& _internal_entries(int index) const;
  ::Rpc::LogEntry* _internal_add_entries();
  public:
  const ::Rpc::LogEntry& entries(int index) const;
  ::Rpc::LogEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::LogEntry >&
      entries() const;

  // int32 ATerm = 2;
  void clear_aterm();
  int32_t aterm() const;
  void set_aterm(int32_t value);
  private:
  int32_t _internal_aterm() const;
  void _internal_set_aterm(int32_t value);
  public:

  // int32 LeaderId = 3;
  void clear_leaderid();
  int32_t leaderid() const;
  void set_leaderid(int32_t value);
  private:
  int32_t _internal_leaderid() const;
  void _internal_set_leaderid(int32_t value);
  public:

  // int32 PrevLogIndex = 4;
  void clear_prevlogindex();
  int32_t prevlogindex() const;
  void set_prevlogindex(int32_t value);
  private:
  int32_t _internal_prevlogindex() const;
  void _internal_set_prevlogindex(int32_t value);
  public:

  // int32 PrevLogTerm = 5;
  void clear_prevlogterm();
  int32_t prevlogterm() const;
  void set_prevlogterm(int32_t value);
  private:
  int32_t _internal_prevlogterm() const;
  void _internal_set_prevlogterm(int32_t value);
  public:

  // int32 LeaderCommit = 6;
  void clear_leadercommit();
  int32_t leadercommit() const;
  void set_leadercommit(int32_t value);
  private:
  int32_t _internal_leadercommit() const;
  void _internal_set_leadercommit(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.AppendEntriesArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::LogEntry > entries_;
    int32_t aterm_;
    int32_t leaderid_;
    int32_t prevlogindex_;
    int32_t prevlogterm_;
    int32_t leadercommit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class AppendEntriesReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.AppendEntriesReply) */ {
 public:
  inline AppendEntriesReply() : AppendEntriesReply(nullptr) {}
  ~AppendEntriesReply() override;
  explicit PROTOBUF_CONSTEXPR AppendEntriesReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AppendEntriesReply(const AppendEntriesReply& from);
  AppendEntriesReply(AppendEntriesReply&& from) noexcept
    : AppendEntriesReply() {
    *this = ::std::move(from);
  }

  inline AppendEntriesReply& operator=(const AppendEntriesReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AppendEntriesReply& operator=(AppendEntriesReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AppendEntriesReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const AppendEntriesReply* internal_default_instance() {
    return reinterpret_cast<const AppendEntriesReply*>(
               &_AppendEntriesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AppendEntriesReply& a, AppendEntriesReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AppendEntriesReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AppendEntriesReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AppendEntriesReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AppendEntriesReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AppendEntriesReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AppendEntriesReply& from) {
    AppendEntriesReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AppendEntriesReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.AppendEntriesReply";
  }
  protected:
  explicit AppendEntriesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kSuccessFieldNumber = 2,
    kUpNextIndexFieldNumber = 3,
    kAppendEntriesStateFieldNumber = 4,
  };
  // int32 Term = 1;
  void clear_term();
  int32_t term() const;
  void set_term(int32_t value);
  private:
  int32_t _internal_term() const;
  void _internal_set_term(int32_t value);
  public:

  // bool Success = 2;
  void clear_success();
  bool success() const;
  void set_success(bool value);
  private:
  bool _internal_success() const;
  void _internal_set_success(bool value);
  public:

  // int32 UpNextIndex = 3;
  void clear_upnextindex();
  int32_t upnextindex() const;
  void set_upnextindex(int32_t value);
  private:
  int32_t _internal_upnextindex() const;
  void _internal_set_upnextindex(int32_t value);
  public:

  // int32 AppendEntriesState = 4;
  void clear_appendentriesstate();
  int32_t appendentriesstate() const;
  void set_appendentriesstate(int32_t value);
  private:
  int32_t _internal_appendentriesstate() const;
  void _internal_set_appendentriesstate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.AppendEntriesReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t term_;
    bool success_;
    int32_t upnextindex_;
    int32_t appendentriesstate_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteArgs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.RequestVoteArgs) */ {
 public:
  inline RequestVoteArgs() : RequestVoteArgs(nullptr) {}
  ~RequestVoteArgs() override;
  explicit PROTOBUF_CONSTEXPR RequestVoteArgs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteArgs(const RequestVoteArgs& from);
  RequestVoteArgs(RequestVoteArgs&& from) noexcept
    : RequestVoteArgs() {
    *this = ::std::move(from);
  }

  inline RequestVoteArgs& operator=(const RequestVoteArgs& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteArgs& operator=(RequestVoteArgs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteArgs& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteArgs* internal_default_instance() {
    return reinterpret_cast<const RequestVoteArgs*>(
               &_RequestVoteArgs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(RequestVoteArgs& a, RequestVoteArgs& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteArgs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteArgs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteArgs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteArgs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteArgs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestVoteArgs& from) {
    RequestVoteArgs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteArgs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.RequestVoteArgs";
  }
  protected:
  explicit RequestVoteArgs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kCandidateIdFieldNumber = 2,
    kLastLogindexFieldNumber = 3,
    kLastLogtermFieldNumber = 4,
  };
  // int32 term = 1;
  void clear_term();
  int32_t term() const;
  void set_term(int32_t value);
  private:
  int32_t _internal_term() const;
  void _internal_set_term(int32_t value);
  public:

  // int32 candidateId = 2;
  void clear_candidateid();
  int32_t candidateid() const;
  void set_candidateid(int32_t value);
  private:
  int32_t _internal_candidateid() const;
  void _internal_set_candidateid(int32_t value);
  public:

  // int32 lastLogindex = 3;
  void clear_lastlogindex();
  int32_t lastlogindex() const;
  void set_lastlogindex(int32_t value);
  private:
  int32_t _internal_lastlogindex() const;
  void _internal_set_lastlogindex(int32_t value);
  public:

  // int32 lastLogterm = 4;
  void clear_lastlogterm();
  int32_t lastlogterm() const;
  void set_lastlogterm(int32_t value);
  private:
  int32_t _internal_lastlogterm() const;
  void _internal_set_lastlogterm(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.RequestVoteArgs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t term_;
    int32_t candidateid_;
    int32_t lastlogindex_;
    int32_t lastlogterm_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class RequestVoteReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.RequestVoteReply) */ {
 public:
  inline RequestVoteReply() : RequestVoteReply(nullptr) {}
  ~RequestVoteReply() override;
  explicit PROTOBUF_CONSTEXPR RequestVoteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RequestVoteReply(const RequestVoteReply& from);
  RequestVoteReply(RequestVoteReply&& from) noexcept
    : RequestVoteReply() {
    *this = ::std::move(from);
  }

  inline RequestVoteReply& operator=(const RequestVoteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RequestVoteReply& operator=(RequestVoteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RequestVoteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RequestVoteReply* internal_default_instance() {
    return reinterpret_cast<const RequestVoteReply*>(
               &_RequestVoteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RequestVoteReply& a, RequestVoteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RequestVoteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RequestVoteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RequestVoteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RequestVoteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RequestVoteReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RequestVoteReply& from) {
    RequestVoteReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RequestVoteReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.RequestVoteReply";
  }
  protected:
  explicit RequestVoteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
    kVotegrantedFieldNumber = 2,
  };
  // int32 term = 1;
  void clear_term();
  int32_t term() const;
  void set_term(int32_t value);
  private:
  int32_t _internal_term() const;
  void _internal_set_term(int32_t value);
  public:

  // bool votegranted = 2;
  void clear_votegranted();
  bool votegranted() const;
  void set_votegranted(bool value);
  private:
  bool _internal_votegranted() const;
  void _internal_set_votegranted(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.RequestVoteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t term_;
    bool votegranted_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class FindAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.FindAddrRequest) */ {
 public:
  inline FindAddrRequest() : FindAddrRequest(nullptr) {}
  ~FindAddrRequest() override;
  explicit PROTOBUF_CONSTEXPR FindAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAddrRequest(const FindAddrRequest& from);
  FindAddrRequest(FindAddrRequest&& from) noexcept
    : FindAddrRequest() {
    *this = ::std::move(from);
  }

  inline FindAddrRequest& operator=(const FindAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAddrRequest& operator=(FindAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAddrRequest* internal_default_instance() {
    return reinterpret_cast<const FindAddrRequest*>(
               &_FindAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(FindAddrRequest& a, FindAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAddrRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindAddrRequest& from) {
    FindAddrRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.FindAddrRequest";
  }
  protected:
  explicit FindAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilepathFieldNumber = 1,
  };
  // string filepath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.FindAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class FindAddrReply_ReplicaAddrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.FindAddrReply.ReplicaAddrs) */ {
 public:
  inline FindAddrReply_ReplicaAddrs() : FindAddrReply_ReplicaAddrs(nullptr) {}
  ~FindAddrReply_ReplicaAddrs() override;
  explicit PROTOBUF_CONSTEXPR FindAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAddrReply_ReplicaAddrs(const FindAddrReply_ReplicaAddrs& from);
  FindAddrReply_ReplicaAddrs(FindAddrReply_ReplicaAddrs&& from) noexcept
    : FindAddrReply_ReplicaAddrs() {
    *this = ::std::move(from);
  }

  inline FindAddrReply_ReplicaAddrs& operator=(const FindAddrReply_ReplicaAddrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAddrReply_ReplicaAddrs& operator=(FindAddrReply_ReplicaAddrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAddrReply_ReplicaAddrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAddrReply_ReplicaAddrs* internal_default_instance() {
    return reinterpret_cast<const FindAddrReply_ReplicaAddrs*>(
               &_FindAddrReply_ReplicaAddrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(FindAddrReply_ReplicaAddrs& a, FindAddrReply_ReplicaAddrs& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAddrReply_ReplicaAddrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAddrReply_ReplicaAddrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAddrReply_ReplicaAddrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindAddrReply_ReplicaAddrs& from) {
    FindAddrReply_ReplicaAddrs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrReply_ReplicaAddrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.FindAddrReply.ReplicaAddrs";
  }
  protected:
  explicit FindAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpPortsFieldNumber = 1,
  };
  // repeated string ip_ports = 1;
  int ip_ports_size() const;
  private:
  int _internal_ip_ports_size() const;
  public:
  void clear_ip_ports();
  const std::string& ip_ports(int index) const;
  std::string* mutable_ip_ports(int index);
  void set_ip_ports(int index, const std::string& value);
  void set_ip_ports(int index, std::string&& value);
  void set_ip_ports(int index, const char* value);
  void set_ip_ports(int index, const char* value, size_t size);
  std::string* add_ip_ports();
  void add_ip_ports(const std::string& value);
  void add_ip_ports(std::string&& value);
  void add_ip_ports(const char* value);
  void add_ip_ports(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_ports();
  private:
  const std::string& _internal_ip_ports(int index) const;
  std::string* _internal_add_ip_ports();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.FindAddrReply.ReplicaAddrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_ports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class FindAddrReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.FindAddrReply) */ {
 public:
  inline FindAddrReply() : FindAddrReply(nullptr) {}
  ~FindAddrReply() override;
  explicit PROTOBUF_CONSTEXPR FindAddrReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAddrReply(const FindAddrReply& from);
  FindAddrReply(FindAddrReply&& from) noexcept
    : FindAddrReply() {
    *this = ::std::move(from);
  }

  inline FindAddrReply& operator=(const FindAddrReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAddrReply& operator=(FindAddrReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAddrReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAddrReply* internal_default_instance() {
    return reinterpret_cast<const FindAddrReply*>(
               &_FindAddrReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(FindAddrReply& a, FindAddrReply& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAddrReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAddrReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAddrReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAddrReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAddrReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FindAddrReply& from) {
    FindAddrReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.FindAddrReply";
  }
  protected:
  explicit FindAddrReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FindAddrReply_ReplicaAddrs ReplicaAddrs;

  // accessors -------------------------------------------------------

  enum : int {
    kChunkHandlesFieldNumber = 1,
    kAddrsFieldNumber = 2,
  };
  // repeated int64 chunk_handles = 1;
  int chunk_handles_size() const;
  private:
  int _internal_chunk_handles_size() const;
  public:
  void clear_chunk_handles();
  private:
  int64_t _internal_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_chunk_handles() const;
  void _internal_add_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_chunk_handles();
  public:
  int64_t chunk_handles(int index) const;
  void set_chunk_handles(int index, int64_t value);
  void add_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_chunk_handles();

  // repeated .Rpc.FindAddrReply.ReplicaAddrs addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  ::Rpc::FindAddrReply_ReplicaAddrs* mutable_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >*
      mutable_addrs();
  private:
  const ::Rpc::FindAddrReply_ReplicaAddrs& _internal_addrs(int index) const;
  ::Rpc::FindAddrReply_ReplicaAddrs* _internal_add_addrs();
  public:
  const ::Rpc::FindAddrReply_ReplicaAddrs& addrs(int index) const;
  ::Rpc::FindAddrReply_ReplicaAddrs* add_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >&
      addrs() const;

  // @@protoc_insertion_point(class_scope:Rpc.FindAddrReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > chunk_handles_;
    mutable std::atomic<int> _chunk_handles_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs > addrs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class GetWriteAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.GetWriteAddrRequest) */ {
 public:
  inline GetWriteAddrRequest() : GetWriteAddrRequest(nullptr) {}
  ~GetWriteAddrRequest() override;
  explicit PROTOBUF_CONSTEXPR GetWriteAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWriteAddrRequest(const GetWriteAddrRequest& from);
  GetWriteAddrRequest(GetWriteAddrRequest&& from) noexcept
    : GetWriteAddrRequest() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrRequest& operator=(const GetWriteAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWriteAddrRequest& operator=(GetWriteAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWriteAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWriteAddrRequest* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrRequest*>(
               &_GetWriteAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetWriteAddrRequest& a, GetWriteAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWriteAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWriteAddrRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWriteAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWriteAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWriteAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWriteAddrRequest& from) {
    GetWriteAddrRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.GetWriteAddrRequest";
  }
  protected:
  explicit GetWriteAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteFilePathFieldNumber = 1,
    kWriteDataSizeFieldNumber = 2,
  };
  // string remote_file_path = 1;
  void clear_remote_file_path();
  const std::string& remote_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_file_path();
  PROTOBUF_NODISCARD std::string* release_remote_file_path();
  void set_allocated_remote_file_path(std::string* remote_file_path);
  private:
  const std::string& _internal_remote_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_file_path(const std::string& value);
  std::string* _internal_mutable_remote_file_path();
  public:

  // int64 write_data_size = 2;
  void clear_write_data_size();
  int64_t write_data_size() const;
  void set_write_data_size(int64_t value);
  private:
  int64_t _internal_write_data_size() const;
  void _internal_set_write_data_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.GetWriteAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_file_path_;
    int64_t write_data_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class GetWriteAddrReply_ReplicaAddrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.GetWriteAddrReply.ReplicaAddrs) */ {
 public:
  inline GetWriteAddrReply_ReplicaAddrs() : GetWriteAddrReply_ReplicaAddrs(nullptr) {}
  ~GetWriteAddrReply_ReplicaAddrs() override;
  explicit PROTOBUF_CONSTEXPR GetWriteAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWriteAddrReply_ReplicaAddrs(const GetWriteAddrReply_ReplicaAddrs& from);
  GetWriteAddrReply_ReplicaAddrs(GetWriteAddrReply_ReplicaAddrs&& from) noexcept
    : GetWriteAddrReply_ReplicaAddrs() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrReply_ReplicaAddrs& operator=(const GetWriteAddrReply_ReplicaAddrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWriteAddrReply_ReplicaAddrs& operator=(GetWriteAddrReply_ReplicaAddrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWriteAddrReply_ReplicaAddrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWriteAddrReply_ReplicaAddrs* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrReply_ReplicaAddrs*>(
               &_GetWriteAddrReply_ReplicaAddrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetWriteAddrReply_ReplicaAddrs& a, GetWriteAddrReply_ReplicaAddrs& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWriteAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWriteAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWriteAddrReply_ReplicaAddrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWriteAddrReply_ReplicaAddrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWriteAddrReply_ReplicaAddrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWriteAddrReply_ReplicaAddrs& from) {
    GetWriteAddrReply_ReplicaAddrs::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrReply_ReplicaAddrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.GetWriteAddrReply.ReplicaAddrs";
  }
  protected:
  explicit GetWriteAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpPortsFieldNumber = 1,
  };
  // repeated string ip_ports = 1;
  int ip_ports_size() const;
  private:
  int _internal_ip_ports_size() const;
  public:
  void clear_ip_ports();
  const std::string& ip_ports(int index) const;
  std::string* mutable_ip_ports(int index);
  void set_ip_ports(int index, const std::string& value);
  void set_ip_ports(int index, std::string&& value);
  void set_ip_ports(int index, const char* value);
  void set_ip_ports(int index, const char* value, size_t size);
  std::string* add_ip_ports();
  void add_ip_ports(const std::string& value);
  void add_ip_ports(std::string&& value);
  void add_ip_ports(const char* value);
  void add_ip_ports(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_ports();
  private:
  const std::string& _internal_ip_ports(int index) const;
  std::string* _internal_add_ip_ports();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.GetWriteAddrReply.ReplicaAddrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_ports_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class GetWriteAddrReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.GetWriteAddrReply) */ {
 public:
  inline GetWriteAddrReply() : GetWriteAddrReply(nullptr) {}
  ~GetWriteAddrReply() override;
  explicit PROTOBUF_CONSTEXPR GetWriteAddrReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWriteAddrReply(const GetWriteAddrReply& from);
  GetWriteAddrReply(GetWriteAddrReply&& from) noexcept
    : GetWriteAddrReply() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrReply& operator=(const GetWriteAddrReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWriteAddrReply& operator=(GetWriteAddrReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWriteAddrReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWriteAddrReply* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrReply*>(
               &_GetWriteAddrReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(GetWriteAddrReply& a, GetWriteAddrReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWriteAddrReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWriteAddrReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWriteAddrReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWriteAddrReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWriteAddrReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetWriteAddrReply& from) {
    GetWriteAddrReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.GetWriteAddrReply";
  }
  protected:
  explicit GetWriteAddrReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetWriteAddrReply_ReplicaAddrs ReplicaAddrs;

  // accessors -------------------------------------------------------

  enum : int {
    kChunkHandlesFieldNumber = 1,
    kAddrsFieldNumber = 2,
  };
  // repeated int64 chunk_handles = 1;
  int chunk_handles_size() const;
  private:
  int _internal_chunk_handles_size() const;
  public:
  void clear_chunk_handles();
  private:
  int64_t _internal_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_chunk_handles() const;
  void _internal_add_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_chunk_handles();
  public:
  int64_t chunk_handles(int index) const;
  void set_chunk_handles(int index, int64_t value);
  void add_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_chunk_handles();

  // repeated .Rpc.GetWriteAddrReply.ReplicaAddrs addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  ::Rpc::GetWriteAddrReply_ReplicaAddrs* mutable_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >*
      mutable_addrs();
  private:
  const ::Rpc::GetWriteAddrReply_ReplicaAddrs& _internal_addrs(int index) const;
  ::Rpc::GetWriteAddrReply_ReplicaAddrs* _internal_add_addrs();
  public:
  const ::Rpc::GetWriteAddrReply_ReplicaAddrs& addrs(int index) const;
  ::Rpc::GetWriteAddrReply_ReplicaAddrs* add_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >&
      addrs() const;

  // @@protoc_insertion_point(class_scope:Rpc.GetWriteAddrReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > chunk_handles_;
    mutable std::atomic<int> _chunk_handles_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs > addrs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class GetSubDirNamesRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.GetSubDirNamesRequest) */ {
 public:
  inline GetSubDirNamesRequest() : GetSubDirNamesRequest(nullptr) {}
  ~GetSubDirNamesRequest() override;
  explicit PROTOBUF_CONSTEXPR GetSubDirNamesRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubDirNamesRequest(const GetSubDirNamesRequest& from);
  GetSubDirNamesRequest(GetSubDirNamesRequest&& from) noexcept
    : GetSubDirNamesRequest() {
    *this = ::std::move(from);
  }

  inline GetSubDirNamesRequest& operator=(const GetSubDirNamesRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubDirNamesRequest& operator=(GetSubDirNamesRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubDirNamesRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubDirNamesRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubDirNamesRequest*>(
               &_GetSubDirNamesRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetSubDirNamesRequest& a, GetSubDirNamesRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubDirNamesRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubDirNamesRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubDirNamesRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubDirNamesRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubDirNamesRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSubDirNamesRequest& from) {
    GetSubDirNamesRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubDirNamesRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.GetSubDirNamesRequest";
  }
  protected:
  explicit GetSubDirNamesRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
  };
  // string file_path = 1;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.GetSubDirNamesRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class GetSubDirNamesReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.GetSubDirNamesReply) */ {
 public:
  inline GetSubDirNamesReply() : GetSubDirNamesReply(nullptr) {}
  ~GetSubDirNamesReply() override;
  explicit PROTOBUF_CONSTEXPR GetSubDirNamesReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubDirNamesReply(const GetSubDirNamesReply& from);
  GetSubDirNamesReply(GetSubDirNamesReply&& from) noexcept
    : GetSubDirNamesReply() {
    *this = ::std::move(from);
  }

  inline GetSubDirNamesReply& operator=(const GetSubDirNamesReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubDirNamesReply& operator=(GetSubDirNamesReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubDirNamesReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubDirNamesReply* internal_default_instance() {
    return reinterpret_cast<const GetSubDirNamesReply*>(
               &_GetSubDirNamesReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(GetSubDirNamesReply& a, GetSubDirNamesReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubDirNamesReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubDirNamesReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubDirNamesReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubDirNamesReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubDirNamesReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetSubDirNamesReply& from) {
    GetSubDirNamesReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubDirNamesReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.GetSubDirNamesReply";
  }
  protected:
  explicit GetSubDirNamesReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubdirFileNamesFieldNumber = 1,
  };
  // repeated string subdir_file_names = 1;
  int subdir_file_names_size() const;
  private:
  int _internal_subdir_file_names_size() const;
  public:
  void clear_subdir_file_names();
  const std::string& subdir_file_names(int index) const;
  std::string* mutable_subdir_file_names(int index);
  void set_subdir_file_names(int index, const std::string& value);
  void set_subdir_file_names(int index, std::string&& value);
  void set_subdir_file_names(int index, const char* value);
  void set_subdir_file_names(int index, const char* value, size_t size);
  std::string* add_subdir_file_names();
  void add_subdir_file_names(const std::string& value);
  void add_subdir_file_names(std::string&& value);
  void add_subdir_file_names(const char* value);
  void add_subdir_file_names(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subdir_file_names() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subdir_file_names();
  private:
  const std::string& _internal_subdir_file_names(int index) const;
  std::string* _internal_add_subdir_file_names();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.GetSubDirNamesReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subdir_file_names_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class MkdirRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.MkdirRequest) */ {
 public:
  inline MkdirRequest() : MkdirRequest(nullptr) {}
  ~MkdirRequest() override;
  explicit PROTOBUF_CONSTEXPR MkdirRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirRequest(const MkdirRequest& from);
  MkdirRequest(MkdirRequest&& from) noexcept
    : MkdirRequest() {
    *this = ::std::move(from);
  }

  inline MkdirRequest& operator=(const MkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirRequest& operator=(MkdirRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirRequest* internal_default_instance() {
    return reinterpret_cast<const MkdirRequest*>(
               &_MkdirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(MkdirRequest& a, MkdirRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MkdirRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MkdirRequest& from) {
    MkdirRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.MkdirRequest";
  }
  protected:
  explicit MkdirRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewFilePathFieldNumber = 1,
  };
  // string new_file_path = 1;
  void clear_new_file_path();
  const std::string& new_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_file_path();
  PROTOBUF_NODISCARD std::string* release_new_file_path();
  void set_allocated_new_file_path(std::string* new_file_path);
  private:
  const std::string& _internal_new_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_file_path(const std::string& value);
  std::string* _internal_mutable_new_file_path();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.MkdirRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_file_path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class MkdirReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.MkdirReply) */ {
 public:
  inline MkdirReply() : MkdirReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR MkdirReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirReply(const MkdirReply& from);
  MkdirReply(MkdirReply&& from) noexcept
    : MkdirReply() {
    *this = ::std::move(from);
  }

  inline MkdirReply& operator=(const MkdirReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirReply& operator=(MkdirReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirReply* internal_default_instance() {
    return reinterpret_cast<const MkdirReply*>(
               &_MkdirReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(MkdirReply& a, MkdirReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MkdirReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MkdirReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.MkdirReply";
  }
  protected:
  explicit MkdirReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.MkdirReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class RenameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.RenameRequest) */ {
 public:
  inline RenameRequest() : RenameRequest(nullptr) {}
  ~RenameRequest() override;
  explicit PROTOBUF_CONSTEXPR RenameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameRequest(const RenameRequest& from);
  RenameRequest(RenameRequest&& from) noexcept
    : RenameRequest() {
    *this = ::std::move(from);
  }

  inline RenameRequest& operator=(const RenameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameRequest& operator=(RenameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameRequest* internal_default_instance() {
    return reinterpret_cast<const RenameRequest*>(
               &_RenameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(RenameRequest& a, RenameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RenameRequest& from) {
    RenameRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.RenameRequest";
  }
  protected:
  explicit RenameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPathFieldNumber = 1,
    kDesPathFieldNumber = 2,
  };
  // string src_path = 1;
  void clear_src_path();
  const std::string& src_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_path();
  PROTOBUF_NODISCARD std::string* release_src_path();
  void set_allocated_src_path(std::string* src_path);
  private:
  const std::string& _internal_src_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_path(const std::string& value);
  std::string* _internal_mutable_src_path();
  public:

  // string des_path = 2;
  void clear_des_path();
  const std::string& des_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_des_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_des_path();
  PROTOBUF_NODISCARD std::string* release_des_path();
  void set_allocated_des_path(std::string* des_path);
  private:
  const std::string& _internal_des_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_des_path(const std::string& value);
  std::string* _internal_mutable_des_path();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.RenameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_path_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr des_path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class RenameReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.RenameReply) */ {
 public:
  inline RenameReply() : RenameReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR RenameReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameReply(const RenameReply& from);
  RenameReply(RenameReply&& from) noexcept
    : RenameReply() {
    *this = ::std::move(from);
  }

  inline RenameReply& operator=(const RenameReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameReply& operator=(RenameReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameReply* internal_default_instance() {
    return reinterpret_cast<const RenameReply*>(
               &_RenameReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(RenameReply& a, RenameReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RenameReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RenameReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.RenameReply";
  }
  protected:
  explicit RenameReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.RenameReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteRequest& from) {
    DeleteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteFilePathFieldNumber = 1,
  };
  // string remote_file_path = 1;
  void clear_remote_file_path();
  const std::string& remote_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_file_path();
  PROTOBUF_NODISCARD std::string* release_remote_file_path();
  void set_allocated_remote_file_path(std::string* remote_file_path);
  private:
  const std::string& _internal_remote_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_file_path(const std::string& value);
  std::string* _internal_mutable_remote_file_path();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_file_path_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class DeleteReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.DeleteReply) */ {
 public:
  inline DeleteReply() : DeleteReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR DeleteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteReply(const DeleteReply& from);
  DeleteReply(DeleteReply&& from) noexcept
    : DeleteReply() {
    *this = ::std::move(from);
  }

  inline DeleteReply& operator=(const DeleteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteReply& operator=(DeleteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteReply* internal_default_instance() {
    return reinterpret_cast<const DeleteReply*>(
               &_DeleteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(DeleteReply& a, DeleteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.DeleteReply";
  }
  protected:
  explicit DeleteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.DeleteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class StatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.StatRequest) */ {
 public:
  inline StatRequest() : StatRequest(nullptr) {}
  ~StatRequest() override;
  explicit PROTOBUF_CONSTEXPR StatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatRequest(const StatRequest& from);
  StatRequest(StatRequest&& from) noexcept
    : StatRequest() {
    *this = ::std::move(from);
  }

  inline StatRequest& operator=(const StatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatRequest& operator=(StatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatRequest* internal_default_instance() {
    return reinterpret_cast<const StatRequest*>(
               &_StatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StatRequest& a, StatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatRequest& from) {
    StatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.StatRequest";
  }
  protected:
  explicit StatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilepathFieldNumber = 1,
  };
  // string filepath = 1;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.StatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class StatReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.StatReply) */ {
 public:
  inline StatReply() : StatReply(nullptr) {}
  ~StatReply() override;
  explicit PROTOBUF_CONSTEXPR StatReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatReply(const StatReply& from);
  StatReply(StatReply&& from) noexcept
    : StatReply() {
    *this = ::std::move(from);
  }

  inline StatReply& operator=(const StatReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatReply& operator=(StatReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatReply* internal_default_instance() {
    return reinterpret_cast<const StatReply*>(
               &_StatReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StatReply& a, StatReply& b) {
    a.Swap(&b);
  }
  inline void Swap(StatReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const StatReply& from) {
    StatReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.StatReply";
  }
  protected:
  explicit StatReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileNameFieldNumber = 2,
    kFileSizeFieldNumber = 3,
    kExistedFieldNumber = 1,
  };
  // string file_name = 2;
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // uint64 file_size = 3;
  void clear_file_size();
  uint64_t file_size() const;
  void set_file_size(uint64_t value);
  private:
  uint64_t _internal_file_size() const;
  void _internal_set_file_size(uint64_t value);
  public:

  // bool existed = 1;
  void clear_existed();
  bool existed() const;
  void set_existed(bool value);
  private:
  bool _internal_existed() const;
  void _internal_set_existed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.StatReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
    uint64_t file_size_;
    bool existed_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class HelloRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.HelloRequest) */ {
 public:
  inline HelloRequest() : HelloRequest(nullptr) {}
  ~HelloRequest() override;
  explicit PROTOBUF_CONSTEXPR HelloRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloRequest(const HelloRequest& from);
  HelloRequest(HelloRequest&& from) noexcept
    : HelloRequest() {
    *this = ::std::move(from);
  }

  inline HelloRequest& operator=(const HelloRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloRequest& operator=(HelloRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloRequest* internal_default_instance() {
    return reinterpret_cast<const HelloRequest*>(
               &_HelloRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(HelloRequest& a, HelloRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloRequest& from) {
    HelloRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.HelloRequest";
  }
  protected:
  explicit HelloRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.HelloRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class HelloReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.HelloReply) */ {
 public:
  inline HelloReply() : HelloReply(nullptr) {}
  ~HelloReply() override;
  explicit PROTOBUF_CONSTEXPR HelloReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HelloReply(const HelloReply& from);
  HelloReply(HelloReply&& from) noexcept
    : HelloReply() {
    *this = ::std::move(from);
  }

  inline HelloReply& operator=(const HelloReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HelloReply& operator=(HelloReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HelloReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HelloReply* internal_default_instance() {
    return reinterpret_cast<const HelloReply*>(
               &_HelloReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(HelloReply& a, HelloReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HelloReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HelloReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HelloReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HelloReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HelloReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HelloReply& from) {
    HelloReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HelloReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.HelloReply";
  }
  protected:
  explicit HelloReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 1,
  };
  // string message = 1;
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.HelloReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class WriteChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.WriteChunkRequest) */ {
 public:
  inline WriteChunkRequest() : WriteChunkRequest(nullptr) {}
  ~WriteChunkRequest() override;
  explicit PROTOBUF_CONSTEXPR WriteChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteChunkRequest(const WriteChunkRequest& from);
  WriteChunkRequest(WriteChunkRequest&& from) noexcept
    : WriteChunkRequest() {
    *this = ::std::move(from);
  }

  inline WriteChunkRequest& operator=(const WriteChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteChunkRequest& operator=(WriteChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteChunkRequest* internal_default_instance() {
    return reinterpret_cast<const WriteChunkRequest*>(
               &_WriteChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(WriteChunkRequest& a, WriteChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteChunkRequest& from) {
    WriteChunkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.WriteChunkRequest";
  }
  protected:
  explicit WriteChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationsFieldNumber = 5,
    kDataFieldNumber = 6,
    kClientIdFieldNumber = 1,
    kChunkhandleFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kLengthFieldNumber = 4,
  };
  // repeated string locations = 5;
  int locations_size() const;
  private:
  int _internal_locations_size() const;
  public:
  void clear_locations();
  const std::string& locations(int index) const;
  std::string* mutable_locations(int index);
  void set_locations(int index, const std::string& value);
  void set_locations(int index, std::string&& value);
  void set_locations(int index, const char* value);
  void set_locations(int index, const char* value, size_t size);
  std::string* add_locations();
  void add_locations(const std::string& value);
  void add_locations(std::string&& value);
  void add_locations(const char* value);
  void add_locations(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& locations() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_locations();
  private:
  const std::string& _internal_locations(int index) const;
  std::string* _internal_add_locations();
  public:

  // bytes data = 6;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 client_id = 1;
  void clear_client_id();
  int64_t client_id() const;
  void set_client_id(int64_t value);
  private:
  int64_t _internal_client_id() const;
  void _internal_set_client_id(int64_t value);
  public:

  // int64 chunkhandle = 2;
  void clear_chunkhandle();
  int64_t chunkhandle() const;
  void set_chunkhandle(int64_t value);
  private:
  int64_t _internal_chunkhandle() const;
  void _internal_set_chunkhandle(int64_t value);
  public:

  // int64 offset = 3;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 length = 4;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.WriteChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> locations_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t client_id_;
    int64_t chunkhandle_;
    int64_t offset_;
    int64_t length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class WriteChunkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.WriteChunkReply) */ {
 public:
  inline WriteChunkReply() : WriteChunkReply(nullptr) {}
  ~WriteChunkReply() override;
  explicit PROTOBUF_CONSTEXPR WriteChunkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteChunkReply(const WriteChunkReply& from);
  WriteChunkReply(WriteChunkReply&& from) noexcept
    : WriteChunkReply() {
    *this = ::std::move(from);
  }

  inline WriteChunkReply& operator=(const WriteChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteChunkReply& operator=(WriteChunkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteChunkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteChunkReply* internal_default_instance() {
    return reinterpret_cast<const WriteChunkReply*>(
               &_WriteChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(WriteChunkReply& a, WriteChunkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteChunkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteChunkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteChunkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteChunkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteChunkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WriteChunkReply& from) {
    WriteChunkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteChunkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.WriteChunkReply";
  }
  protected:
  explicit WriteChunkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesReadFieldNumber = 2,
  };
  // int64 bytes_read = 2;
  void clear_bytes_read();
  int64_t bytes_read() const;
  void set_bytes_read(int64_t value);
  private:
  int64_t _internal_bytes_read() const;
  void _internal_set_bytes_read(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.WriteChunkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t bytes_read_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class ReadChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.ReadChunkRequest) */ {
 public:
  inline ReadChunkRequest() : ReadChunkRequest(nullptr) {}
  ~ReadChunkRequest() override;
  explicit PROTOBUF_CONSTEXPR ReadChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadChunkRequest(const ReadChunkRequest& from);
  ReadChunkRequest(ReadChunkRequest&& from) noexcept
    : ReadChunkRequest() {
    *this = ::std::move(from);
  }

  inline ReadChunkRequest& operator=(const ReadChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadChunkRequest& operator=(ReadChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadChunkRequest* internal_default_instance() {
    return reinterpret_cast<const ReadChunkRequest*>(
               &_ReadChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(ReadChunkRequest& a, ReadChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadChunkRequest& from) {
    ReadChunkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.ReadChunkRequest";
  }
  protected:
  explicit ReadChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkhandleFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // int64 chunkhandle = 1;
  void clear_chunkhandle();
  int64_t chunkhandle() const;
  void set_chunkhandle(int64_t value);
  private:
  int64_t _internal_chunkhandle() const;
  void _internal_set_chunkhandle(int64_t value);
  public:

  // int64 offset = 2;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 length = 3;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.ReadChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t chunkhandle_;
    int64_t offset_;
    int64_t length_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class ReadChunkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.ReadChunkReply) */ {
 public:
  inline ReadChunkReply() : ReadChunkReply(nullptr) {}
  ~ReadChunkReply() override;
  explicit PROTOBUF_CONSTEXPR ReadChunkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadChunkReply(const ReadChunkReply& from);
  ReadChunkReply(ReadChunkReply&& from) noexcept
    : ReadChunkReply() {
    *this = ::std::move(from);
  }

  inline ReadChunkReply& operator=(const ReadChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadChunkReply& operator=(ReadChunkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadChunkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadChunkReply* internal_default_instance() {
    return reinterpret_cast<const ReadChunkReply*>(
               &_ReadChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(ReadChunkReply& a, ReadChunkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadChunkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadChunkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadChunkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadChunkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadChunkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReadChunkReply& from) {
    ReadChunkReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChunkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.ReadChunkReply";
  }
  protected:
  explicit ReadChunkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kBytesReadFieldNumber = 2,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 bytes_read = 2;
  void clear_bytes_read();
  int64_t bytes_read() const;
  void set_bytes_read(int64_t value);
  private:
  int64_t _internal_bytes_read() const;
  void _internal_set_bytes_read(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.ReadChunkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t bytes_read_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class DataNodeLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.DataNodeLocation) */ {
 public:
  inline DataNodeLocation() : DataNodeLocation(nullptr) {}
  ~DataNodeLocation() override;
  explicit PROTOBUF_CONSTEXPR DataNodeLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataNodeLocation(const DataNodeLocation& from);
  DataNodeLocation(DataNodeLocation&& from) noexcept
    : DataNodeLocation() {
    *this = ::std::move(from);
  }

  inline DataNodeLocation& operator=(const DataNodeLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataNodeLocation& operator=(DataNodeLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataNodeLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataNodeLocation* internal_default_instance() {
    return reinterpret_cast<const DataNodeLocation*>(
               &_DataNodeLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(DataNodeLocation& a, DataNodeLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(DataNodeLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataNodeLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataNodeLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataNodeLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataNodeLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataNodeLocation& from) {
    DataNodeLocation::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataNodeLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.DataNodeLocation";
  }
  protected:
  explicit DataNodeLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.DataNodeLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class DataNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.DataNode) */ {
 public:
  inline DataNode() : DataNode(nullptr) {}
  ~DataNode() override;
  explicit PROTOBUF_CONSTEXPR DataNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataNode(const DataNode& from);
  DataNode(DataNode&& from) noexcept
    : DataNode() {
    *this = ::std::move(from);
  }

  inline DataNode& operator=(const DataNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataNode& operator=(DataNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataNode* internal_default_instance() {
    return reinterpret_cast<const DataNode*>(
               &_DataNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(DataNode& a, DataNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DataNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DataNode& from) {
    DataNode::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.DataNode";
  }
  protected:
  explicit DataNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoredChunkHandlesFieldNumber = 3,
    kLocationFieldNumber = 1,
    kAvailableSizeFieldNumber = 2,
  };
  // repeated int64 stored_chunk_handles = 3;
  int stored_chunk_handles_size() const;
  private:
  int _internal_stored_chunk_handles_size() const;
  public:
  void clear_stored_chunk_handles();
  private:
  int64_t _internal_stored_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_stored_chunk_handles() const;
  void _internal_add_stored_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_stored_chunk_handles();
  public:
  int64_t stored_chunk_handles(int index) const;
  void set_stored_chunk_handles(int index, int64_t value);
  void add_stored_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      stored_chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_stored_chunk_handles();

  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // uint32 available_size = 2;
  void clear_available_size();
  uint32_t available_size() const;
  void set_available_size(uint32_t value);
  private:
  uint32_t _internal_available_size() const;
  void _internal_set_available_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.DataNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > stored_chunk_handles_;
    mutable std::atomic<int> _stored_chunk_handles_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    uint32_t available_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class Chunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.Chunk) */ {
 public:
  inline Chunk() : Chunk(nullptr) {}
  ~Chunk() override;
  explicit PROTOBUF_CONSTEXPR Chunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chunk(const Chunk& from);
  Chunk(Chunk&& from) noexcept
    : Chunk() {
    *this = ::std::move(from);
  }

  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chunk& operator=(Chunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chunk* internal_default_instance() {
    return reinterpret_cast<const Chunk*>(
               &_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(Chunk& a, Chunk& b) {
    a.Swap(&b);
  }
  inline void Swap(Chunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Chunk& from) {
    Chunk::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.Chunk";
  }
  protected:
  explicit Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kChunkHandleFieldNumber = 1,
    kSizeFieldNumber = 3,
  };
  // repeated string location = 2;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  const std::string& location(int index) const;
  std::string* mutable_location(int index);
  void set_location(int index, const std::string& value);
  void set_location(int index, std::string&& value);
  void set_location(int index, const char* value);
  void set_location(int index, const char* value, size_t size);
  std::string* add_location();
  void add_location(const std::string& value);
  void add_location(std::string&& value);
  void add_location(const char* value);
  void add_location(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& location() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_location();
  private:
  const std::string& _internal_location(int index) const;
  std::string* _internal_add_location();
  public:

  // int64 chunk_handle = 1;
  void clear_chunk_handle();
  int64_t chunk_handle() const;
  void set_chunk_handle(int64_t value);
  private:
  int64_t _internal_chunk_handle() const;
  void _internal_set_chunk_handle(int64_t value);
  public:

  // int64 size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.Chunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> location_;
    int64_t chunk_handle_;
    int64_t size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class ReportDataNodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.ReportDataNodeRequest) */ {
 public:
  inline ReportDataNodeRequest() : ReportDataNodeRequest(nullptr) {}
  ~ReportDataNodeRequest() override;
  explicit PROTOBUF_CONSTEXPR ReportDataNodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportDataNodeRequest(const ReportDataNodeRequest& from);
  ReportDataNodeRequest(ReportDataNodeRequest&& from) noexcept
    : ReportDataNodeRequest() {
    *this = ::std::move(from);
  }

  inline ReportDataNodeRequest& operator=(const ReportDataNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportDataNodeRequest& operator=(ReportDataNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportDataNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportDataNodeRequest* internal_default_instance() {
    return reinterpret_cast<const ReportDataNodeRequest*>(
               &_ReportDataNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ReportDataNodeRequest& a, ReportDataNodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportDataNodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportDataNodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportDataNodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportDataNodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportDataNodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const ReportDataNodeRequest& from) {
    ReportDataNodeRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportDataNodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.ReportDataNodeRequest";
  }
  protected:
  explicit ReportDataNodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoredChunkHandlesFieldNumber = 3,
    kLocationFieldNumber = 1,
    kAvailableSizeFieldNumber = 2,
  };
  // repeated int64 stored_chunk_handles = 3;
  int stored_chunk_handles_size() const;
  private:
  int _internal_stored_chunk_handles_size() const;
  public:
  void clear_stored_chunk_handles();
  private:
  int64_t _internal_stored_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_stored_chunk_handles() const;
  void _internal_add_stored_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_stored_chunk_handles();
  public:
  int64_t stored_chunk_handles(int index) const;
  void set_stored_chunk_handles(int index, int64_t value);
  void add_stored_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      stored_chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_stored_chunk_handles();

  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // uint32 available_size = 2;
  void clear_available_size();
  uint32_t available_size() const;
  void set_available_size(uint32_t value);
  private:
  uint32_t _internal_available_size() const;
  void _internal_set_available_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.ReportDataNodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > stored_chunk_handles_;
    mutable std::atomic<int> _stored_chunk_handles_cached_byte_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    uint32_t available_size_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class ReportDataNodeReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.ReportDataNodeReply) */ {
 public:
  inline ReportDataNodeReply() : ReportDataNodeReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR ReportDataNodeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportDataNodeReply(const ReportDataNodeReply& from);
  ReportDataNodeReply(ReportDataNodeReply&& from) noexcept
    : ReportDataNodeReply() {
    *this = ::std::move(from);
  }

  inline ReportDataNodeReply& operator=(const ReportDataNodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportDataNodeReply& operator=(ReportDataNodeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportDataNodeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportDataNodeReply* internal_default_instance() {
    return reinterpret_cast<const ReportDataNodeReply*>(
               &_ReportDataNodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(ReportDataNodeReply& a, ReportDataNodeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportDataNodeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportDataNodeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportDataNodeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportDataNodeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportDataNodeReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportDataNodeReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.ReportDataNodeReply";
  }
  protected:
  explicit ReportDataNodeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.ReportDataNodeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  explicit PROTOBUF_CONSTEXPR HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeartbeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeartbeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.HeartbeatReply) */ {
 public:
  inline HeartbeatReply() : HeartbeatReply(nullptr) {}
  ~HeartbeatReply() override;
  explicit PROTOBUF_CONSTEXPR HeartbeatReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatReply(const HeartbeatReply& from);
  HeartbeatReply(HeartbeatReply&& from) noexcept
    : HeartbeatReply() {
    *this = ::std::move(from);
  }

  inline HeartbeatReply& operator=(const HeartbeatReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatReply& operator=(HeartbeatReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatReply* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReply*>(
               &_HeartbeatReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(HeartbeatReply& a, HeartbeatReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const HeartbeatReply& from) {
    HeartbeatReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.HeartbeatReply";
  }
  protected:
  explicit HeartbeatReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .Rpc.HeartbeatRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::Rpc::HeartbeatRequest& request() const;
  PROTOBUF_NODISCARD ::Rpc::HeartbeatRequest* release_request();
  ::Rpc::HeartbeatRequest* mutable_request();
  void set_allocated_request(::Rpc::HeartbeatRequest* request);
  private:
  const ::Rpc::HeartbeatRequest& _internal_request() const;
  ::Rpc::HeartbeatRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::Rpc::HeartbeatRequest* request);
  ::Rpc::HeartbeatRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:Rpc.HeartbeatReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::Rpc::HeartbeatRequest* request_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class CopyChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkRequest) */ {
 public:
  inline CopyChunkRequest() : CopyChunkRequest(nullptr) {}
  ~CopyChunkRequest() override;
  explicit PROTOBUF_CONSTEXPR CopyChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyChunkRequest(const CopyChunkRequest& from);
  CopyChunkRequest(CopyChunkRequest&& from) noexcept
    : CopyChunkRequest() {
    *this = ::std::move(from);
  }

  inline CopyChunkRequest& operator=(const CopyChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyChunkRequest& operator=(CopyChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyChunkRequest* internal_default_instance() {
    return reinterpret_cast<const CopyChunkRequest*>(
               &_CopyChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CopyChunkRequest& a, CopyChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CopyChunkRequest& from) {
    CopyChunkRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.CopyChunkRequest";
  }
  protected:
  explicit CopyChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kChunkHandleFieldNumber = 2,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // int64 chunk_handle = 2;
  void clear_chunk_handle();
  int64_t chunk_handle() const;
  void set_chunk_handle(int64_t value);
  private:
  int64_t _internal_chunk_handle() const;
  void _internal_set_chunk_handle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
    int64_t chunk_handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class CopyChunkReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkReply) */ {
 public:
  inline CopyChunkReply() : CopyChunkReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CopyChunkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyChunkReply(const CopyChunkReply& from);
  CopyChunkReply(CopyChunkReply&& from) noexcept
    : CopyChunkReply() {
    *this = ::std::move(from);
  }

  inline CopyChunkReply& operator=(const CopyChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyChunkReply& operator=(CopyChunkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyChunkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyChunkReply* internal_default_instance() {
    return reinterpret_cast<const CopyChunkReply*>(
               &_CopyChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CopyChunkReply& a, CopyChunkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyChunkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyChunkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyChunkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyChunkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CopyChunkReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CopyChunkReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.CopyChunkReply";
  }
  protected:
  explicit CopyChunkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class MultiWriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.MultiWriteRequest) */ {
 public:
  inline MultiWriteRequest() : MultiWriteRequest(nullptr) {}
  ~MultiWriteRequest() override;
  explicit PROTOBUF_CONSTEXPR MultiWriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiWriteRequest(const MultiWriteRequest& from);
  MultiWriteRequest(MultiWriteRequest&& from) noexcept
    : MultiWriteRequest() {
    *this = ::std::move(from);
  }

  inline MultiWriteRequest& operator=(const MultiWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiWriteRequest& operator=(MultiWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiWriteRequest* internal_default_instance() {
    return reinterpret_cast<const MultiWriteRequest*>(
               &_MultiWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(MultiWriteRequest& a, MultiWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiWriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiWriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiWriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiWriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiWriteRequest& from) {
    MultiWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWriteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.MultiWriteRequest";
  }
  protected:
  explicit MultiWriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 5,
    kClientIdFieldNumber = 1,
    kChunkhandleFieldNumber = 2,
    kOffsetFieldNumber = 3,
    kPaddedChunkFieldNumber = 4,
  };
  // bytes data = 5;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 client_id = 1;
  void clear_client_id();
  int64_t client_id() const;
  void set_client_id(int64_t value);
  private:
  int64_t _internal_client_id() const;
  void _internal_set_client_id(int64_t value);
  public:

  // int64 chunkhandle = 2;
  void clear_chunkhandle();
  int64_t chunkhandle() const;
  void set_chunkhandle(int64_t value);
  private:
  int64_t _internal_chunkhandle() const;
  void _internal_set_chunkhandle(int64_t value);
  public:

  // int64 offset = 3;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // bool padded_chunk = 4;
  void clear_padded_chunk();
  bool padded_chunk() const;
  void set_padded_chunk(bool value);
  private:
  bool _internal_padded_chunk() const;
  void _internal_set_padded_chunk(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.MultiWriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t client_id_;
    int64_t chunkhandle_;
    int64_t offset_;
    bool padded_chunk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class MultiWriteReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.MultiWriteReply) */ {
 public:
  inline MultiWriteReply() : MultiWriteReply(nullptr) {}
  ~MultiWriteReply() override;
  explicit PROTOBUF_CONSTEXPR MultiWriteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MultiWriteReply(const MultiWriteReply& from);
  MultiWriteReply(MultiWriteReply&& from) noexcept
    : MultiWriteReply() {
    *this = ::std::move(from);
  }

  inline MultiWriteReply& operator=(const MultiWriteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MultiWriteReply& operator=(MultiWriteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MultiWriteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MultiWriteReply* internal_default_instance() {
    return reinterpret_cast<const MultiWriteReply*>(
               &_MultiWriteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(MultiWriteReply& a, MultiWriteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MultiWriteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MultiWriteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MultiWriteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MultiWriteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MultiWriteReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MultiWriteReply& from) {
    MultiWriteReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiWriteReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.MultiWriteReply";
  }
  protected:
  explicit MultiWriteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesWrittenFieldNumber = 1,
  };
  // int64 bytes_written = 1;
  void clear_bytes_written();
  int64_t bytes_written() const;
  void set_bytes_written(int64_t value);
  private:
  int64_t _internal_bytes_written() const;
  void _internal_set_bytes_written(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.MultiWriteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int64_t bytes_written_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class CopyChunkWriteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkWriteRequest) */ {
 public:
  inline CopyChunkWriteRequest() : CopyChunkWriteRequest(nullptr) {}
  ~CopyChunkWriteRequest() override;
  explicit PROTOBUF_CONSTEXPR CopyChunkWriteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyChunkWriteRequest(const CopyChunkWriteRequest& from);
  CopyChunkWriteRequest(CopyChunkWriteRequest&& from) noexcept
    : CopyChunkWriteRequest() {
    *this = ::std::move(from);
  }

  inline CopyChunkWriteRequest& operator=(const CopyChunkWriteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyChunkWriteRequest& operator=(CopyChunkWriteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyChunkWriteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyChunkWriteRequest* internal_default_instance() {
    return reinterpret_cast<const CopyChunkWriteRequest*>(
               &_CopyChunkWriteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CopyChunkWriteRequest& a, CopyChunkWriteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyChunkWriteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyChunkWriteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyChunkWriteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyChunkWriteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyChunkWriteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CopyChunkWriteRequest& from) {
    CopyChunkWriteRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyChunkWriteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.CopyChunkWriteRequest";
  }
  protected:
  explicit CopyChunkWriteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kChunkHandleFieldNumber = 2,
  };
  // bytes data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 chunk_handle = 2;
  void clear_chunk_handle();
  int64_t chunk_handle() const;
  void set_chunk_handle(int64_t value);
  private:
  int64_t _internal_chunk_handle() const;
  void _internal_set_chunk_handle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkWriteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
    int64_t chunk_handle_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_final_2eproto;
};
// -------------------------------------------------------------------

class CopyChunkWriteReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkWriteReply) */ {
 public:
  inline CopyChunkWriteReply() : CopyChunkWriteReply(nullptr) {}
  explicit PROTOBUF_CONSTEXPR CopyChunkWriteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyChunkWriteReply(const CopyChunkWriteReply& from);
  CopyChunkWriteReply(CopyChunkWriteReply&& from) noexcept
    : CopyChunkWriteReply() {
    *this = ::std::move(from);
  }

  inline CopyChunkWriteReply& operator=(const CopyChunkWriteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyChunkWriteReply& operator=(CopyChunkWriteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyChunkWriteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyChunkWriteReply* internal_default_instance() {
    return reinterpret_cast<const CopyChunkWriteReply*>(
               &_CopyChunkWriteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CopyChunkWriteReply& a, CopyChunkWriteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyChunkWriteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyChunkWriteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyChunkWriteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyChunkWriteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CopyChunkWriteReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CopyChunkWriteReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.CopyChunkWriteReply";
  }
  protected:
  explicit CopyChunkWriteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkWriteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_final_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// LogEntry

// int32 Term = 1;
inline void LogEntry::clear_term() {
  _impl_.term_ = 0;
}
inline int32_t LogEntry::_internal_term() const {
  return _impl_.term_;
}
inline int32_t LogEntry::term() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.Term)
  return _internal_term();
}
inline void LogEntry::_internal_set_term(int32_t value) {
  
  _impl_.term_ = value;
}
inline void LogEntry::set_term(int32_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.Term)
}

// int32 command = 2;
inline void LogEntry::clear_command() {
  _impl_.command_ = 0;
}
inline int32_t LogEntry::_internal_command() const {
  return _impl_.command_;
}
inline int32_t LogEntry::command() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.command)
  return _internal_command();
}
inline void LogEntry::_internal_set_command(int32_t value) {
  
  _impl_.command_ = value;
}
inline void LogEntry::set_command(int32_t value) {
  _internal_set_command(value);
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.command)
}

// .Rpc.GetWriteAddrRequest getw = 3;
inline bool LogEntry::_internal_has_getw() const {
  return this != internal_default_instance() && _impl_.getw_ != nullptr;
}
inline bool LogEntry::has_getw() const {
  return _internal_has_getw();
}
inline void LogEntry::clear_getw() {
  if (GetArenaForAllocation() == nullptr && _impl_.getw_ != nullptr) {
    delete _impl_.getw_;
  }
  _impl_.getw_ = nullptr;
}
inline const ::Rpc::GetWriteAddrRequest& LogEntry::_internal_getw() const {
  const ::Rpc::GetWriteAddrRequest* p = _impl_.getw_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rpc::GetWriteAddrRequest&>(
      ::Rpc::_GetWriteAddrRequest_default_instance_);
}
inline const ::Rpc::GetWriteAddrRequest& LogEntry::getw() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.getw)
  return _internal_getw();
}
inline void LogEntry::unsafe_arena_set_allocated_getw(
    ::Rpc::GetWriteAddrRequest* getw) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.getw_);
  }
  _impl_.getw_ = getw;
  if (getw) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rpc.LogEntry.getw)
}
inline ::Rpc::GetWriteAddrRequest* LogEntry::release_getw() {
  
  ::Rpc::GetWriteAddrRequest* temp = _impl_.getw_;
  _impl_.getw_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rpc::GetWriteAddrRequest* LogEntry::unsafe_arena_release_getw() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.getw)
  
  ::Rpc::GetWriteAddrRequest* temp = _impl_.getw_;
  _impl_.getw_ = nullptr;
  return temp;
}
inline ::Rpc::GetWriteAddrRequest* LogEntry::_internal_mutable_getw() {
  
  if (_impl_.getw_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rpc::GetWriteAddrRequest>(GetArenaForAllocation());
    _impl_.getw_ = p;
  }
  return _impl_.getw_;
}
inline ::Rpc::GetWriteAddrRequest* LogEntry::mutable_getw() {
  ::Rpc::GetWriteAddrRequest* _msg = _internal_mutable_getw();
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.getw)
  return _msg;
}
inline void LogEntry::set_allocated_getw(::Rpc::GetWriteAddrRequest* getw) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.getw_;
  }
  if (getw) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(getw);
    if (message_arena != submessage_arena) {
      getw = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, getw, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.getw_ = getw;
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.getw)
}

// .Rpc.RenameRequest rename = 4;
inline bool LogEntry::_internal_has_rename() const {
  return this != internal_default_instance() && _impl_.rename_ != nullptr;
}
inline bool LogEntry::has_rename() const {
  return _internal_has_rename();
}
inline void LogEntry::clear_rename() {
  if (GetArenaForAllocation() == nullptr && _impl_.rename_ != nullptr) {
    delete _impl_.rename_;
  }
  _impl_.rename_ = nullptr;
}
inline const ::Rpc::RenameRequest& LogEntry::_internal_rename() const {
  const ::Rpc::RenameRequest* p = _impl_.rename_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rpc::RenameRequest&>(
      ::Rpc::_RenameRequest_default_instance_);
}
inline const ::Rpc::RenameRequest& LogEntry::rename() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.rename)
  return _internal_rename();
}
inline void LogEntry::unsafe_arena_set_allocated_rename(
    ::Rpc::RenameRequest* rename) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.rename_);
  }
  _impl_.rename_ = rename;
  if (rename) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rpc.LogEntry.rename)
}
inline ::Rpc::RenameRequest* LogEntry::release_rename() {
  
  ::Rpc::RenameRequest* temp = _impl_.rename_;
  _impl_.rename_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rpc::RenameRequest* LogEntry::unsafe_arena_release_rename() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.rename)
  
  ::Rpc::RenameRequest* temp = _impl_.rename_;
  _impl_.rename_ = nullptr;
  return temp;
}
inline ::Rpc::RenameRequest* LogEntry::_internal_mutable_rename() {
  
  if (_impl_.rename_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rpc::RenameRequest>(GetArenaForAllocation());
    _impl_.rename_ = p;
  }
  return _impl_.rename_;
}
inline ::Rpc::RenameRequest* LogEntry::mutable_rename() {
  ::Rpc::RenameRequest* _msg = _internal_mutable_rename();
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.rename)
  return _msg;
}
inline void LogEntry::set_allocated_rename(::Rpc::RenameRequest* rename) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.rename_;
  }
  if (rename) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rename);
    if (message_arena != submessage_arena) {
      rename = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rename, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.rename_ = rename;
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.rename)
}

// .Rpc.DeleteRequest del = 5;
inline bool LogEntry::_internal_has_del() const {
  return this != internal_default_instance() && _impl_.del_ != nullptr;
}
inline bool LogEntry::has_del() const {
  return _internal_has_del();
}
inline void LogEntry::clear_del() {
  if (GetArenaForAllocation() == nullptr && _impl_.del_ != nullptr) {
    delete _impl_.del_;
  }
  _impl_.del_ = nullptr;
}
inline const ::Rpc::DeleteRequest& LogEntry::_internal_del() const {
  const ::Rpc::DeleteRequest* p = _impl_.del_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rpc::DeleteRequest&>(
      ::Rpc::_DeleteRequest_default_instance_);
}
inline const ::Rpc::DeleteRequest& LogEntry::del() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.del)
  return _internal_del();
}
inline void LogEntry::unsafe_arena_set_allocated_del(
    ::Rpc::DeleteRequest* del) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.del_);
  }
  _impl_.del_ = del;
  if (del) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rpc.LogEntry.del)
}
inline ::Rpc::DeleteRequest* LogEntry::release_del() {
  
  ::Rpc::DeleteRequest* temp = _impl_.del_;
  _impl_.del_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rpc::DeleteRequest* LogEntry::unsafe_arena_release_del() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.del)
  
  ::Rpc::DeleteRequest* temp = _impl_.del_;
  _impl_.del_ = nullptr;
  return temp;
}
inline ::Rpc::DeleteRequest* LogEntry::_internal_mutable_del() {
  
  if (_impl_.del_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rpc::DeleteRequest>(GetArenaForAllocation());
    _impl_.del_ = p;
  }
  return _impl_.del_;
}
inline ::Rpc::DeleteRequest* LogEntry::mutable_del() {
  ::Rpc::DeleteRequest* _msg = _internal_mutable_del();
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.del)
  return _msg;
}
inline void LogEntry::set_allocated_del(::Rpc::DeleteRequest* del) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.del_;
  }
  if (del) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(del);
    if (message_arena != submessage_arena) {
      del = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, del, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.del_ = del;
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.del)
}

// string filepath = 6;
inline void LogEntry::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& LogEntry::filepath() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.filepath)
}
inline std::string* LogEntry::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.filepath)
  return _s;
}
inline const std::string& LogEntry::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void LogEntry::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_filepath() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.filepath)
  return _impl_.filepath_.Release();
}
inline void LogEntry::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.filepath)
}

// string src = 7;
inline void LogEntry::clear_src() {
  _impl_.src_.ClearToEmpty();
}
inline const std::string& LogEntry::src() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.src)
  return _internal_src();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_src(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.src)
}
inline std::string* LogEntry::mutable_src() {
  std::string* _s = _internal_mutable_src();
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.src)
  return _s;
}
inline const std::string& LogEntry::_internal_src() const {
  return _impl_.src_.Get();
}
inline void LogEntry::_internal_set_src(const std::string& value) {
  
  _impl_.src_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_src() {
  
  return _impl_.src_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_src() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.src)
  return _impl_.src_.Release();
}
inline void LogEntry::set_allocated_src(std::string* src) {
  if (src != nullptr) {
    
  } else {
    
  }
  _impl_.src_.SetAllocated(src, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_.IsDefault()) {
    _impl_.src_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.src)
}

// string des = 8;
inline void LogEntry::clear_des() {
  _impl_.des_.ClearToEmpty();
}
inline const std::string& LogEntry::des() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.des)
  return _internal_des();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LogEntry::set_des(ArgT0&& arg0, ArgT... args) {
 
 _impl_.des_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.des)
}
inline std::string* LogEntry::mutable_des() {
  std::string* _s = _internal_mutable_des();
  // @@protoc_insertion_point(field_mutable:Rpc.LogEntry.des)
  return _s;
}
inline const std::string& LogEntry::_internal_des() const {
  return _impl_.des_.Get();
}
inline void LogEntry::_internal_set_des(const std::string& value) {
  
  _impl_.des_.Set(value, GetArenaForAllocation());
}
inline std::string* LogEntry::_internal_mutable_des() {
  
  return _impl_.des_.Mutable(GetArenaForAllocation());
}
inline std::string* LogEntry::release_des() {
  // @@protoc_insertion_point(field_release:Rpc.LogEntry.des)
  return _impl_.des_.Release();
}
inline void LogEntry::set_allocated_des(std::string* des) {
  if (des != nullptr) {
    
  } else {
    
  }
  _impl_.des_.SetAllocated(des, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.des_.IsDefault()) {
    _impl_.des_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.LogEntry.des)
}

// int64 size = 9;
inline void LogEntry::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t LogEntry::_internal_size() const {
  return _impl_.size_;
}
inline int64_t LogEntry::size() const {
  // @@protoc_insertion_point(field_get:Rpc.LogEntry.size)
  return _internal_size();
}
inline void LogEntry::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void LogEntry::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Rpc.LogEntry.size)
}

// -------------------------------------------------------------------

// AppendEntriesArgs

// repeated .Rpc.LogEntry Entries = 1;
inline int AppendEntriesArgs::_internal_entries_size() const {
  return _impl_.entries_.size();
}
inline int AppendEntriesArgs::entries_size() const {
  return _internal_entries_size();
}
inline void AppendEntriesArgs::clear_entries() {
  _impl_.entries_.Clear();
}
inline ::Rpc::LogEntry* AppendEntriesArgs::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.AppendEntriesArgs.Entries)
  return _impl_.entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::LogEntry >*
AppendEntriesArgs::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.AppendEntriesArgs.Entries)
  return &_impl_.entries_;
}
inline const ::Rpc::LogEntry& AppendEntriesArgs::_internal_entries(int index) const {
  return _impl_.entries_.Get(index);
}
inline const ::Rpc::LogEntry& AppendEntriesArgs::entries(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.Entries)
  return _internal_entries(index);
}
inline ::Rpc::LogEntry* AppendEntriesArgs::_internal_add_entries() {
  return _impl_.entries_.Add();
}
inline ::Rpc::LogEntry* AppendEntriesArgs::add_entries() {
  ::Rpc::LogEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:Rpc.AppendEntriesArgs.Entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::LogEntry >&
AppendEntriesArgs::entries() const {
  // @@protoc_insertion_point(field_list:Rpc.AppendEntriesArgs.Entries)
  return _impl_.entries_;
}

// int32 ATerm = 2;
inline void AppendEntriesArgs::clear_aterm() {
  _impl_.aterm_ = 0;
}
inline int32_t AppendEntriesArgs::_internal_aterm() const {
  return _impl_.aterm_;
}
inline int32_t AppendEntriesArgs::aterm() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.ATerm)
  return _internal_aterm();
}
inline void AppendEntriesArgs::_internal_set_aterm(int32_t value) {
  
  _impl_.aterm_ = value;
}
inline void AppendEntriesArgs::set_aterm(int32_t value) {
  _internal_set_aterm(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.ATerm)
}

// int32 LeaderId = 3;
inline void AppendEntriesArgs::clear_leaderid() {
  _impl_.leaderid_ = 0;
}
inline int32_t AppendEntriesArgs::_internal_leaderid() const {
  return _impl_.leaderid_;
}
inline int32_t AppendEntriesArgs::leaderid() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.LeaderId)
  return _internal_leaderid();
}
inline void AppendEntriesArgs::_internal_set_leaderid(int32_t value) {
  
  _impl_.leaderid_ = value;
}
inline void AppendEntriesArgs::set_leaderid(int32_t value) {
  _internal_set_leaderid(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.LeaderId)
}

// int32 PrevLogIndex = 4;
inline void AppendEntriesArgs::clear_prevlogindex() {
  _impl_.prevlogindex_ = 0;
}
inline int32_t AppendEntriesArgs::_internal_prevlogindex() const {
  return _impl_.prevlogindex_;
}
inline int32_t AppendEntriesArgs::prevlogindex() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.PrevLogIndex)
  return _internal_prevlogindex();
}
inline void AppendEntriesArgs::_internal_set_prevlogindex(int32_t value) {
  
  _impl_.prevlogindex_ = value;
}
inline void AppendEntriesArgs::set_prevlogindex(int32_t value) {
  _internal_set_prevlogindex(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.PrevLogIndex)
}

// int32 PrevLogTerm = 5;
inline void AppendEntriesArgs::clear_prevlogterm() {
  _impl_.prevlogterm_ = 0;
}
inline int32_t AppendEntriesArgs::_internal_prevlogterm() const {
  return _impl_.prevlogterm_;
}
inline int32_t AppendEntriesArgs::prevlogterm() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.PrevLogTerm)
  return _internal_prevlogterm();
}
inline void AppendEntriesArgs::_internal_set_prevlogterm(int32_t value) {
  
  _impl_.prevlogterm_ = value;
}
inline void AppendEntriesArgs::set_prevlogterm(int32_t value) {
  _internal_set_prevlogterm(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.PrevLogTerm)
}

// int32 LeaderCommit = 6;
inline void AppendEntriesArgs::clear_leadercommit() {
  _impl_.leadercommit_ = 0;
}
inline int32_t AppendEntriesArgs::_internal_leadercommit() const {
  return _impl_.leadercommit_;
}
inline int32_t AppendEntriesArgs::leadercommit() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesArgs.LeaderCommit)
  return _internal_leadercommit();
}
inline void AppendEntriesArgs::_internal_set_leadercommit(int32_t value) {
  
  _impl_.leadercommit_ = value;
}
inline void AppendEntriesArgs::set_leadercommit(int32_t value) {
  _internal_set_leadercommit(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesArgs.LeaderCommit)
}

// -------------------------------------------------------------------

// AppendEntriesReply

// int32 Term = 1;
inline void AppendEntriesReply::clear_term() {
  _impl_.term_ = 0;
}
inline int32_t AppendEntriesReply::_internal_term() const {
  return _impl_.term_;
}
inline int32_t AppendEntriesReply::term() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.Term)
  return _internal_term();
}
inline void AppendEntriesReply::_internal_set_term(int32_t value) {
  
  _impl_.term_ = value;
}
inline void AppendEntriesReply::set_term(int32_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.Term)
}

// bool Success = 2;
inline void AppendEntriesReply::clear_success() {
  _impl_.success_ = false;
}
inline bool AppendEntriesReply::_internal_success() const {
  return _impl_.success_;
}
inline bool AppendEntriesReply::success() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.Success)
  return _internal_success();
}
inline void AppendEntriesReply::_internal_set_success(bool value) {
  
  _impl_.success_ = value;
}
inline void AppendEntriesReply::set_success(bool value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.Success)
}

// int32 UpNextIndex = 3;
inline void AppendEntriesReply::clear_upnextindex() {
  _impl_.upnextindex_ = 0;
}
inline int32_t AppendEntriesReply::_internal_upnextindex() const {
  return _impl_.upnextindex_;
}
inline int32_t AppendEntriesReply::upnextindex() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.UpNextIndex)
  return _internal_upnextindex();
}
inline void AppendEntriesReply::_internal_set_upnextindex(int32_t value) {
  
  _impl_.upnextindex_ = value;
}
inline void AppendEntriesReply::set_upnextindex(int32_t value) {
  _internal_set_upnextindex(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.UpNextIndex)
}

// int32 AppendEntriesState = 4;
inline void AppendEntriesReply::clear_appendentriesstate() {
  _impl_.appendentriesstate_ = 0;
}
inline int32_t AppendEntriesReply::_internal_appendentriesstate() const {
  return _impl_.appendentriesstate_;
}
inline int32_t AppendEntriesReply::appendentriesstate() const {
  // @@protoc_insertion_point(field_get:Rpc.AppendEntriesReply.AppendEntriesState)
  return _internal_appendentriesstate();
}
inline void AppendEntriesReply::_internal_set_appendentriesstate(int32_t value) {
  
  _impl_.appendentriesstate_ = value;
}
inline void AppendEntriesReply::set_appendentriesstate(int32_t value) {
  _internal_set_appendentriesstate(value);
  // @@protoc_insertion_point(field_set:Rpc.AppendEntriesReply.AppendEntriesState)
}

// -------------------------------------------------------------------

// RequestVoteArgs

// int32 term = 1;
inline void RequestVoteArgs::clear_term() {
  _impl_.term_ = 0;
}
inline int32_t RequestVoteArgs::_internal_term() const {
  return _impl_.term_;
}
inline int32_t RequestVoteArgs::term() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.term)
  return _internal_term();
}
inline void RequestVoteArgs::_internal_set_term(int32_t value) {
  
  _impl_.term_ = value;
}
inline void RequestVoteArgs::set_term(int32_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.term)
}

// int32 candidateId = 2;
inline void RequestVoteArgs::clear_candidateid() {
  _impl_.candidateid_ = 0;
}
inline int32_t RequestVoteArgs::_internal_candidateid() const {
  return _impl_.candidateid_;
}
inline int32_t RequestVoteArgs::candidateid() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.candidateId)
  return _internal_candidateid();
}
inline void RequestVoteArgs::_internal_set_candidateid(int32_t value) {
  
  _impl_.candidateid_ = value;
}
inline void RequestVoteArgs::set_candidateid(int32_t value) {
  _internal_set_candidateid(value);
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.candidateId)
}

// int32 lastLogindex = 3;
inline void RequestVoteArgs::clear_lastlogindex() {
  _impl_.lastlogindex_ = 0;
}
inline int32_t RequestVoteArgs::_internal_lastlogindex() const {
  return _impl_.lastlogindex_;
}
inline int32_t RequestVoteArgs::lastlogindex() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.lastLogindex)
  return _internal_lastlogindex();
}
inline void RequestVoteArgs::_internal_set_lastlogindex(int32_t value) {
  
  _impl_.lastlogindex_ = value;
}
inline void RequestVoteArgs::set_lastlogindex(int32_t value) {
  _internal_set_lastlogindex(value);
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.lastLogindex)
}

// int32 lastLogterm = 4;
inline void RequestVoteArgs::clear_lastlogterm() {
  _impl_.lastlogterm_ = 0;
}
inline int32_t RequestVoteArgs::_internal_lastlogterm() const {
  return _impl_.lastlogterm_;
}
inline int32_t RequestVoteArgs::lastlogterm() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteArgs.lastLogterm)
  return _internal_lastlogterm();
}
inline void RequestVoteArgs::_internal_set_lastlogterm(int32_t value) {
  
  _impl_.lastlogterm_ = value;
}
inline void RequestVoteArgs::set_lastlogterm(int32_t value) {
  _internal_set_lastlogterm(value);
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteArgs.lastLogterm)
}

// -------------------------------------------------------------------

// RequestVoteReply

// int32 term = 1;
inline void RequestVoteReply::clear_term() {
  _impl_.term_ = 0;
}
inline int32_t RequestVoteReply::_internal_term() const {
  return _impl_.term_;
}
inline int32_t RequestVoteReply::term() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteReply.term)
  return _internal_term();
}
inline void RequestVoteReply::_internal_set_term(int32_t value) {
  
  _impl_.term_ = value;
}
inline void RequestVoteReply::set_term(int32_t value) {
  _internal_set_term(value);
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteReply.term)
}

// bool votegranted = 2;
inline void RequestVoteReply::clear_votegranted() {
  _impl_.votegranted_ = false;
}
inline bool RequestVoteReply::_internal_votegranted() const {
  return _impl_.votegranted_;
}
inline bool RequestVoteReply::votegranted() const {
  // @@protoc_insertion_point(field_get:Rpc.RequestVoteReply.votegranted)
  return _internal_votegranted();
}
inline void RequestVoteReply::_internal_set_votegranted(bool value) {
  
  _impl_.votegranted_ = value;
}
inline void RequestVoteReply::set_votegranted(bool value) {
  _internal_set_votegranted(value);
  // @@protoc_insertion_point(field_set:Rpc.RequestVoteReply.votegranted)
}

// -------------------------------------------------------------------

// FindAddrRequest

// string filepath = 1;
inline void FindAddrRequest::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& FindAddrRequest::filepath() const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrRequest.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindAddrRequest::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.FindAddrRequest.filepath)
}
inline std::string* FindAddrRequest::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:Rpc.FindAddrRequest.filepath)
  return _s;
}
inline const std::string& FindAddrRequest::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void FindAddrRequest::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* FindAddrRequest::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* FindAddrRequest::release_filepath() {
  // @@protoc_insertion_point(field_release:Rpc.FindAddrRequest.filepath)
  return _impl_.filepath_.Release();
}
inline void FindAddrRequest::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.FindAddrRequest.filepath)
}

// -------------------------------------------------------------------

// FindAddrReply_ReplicaAddrs

// repeated string ip_ports = 1;
inline int FindAddrReply_ReplicaAddrs::_internal_ip_ports_size() const {
  return _impl_.ip_ports_.size();
}
inline int FindAddrReply_ReplicaAddrs::ip_ports_size() const {
  return _internal_ip_ports_size();
}
inline void FindAddrReply_ReplicaAddrs::clear_ip_ports() {
  _impl_.ip_ports_.Clear();
}
inline std::string* FindAddrReply_ReplicaAddrs::add_ip_ports() {
  std::string* _s = _internal_add_ip_ports();
  // @@protoc_insertion_point(field_add_mutable:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return _s;
}
inline const std::string& FindAddrReply_ReplicaAddrs::_internal_ip_ports(int index) const {
  return _impl_.ip_ports_.Get(index);
}
inline const std::string& FindAddrReply_ReplicaAddrs::ip_ports(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return _internal_ip_ports(index);
}
inline std::string* FindAddrReply_ReplicaAddrs::mutable_ip_ports(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return _impl_.ip_ports_.Mutable(index);
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const std::string& value) {
  _impl_.ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, std::string&& value) {
  _impl_.ip_ports_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value, size_t size) {
  _impl_.ip_ports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline std::string* FindAddrReply_ReplicaAddrs::_internal_add_ip_ports() {
  return _impl_.ip_ports_.Add();
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const std::string& value) {
  _impl_.ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(std::string&& value) {
  _impl_.ip_ports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const char* value, size_t size) {
  _impl_.ip_ports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FindAddrReply_ReplicaAddrs::ip_ports() const {
  // @@protoc_insertion_point(field_list:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return _impl_.ip_ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FindAddrReply_ReplicaAddrs::mutable_ip_ports() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.FindAddrReply.ReplicaAddrs.ip_ports)
  return &_impl_.ip_ports_;
}

// -------------------------------------------------------------------

// FindAddrReply

// repeated int64 chunk_handles = 1;
inline int FindAddrReply::_internal_chunk_handles_size() const {
  return _impl_.chunk_handles_.size();
}
inline int FindAddrReply::chunk_handles_size() const {
  return _internal_chunk_handles_size();
}
inline void FindAddrReply::clear_chunk_handles() {
  _impl_.chunk_handles_.Clear();
}
inline int64_t FindAddrReply::_internal_chunk_handles(int index) const {
  return _impl_.chunk_handles_.Get(index);
}
inline int64_t FindAddrReply::chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrReply.chunk_handles)
  return _internal_chunk_handles(index);
}
inline void FindAddrReply::set_chunk_handles(int index, int64_t value) {
  _impl_.chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.FindAddrReply.chunk_handles)
}
inline void FindAddrReply::_internal_add_chunk_handles(int64_t value) {
  _impl_.chunk_handles_.Add(value);
}
inline void FindAddrReply::add_chunk_handles(int64_t value) {
  _internal_add_chunk_handles(value);
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
FindAddrReply::_internal_chunk_handles() const {
  return _impl_.chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
FindAddrReply::chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.FindAddrReply.chunk_handles)
  return _internal_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
FindAddrReply::_internal_mutable_chunk_handles() {
  return &_impl_.chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
FindAddrReply::mutable_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.FindAddrReply.chunk_handles)
  return _internal_mutable_chunk_handles();
}

// repeated .Rpc.FindAddrReply.ReplicaAddrs addrs = 2;
inline int FindAddrReply::_internal_addrs_size() const {
  return _impl_.addrs_.size();
}
inline int FindAddrReply::addrs_size() const {
  return _internal_addrs_size();
}
inline void FindAddrReply::clear_addrs() {
  _impl_.addrs_.Clear();
}
inline ::Rpc::FindAddrReply_ReplicaAddrs* FindAddrReply::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.FindAddrReply.addrs)
  return _impl_.addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >*
FindAddrReply::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.FindAddrReply.addrs)
  return &_impl_.addrs_;
}
inline const ::Rpc::FindAddrReply_ReplicaAddrs& FindAddrReply::_internal_addrs(int index) const {
  return _impl_.addrs_.Get(index);
}
inline const ::Rpc::FindAddrReply_ReplicaAddrs& FindAddrReply::addrs(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.FindAddrReply.addrs)
  return _internal_addrs(index);
}
inline ::Rpc::FindAddrReply_ReplicaAddrs* FindAddrReply::_internal_add_addrs() {
  return _impl_.addrs_.Add();
}
inline ::Rpc::FindAddrReply_ReplicaAddrs* FindAddrReply::add_addrs() {
  ::Rpc::FindAddrReply_ReplicaAddrs* _add = _internal_add_addrs();
  // @@protoc_insertion_point(field_add:Rpc.FindAddrReply.addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::FindAddrReply_ReplicaAddrs >&
FindAddrReply::addrs() const {
  // @@protoc_insertion_point(field_list:Rpc.FindAddrReply.addrs)
  return _impl_.addrs_;
}

// -------------------------------------------------------------------

// GetWriteAddrRequest

// string remote_file_path = 1;
inline void GetWriteAddrRequest::clear_remote_file_path() {
  _impl_.remote_file_path_.ClearToEmpty();
}
inline const std::string& GetWriteAddrRequest::remote_file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrRequest.remote_file_path)
  return _internal_remote_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWriteAddrRequest::set_remote_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrRequest.remote_file_path)
}
inline std::string* GetWriteAddrRequest::mutable_remote_file_path() {
  std::string* _s = _internal_mutable_remote_file_path();
  // @@protoc_insertion_point(field_mutable:Rpc.GetWriteAddrRequest.remote_file_path)
  return _s;
}
inline const std::string& GetWriteAddrRequest::_internal_remote_file_path() const {
  return _impl_.remote_file_path_.Get();
}
inline void GetWriteAddrRequest::_internal_set_remote_file_path(const std::string& value) {
  
  _impl_.remote_file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetWriteAddrRequest::_internal_mutable_remote_file_path() {
  
  return _impl_.remote_file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetWriteAddrRequest::release_remote_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.GetWriteAddrRequest.remote_file_path)
  return _impl_.remote_file_path_.Release();
}
inline void GetWriteAddrRequest::set_allocated_remote_file_path(std::string* remote_file_path) {
  if (remote_file_path != nullptr) {
    
  } else {
    
  }
  _impl_.remote_file_path_.SetAllocated(remote_file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_file_path_.IsDefault()) {
    _impl_.remote_file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.GetWriteAddrRequest.remote_file_path)
}

// int64 write_data_size = 2;
inline void GetWriteAddrRequest::clear_write_data_size() {
  _impl_.write_data_size_ = int64_t{0};
}
inline int64_t GetWriteAddrRequest::_internal_write_data_size() const {
  return _impl_.write_data_size_;
}
inline int64_t GetWriteAddrRequest::write_data_size() const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrRequest.write_data_size)
  return _internal_write_data_size();
}
inline void GetWriteAddrRequest::_internal_set_write_data_size(int64_t value) {
  
  _impl_.write_data_size_ = value;
}
inline void GetWriteAddrRequest::set_write_data_size(int64_t value) {
  _internal_set_write_data_size(value);
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrRequest.write_data_size)
}

// -------------------------------------------------------------------

// GetWriteAddrReply_ReplicaAddrs

// repeated string ip_ports = 1;
inline int GetWriteAddrReply_ReplicaAddrs::_internal_ip_ports_size() const {
  return _impl_.ip_ports_.size();
}
inline int GetWriteAddrReply_ReplicaAddrs::ip_ports_size() const {
  return _internal_ip_ports_size();
}
inline void GetWriteAddrReply_ReplicaAddrs::clear_ip_ports() {
  _impl_.ip_ports_.Clear();
}
inline std::string* GetWriteAddrReply_ReplicaAddrs::add_ip_ports() {
  std::string* _s = _internal_add_ip_ports();
  // @@protoc_insertion_point(field_add_mutable:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return _s;
}
inline const std::string& GetWriteAddrReply_ReplicaAddrs::_internal_ip_ports(int index) const {
  return _impl_.ip_ports_.Get(index);
}
inline const std::string& GetWriteAddrReply_ReplicaAddrs::ip_ports(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return _internal_ip_ports(index);
}
inline std::string* GetWriteAddrReply_ReplicaAddrs::mutable_ip_ports(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return _impl_.ip_ports_.Mutable(index);
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const std::string& value) {
  _impl_.ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, std::string&& value) {
  _impl_.ip_ports_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value, size_t size) {
  _impl_.ip_ports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline std::string* GetWriteAddrReply_ReplicaAddrs::_internal_add_ip_ports() {
  return _impl_.ip_ports_.Add();
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const std::string& value) {
  _impl_.ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(std::string&& value) {
  _impl_.ip_ports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const char* value, size_t size) {
  _impl_.ip_ports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetWriteAddrReply_ReplicaAddrs::ip_ports() const {
  // @@protoc_insertion_point(field_list:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return _impl_.ip_ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetWriteAddrReply_ReplicaAddrs::mutable_ip_ports() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return &_impl_.ip_ports_;
}

// -------------------------------------------------------------------

// GetWriteAddrReply

// repeated int64 chunk_handles = 1;
inline int GetWriteAddrReply::_internal_chunk_handles_size() const {
  return _impl_.chunk_handles_.size();
}
inline int GetWriteAddrReply::chunk_handles_size() const {
  return _internal_chunk_handles_size();
}
inline void GetWriteAddrReply::clear_chunk_handles() {
  _impl_.chunk_handles_.Clear();
}
inline int64_t GetWriteAddrReply::_internal_chunk_handles(int index) const {
  return _impl_.chunk_handles_.Get(index);
}
inline int64_t GetWriteAddrReply::chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrReply.chunk_handles)
  return _internal_chunk_handles(index);
}
inline void GetWriteAddrReply::set_chunk_handles(int index, int64_t value) {
  _impl_.chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.GetWriteAddrReply.chunk_handles)
}
inline void GetWriteAddrReply::_internal_add_chunk_handles(int64_t value) {
  _impl_.chunk_handles_.Add(value);
}
inline void GetWriteAddrReply::add_chunk_handles(int64_t value) {
  _internal_add_chunk_handles(value);
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
GetWriteAddrReply::_internal_chunk_handles() const {
  return _impl_.chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
GetWriteAddrReply::chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.GetWriteAddrReply.chunk_handles)
  return _internal_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
GetWriteAddrReply::_internal_mutable_chunk_handles() {
  return &_impl_.chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
GetWriteAddrReply::mutable_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetWriteAddrReply.chunk_handles)
  return _internal_mutable_chunk_handles();
}

// repeated .Rpc.GetWriteAddrReply.ReplicaAddrs addrs = 2;
inline int GetWriteAddrReply::_internal_addrs_size() const {
  return _impl_.addrs_.size();
}
inline int GetWriteAddrReply::addrs_size() const {
  return _internal_addrs_size();
}
inline void GetWriteAddrReply::clear_addrs() {
  _impl_.addrs_.Clear();
}
inline ::Rpc::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.GetWriteAddrReply.addrs)
  return _impl_.addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >*
GetWriteAddrReply::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetWriteAddrReply.addrs)
  return &_impl_.addrs_;
}
inline const ::Rpc::GetWriteAddrReply_ReplicaAddrs& GetWriteAddrReply::_internal_addrs(int index) const {
  return _impl_.addrs_.Get(index);
}
inline const ::Rpc::GetWriteAddrReply_ReplicaAddrs& GetWriteAddrReply::addrs(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetWriteAddrReply.addrs)
  return _internal_addrs(index);
}
inline ::Rpc::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::_internal_add_addrs() {
  return _impl_.addrs_.Add();
}
inline ::Rpc::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::add_addrs() {
  ::Rpc::GetWriteAddrReply_ReplicaAddrs* _add = _internal_add_addrs();
  // @@protoc_insertion_point(field_add:Rpc.GetWriteAddrReply.addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Rpc::GetWriteAddrReply_ReplicaAddrs >&
GetWriteAddrReply::addrs() const {
  // @@protoc_insertion_point(field_list:Rpc.GetWriteAddrReply.addrs)
  return _impl_.addrs_;
}

// -------------------------------------------------------------------

// GetSubDirNamesRequest

// string file_path = 1;
inline void GetSubDirNamesRequest::clear_file_path() {
  _impl_.file_path_.ClearToEmpty();
}
inline const std::string& GetSubDirNamesRequest::file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.GetSubDirNamesRequest.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSubDirNamesRequest::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.GetSubDirNamesRequest.file_path)
}
inline std::string* GetSubDirNamesRequest::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:Rpc.GetSubDirNamesRequest.file_path)
  return _s;
}
inline const std::string& GetSubDirNamesRequest::_internal_file_path() const {
  return _impl_.file_path_.Get();
}
inline void GetSubDirNamesRequest::_internal_set_file_path(const std::string& value) {
  
  _impl_.file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* GetSubDirNamesRequest::_internal_mutable_file_path() {
  
  return _impl_.file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* GetSubDirNamesRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.GetSubDirNamesRequest.file_path)
  return _impl_.file_path_.Release();
}
inline void GetSubDirNamesRequest::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  _impl_.file_path_.SetAllocated(file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_path_.IsDefault()) {
    _impl_.file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.GetSubDirNamesRequest.file_path)
}

// -------------------------------------------------------------------

// GetSubDirNamesReply

// repeated string subdir_file_names = 1;
inline int GetSubDirNamesReply::_internal_subdir_file_names_size() const {
  return _impl_.subdir_file_names_.size();
}
inline int GetSubDirNamesReply::subdir_file_names_size() const {
  return _internal_subdir_file_names_size();
}
inline void GetSubDirNamesReply::clear_subdir_file_names() {
  _impl_.subdir_file_names_.Clear();
}
inline std::string* GetSubDirNamesReply::add_subdir_file_names() {
  std::string* _s = _internal_add_subdir_file_names();
  // @@protoc_insertion_point(field_add_mutable:Rpc.GetSubDirNamesReply.subdir_file_names)
  return _s;
}
inline const std::string& GetSubDirNamesReply::_internal_subdir_file_names(int index) const {
  return _impl_.subdir_file_names_.Get(index);
}
inline const std::string& GetSubDirNamesReply::subdir_file_names(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.GetSubDirNamesReply.subdir_file_names)
  return _internal_subdir_file_names(index);
}
inline std::string* GetSubDirNamesReply::mutable_subdir_file_names(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.GetSubDirNamesReply.subdir_file_names)
  return _impl_.subdir_file_names_.Mutable(index);
}
inline void GetSubDirNamesReply::set_subdir_file_names(int index, const std::string& value) {
  _impl_.subdir_file_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::set_subdir_file_names(int index, std::string&& value) {
  _impl_.subdir_file_names_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::set_subdir_file_names(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.subdir_file_names_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::set_subdir_file_names(int index, const char* value, size_t size) {
  _impl_.subdir_file_names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline std::string* GetSubDirNamesReply::_internal_add_subdir_file_names() {
  return _impl_.subdir_file_names_.Add();
}
inline void GetSubDirNamesReply::add_subdir_file_names(const std::string& value) {
  _impl_.subdir_file_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::add_subdir_file_names(std::string&& value) {
  _impl_.subdir_file_names_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::add_subdir_file_names(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.subdir_file_names_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline void GetSubDirNamesReply::add_subdir_file_names(const char* value, size_t size) {
  _impl_.subdir_file_names_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.GetSubDirNamesReply.subdir_file_names)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetSubDirNamesReply::subdir_file_names() const {
  // @@protoc_insertion_point(field_list:Rpc.GetSubDirNamesReply.subdir_file_names)
  return _impl_.subdir_file_names_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetSubDirNamesReply::mutable_subdir_file_names() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.GetSubDirNamesReply.subdir_file_names)
  return &_impl_.subdir_file_names_;
}

// -------------------------------------------------------------------

// MkdirRequest

// string new_file_path = 1;
inline void MkdirRequest::clear_new_file_path() {
  _impl_.new_file_path_.ClearToEmpty();
}
inline const std::string& MkdirRequest::new_file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.MkdirRequest.new_file_path)
  return _internal_new_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MkdirRequest::set_new_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.new_file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.MkdirRequest.new_file_path)
}
inline std::string* MkdirRequest::mutable_new_file_path() {
  std::string* _s = _internal_mutable_new_file_path();
  // @@protoc_insertion_point(field_mutable:Rpc.MkdirRequest.new_file_path)
  return _s;
}
inline const std::string& MkdirRequest::_internal_new_file_path() const {
  return _impl_.new_file_path_.Get();
}
inline void MkdirRequest::_internal_set_new_file_path(const std::string& value) {
  
  _impl_.new_file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* MkdirRequest::_internal_mutable_new_file_path() {
  
  return _impl_.new_file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* MkdirRequest::release_new_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.MkdirRequest.new_file_path)
  return _impl_.new_file_path_.Release();
}
inline void MkdirRequest::set_allocated_new_file_path(std::string* new_file_path) {
  if (new_file_path != nullptr) {
    
  } else {
    
  }
  _impl_.new_file_path_.SetAllocated(new_file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.new_file_path_.IsDefault()) {
    _impl_.new_file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.MkdirRequest.new_file_path)
}

// -------------------------------------------------------------------

// MkdirReply

// -------------------------------------------------------------------

// RenameRequest

// string src_path = 1;
inline void RenameRequest::clear_src_path() {
  _impl_.src_path_.ClearToEmpty();
}
inline const std::string& RenameRequest::src_path() const {
  // @@protoc_insertion_point(field_get:Rpc.RenameRequest.src_path)
  return _internal_src_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_src_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.src_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.RenameRequest.src_path)
}
inline std::string* RenameRequest::mutable_src_path() {
  std::string* _s = _internal_mutable_src_path();
  // @@protoc_insertion_point(field_mutable:Rpc.RenameRequest.src_path)
  return _s;
}
inline const std::string& RenameRequest::_internal_src_path() const {
  return _impl_.src_path_.Get();
}
inline void RenameRequest::_internal_set_src_path(const std::string& value) {
  
  _impl_.src_path_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_src_path() {
  
  return _impl_.src_path_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRequest::release_src_path() {
  // @@protoc_insertion_point(field_release:Rpc.RenameRequest.src_path)
  return _impl_.src_path_.Release();
}
inline void RenameRequest::set_allocated_src_path(std::string* src_path) {
  if (src_path != nullptr) {
    
  } else {
    
  }
  _impl_.src_path_.SetAllocated(src_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.src_path_.IsDefault()) {
    _impl_.src_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.RenameRequest.src_path)
}

// string des_path = 2;
inline void RenameRequest::clear_des_path() {
  _impl_.des_path_.ClearToEmpty();
}
inline const std::string& RenameRequest::des_path() const {
  // @@protoc_insertion_point(field_get:Rpc.RenameRequest.des_path)
  return _internal_des_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_des_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.des_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.RenameRequest.des_path)
}
inline std::string* RenameRequest::mutable_des_path() {
  std::string* _s = _internal_mutable_des_path();
  // @@protoc_insertion_point(field_mutable:Rpc.RenameRequest.des_path)
  return _s;
}
inline const std::string& RenameRequest::_internal_des_path() const {
  return _impl_.des_path_.Get();
}
inline void RenameRequest::_internal_set_des_path(const std::string& value) {
  
  _impl_.des_path_.Set(value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_des_path() {
  
  return _impl_.des_path_.Mutable(GetArenaForAllocation());
}
inline std::string* RenameRequest::release_des_path() {
  // @@protoc_insertion_point(field_release:Rpc.RenameRequest.des_path)
  return _impl_.des_path_.Release();
}
inline void RenameRequest::set_allocated_des_path(std::string* des_path) {
  if (des_path != nullptr) {
    
  } else {
    
  }
  _impl_.des_path_.SetAllocated(des_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.des_path_.IsDefault()) {
    _impl_.des_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.RenameRequest.des_path)
}

// -------------------------------------------------------------------

// RenameReply

// -------------------------------------------------------------------

// DeleteRequest

// string remote_file_path = 1;
inline void DeleteRequest::clear_remote_file_path() {
  _impl_.remote_file_path_.ClearToEmpty();
}
inline const std::string& DeleteRequest::remote_file_path() const {
  // @@protoc_insertion_point(field_get:Rpc.DeleteRequest.remote_file_path)
  return _internal_remote_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_remote_file_path(ArgT0&& arg0, ArgT... args) {
 
 _impl_.remote_file_path_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.DeleteRequest.remote_file_path)
}
inline std::string* DeleteRequest::mutable_remote_file_path() {
  std::string* _s = _internal_mutable_remote_file_path();
  // @@protoc_insertion_point(field_mutable:Rpc.DeleteRequest.remote_file_path)
  return _s;
}
inline const std::string& DeleteRequest::_internal_remote_file_path() const {
  return _impl_.remote_file_path_.Get();
}
inline void DeleteRequest::_internal_set_remote_file_path(const std::string& value) {
  
  _impl_.remote_file_path_.Set(value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_remote_file_path() {
  
  return _impl_.remote_file_path_.Mutable(GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_remote_file_path() {
  // @@protoc_insertion_point(field_release:Rpc.DeleteRequest.remote_file_path)
  return _impl_.remote_file_path_.Release();
}
inline void DeleteRequest::set_allocated_remote_file_path(std::string* remote_file_path) {
  if (remote_file_path != nullptr) {
    
  } else {
    
  }
  _impl_.remote_file_path_.SetAllocated(remote_file_path, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.remote_file_path_.IsDefault()) {
    _impl_.remote_file_path_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.DeleteRequest.remote_file_path)
}

// -------------------------------------------------------------------

// DeleteReply

// -------------------------------------------------------------------

// StatRequest

// string filepath = 1;
inline void StatRequest::clear_filepath() {
  _impl_.filepath_.ClearToEmpty();
}
inline const std::string& StatRequest::filepath() const {
  // @@protoc_insertion_point(field_get:Rpc.StatRequest.filepath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatRequest::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 _impl_.filepath_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.StatRequest.filepath)
}
inline std::string* StatRequest::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:Rpc.StatRequest.filepath)
  return _s;
}
inline const std::string& StatRequest::_internal_filepath() const {
  return _impl_.filepath_.Get();
}
inline void StatRequest::_internal_set_filepath(const std::string& value) {
  
  _impl_.filepath_.Set(value, GetArenaForAllocation());
}
inline std::string* StatRequest::_internal_mutable_filepath() {
  
  return _impl_.filepath_.Mutable(GetArenaForAllocation());
}
inline std::string* StatRequest::release_filepath() {
  // @@protoc_insertion_point(field_release:Rpc.StatRequest.filepath)
  return _impl_.filepath_.Release();
}
inline void StatRequest::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  _impl_.filepath_.SetAllocated(filepath, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.filepath_.IsDefault()) {
    _impl_.filepath_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.StatRequest.filepath)
}

// -------------------------------------------------------------------

// StatReply

// bool existed = 1;
inline void StatReply::clear_existed() {
  _impl_.existed_ = false;
}
inline bool StatReply::_internal_existed() const {
  return _impl_.existed_;
}
inline bool StatReply::existed() const {
  // @@protoc_insertion_point(field_get:Rpc.StatReply.existed)
  return _internal_existed();
}
inline void StatReply::_internal_set_existed(bool value) {
  
  _impl_.existed_ = value;
}
inline void StatReply::set_existed(bool value) {
  _internal_set_existed(value);
  // @@protoc_insertion_point(field_set:Rpc.StatReply.existed)
}

// string file_name = 2;
inline void StatReply::clear_file_name() {
  _impl_.file_name_.ClearToEmpty();
}
inline const std::string& StatReply::file_name() const {
  // @@protoc_insertion_point(field_get:Rpc.StatReply.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatReply::set_file_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.file_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.StatReply.file_name)
}
inline std::string* StatReply::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:Rpc.StatReply.file_name)
  return _s;
}
inline const std::string& StatReply::_internal_file_name() const {
  return _impl_.file_name_.Get();
}
inline void StatReply::_internal_set_file_name(const std::string& value) {
  
  _impl_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* StatReply::_internal_mutable_file_name() {
  
  return _impl_.file_name_.Mutable(GetArenaForAllocation());
}
inline std::string* StatReply::release_file_name() {
  // @@protoc_insertion_point(field_release:Rpc.StatReply.file_name)
  return _impl_.file_name_.Release();
}
inline void StatReply::set_allocated_file_name(std::string* file_name) {
  if (file_name != nullptr) {
    
  } else {
    
  }
  _impl_.file_name_.SetAllocated(file_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.file_name_.IsDefault()) {
    _impl_.file_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.StatReply.file_name)
}

// uint64 file_size = 3;
inline void StatReply::clear_file_size() {
  _impl_.file_size_ = uint64_t{0u};
}
inline uint64_t StatReply::_internal_file_size() const {
  return _impl_.file_size_;
}
inline uint64_t StatReply::file_size() const {
  // @@protoc_insertion_point(field_get:Rpc.StatReply.file_size)
  return _internal_file_size();
}
inline void StatReply::_internal_set_file_size(uint64_t value) {
  
  _impl_.file_size_ = value;
}
inline void StatReply::set_file_size(uint64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:Rpc.StatReply.file_size)
}

// -------------------------------------------------------------------

// HelloRequest

// string name = 1;
inline void HelloRequest::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& HelloRequest::name() const {
  // @@protoc_insertion_point(field_get:Rpc.HelloRequest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloRequest::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.HelloRequest.name)
}
inline std::string* HelloRequest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Rpc.HelloRequest.name)
  return _s;
}
inline const std::string& HelloRequest::_internal_name() const {
  return _impl_.name_.Get();
}
inline void HelloRequest::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloRequest::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloRequest::release_name() {
  // @@protoc_insertion_point(field_release:Rpc.HelloRequest.name)
  return _impl_.name_.Release();
}
inline void HelloRequest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.HelloRequest.name)
}

// -------------------------------------------------------------------

// HelloReply

// string message = 1;
inline void HelloReply::clear_message() {
  _impl_.message_.ClearToEmpty();
}
inline const std::string& HelloReply::message() const {
  // @@protoc_insertion_point(field_get:Rpc.HelloReply.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void HelloReply::set_message(ArgT0&& arg0, ArgT... args) {
 
 _impl_.message_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.HelloReply.message)
}
inline std::string* HelloReply::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:Rpc.HelloReply.message)
  return _s;
}
inline const std::string& HelloReply::_internal_message() const {
  return _impl_.message_.Get();
}
inline void HelloReply::_internal_set_message(const std::string& value) {
  
  _impl_.message_.Set(value, GetArenaForAllocation());
}
inline std::string* HelloReply::_internal_mutable_message() {
  
  return _impl_.message_.Mutable(GetArenaForAllocation());
}
inline std::string* HelloReply::release_message() {
  // @@protoc_insertion_point(field_release:Rpc.HelloReply.message)
  return _impl_.message_.Release();
}
inline void HelloReply::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    
  } else {
    
  }
  _impl_.message_.SetAllocated(message, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.message_.IsDefault()) {
    _impl_.message_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.HelloReply.message)
}

// -------------------------------------------------------------------

// WriteChunkRequest

// int64 client_id = 1;
inline void WriteChunkRequest::clear_client_id() {
  _impl_.client_id_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_client_id() const {
  return _impl_.client_id_;
}
inline int64_t WriteChunkRequest::client_id() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.client_id)
  return _internal_client_id();
}
inline void WriteChunkRequest::_internal_set_client_id(int64_t value) {
  
  _impl_.client_id_ = value;
}
inline void WriteChunkRequest::set_client_id(int64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.client_id)
}

// int64 chunkhandle = 2;
inline void WriteChunkRequest::clear_chunkhandle() {
  _impl_.chunkhandle_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_chunkhandle() const {
  return _impl_.chunkhandle_;
}
inline int64_t WriteChunkRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.chunkhandle)
  return _internal_chunkhandle();
}
inline void WriteChunkRequest::_internal_set_chunkhandle(int64_t value) {
  
  _impl_.chunkhandle_ = value;
}
inline void WriteChunkRequest::set_chunkhandle(int64_t value) {
  _internal_set_chunkhandle(value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.chunkhandle)
}

// int64 offset = 3;
inline void WriteChunkRequest::clear_offset() {
  _impl_.offset_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline int64_t WriteChunkRequest::offset() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.offset)
  return _internal_offset();
}
inline void WriteChunkRequest::_internal_set_offset(int64_t value) {
  
  _impl_.offset_ = value;
}
inline void WriteChunkRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.offset)
}

// int64 length = 4;
inline void WriteChunkRequest::clear_length() {
  _impl_.length_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_length() const {
  return _impl_.length_;
}
inline int64_t WriteChunkRequest::length() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.length)
  return _internal_length();
}
inline void WriteChunkRequest::_internal_set_length(int64_t value) {
  
  _impl_.length_ = value;
}
inline void WriteChunkRequest::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.length)
}

// repeated string locations = 5;
inline int WriteChunkRequest::_internal_locations_size() const {
  return _impl_.locations_.size();
}
inline int WriteChunkRequest::locations_size() const {
  return _internal_locations_size();
}
inline void WriteChunkRequest::clear_locations() {
  _impl_.locations_.Clear();
}
inline std::string* WriteChunkRequest::add_locations() {
  std::string* _s = _internal_add_locations();
  // @@protoc_insertion_point(field_add_mutable:Rpc.WriteChunkRequest.locations)
  return _s;
}
inline const std::string& WriteChunkRequest::_internal_locations(int index) const {
  return _impl_.locations_.Get(index);
}
inline const std::string& WriteChunkRequest::locations(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.locations)
  return _internal_locations(index);
}
inline std::string* WriteChunkRequest::mutable_locations(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.WriteChunkRequest.locations)
  return _impl_.locations_.Mutable(index);
}
inline void WriteChunkRequest::set_locations(int index, const std::string& value) {
  _impl_.locations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::set_locations(int index, std::string&& value) {
  _impl_.locations_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::set_locations(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.locations_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::set_locations(int index, const char* value, size_t size) {
  _impl_.locations_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.WriteChunkRequest.locations)
}
inline std::string* WriteChunkRequest::_internal_add_locations() {
  return _impl_.locations_.Add();
}
inline void WriteChunkRequest::add_locations(const std::string& value) {
  _impl_.locations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::add_locations(std::string&& value) {
  _impl_.locations_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::add_locations(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.locations_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.WriteChunkRequest.locations)
}
inline void WriteChunkRequest::add_locations(const char* value, size_t size) {
  _impl_.locations_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.WriteChunkRequest.locations)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
WriteChunkRequest::locations() const {
  // @@protoc_insertion_point(field_list:Rpc.WriteChunkRequest.locations)
  return _impl_.locations_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
WriteChunkRequest::mutable_locations() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.WriteChunkRequest.locations)
  return &_impl_.locations_;
}

// bytes data = 6;
inline void WriteChunkRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& WriteChunkRequest::data() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteChunkRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkRequest.data)
}
inline std::string* WriteChunkRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Rpc.WriteChunkRequest.data)
  return _s;
}
inline const std::string& WriteChunkRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void WriteChunkRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* WriteChunkRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* WriteChunkRequest::release_data() {
  // @@protoc_insertion_point(field_release:Rpc.WriteChunkRequest.data)
  return _impl_.data_.Release();
}
inline void WriteChunkRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.WriteChunkRequest.data)
}

// -------------------------------------------------------------------

// WriteChunkReply

// int64 bytes_read = 2;
inline void WriteChunkReply::clear_bytes_read() {
  _impl_.bytes_read_ = int64_t{0};
}
inline int64_t WriteChunkReply::_internal_bytes_read() const {
  return _impl_.bytes_read_;
}
inline int64_t WriteChunkReply::bytes_read() const {
  // @@protoc_insertion_point(field_get:Rpc.WriteChunkReply.bytes_read)
  return _internal_bytes_read();
}
inline void WriteChunkReply::_internal_set_bytes_read(int64_t value) {
  
  _impl_.bytes_read_ = value;
}
inline void WriteChunkReply::set_bytes_read(int64_t value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:Rpc.WriteChunkReply.bytes_read)
}

// -------------------------------------------------------------------

// ReadChunkRequest

// int64 chunkhandle = 1;
inline void ReadChunkRequest::clear_chunkhandle() {
  _impl_.chunkhandle_ = int64_t{0};
}
inline int64_t ReadChunkRequest::_internal_chunkhandle() const {
  return _impl_.chunkhandle_;
}
inline int64_t ReadChunkRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkRequest.chunkhandle)
  return _internal_chunkhandle();
}
inline void ReadChunkRequest::_internal_set_chunkhandle(int64_t value) {
  
  _impl_.chunkhandle_ = value;
}
inline void ReadChunkRequest::set_chunkhandle(int64_t value) {
  _internal_set_chunkhandle(value);
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkRequest.chunkhandle)
}

// int64 offset = 2;
inline void ReadChunkRequest::clear_offset() {
  _impl_.offset_ = int64_t{0};
}
inline int64_t ReadChunkRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline int64_t ReadChunkRequest::offset() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkRequest.offset)
  return _internal_offset();
}
inline void ReadChunkRequest::_internal_set_offset(int64_t value) {
  
  _impl_.offset_ = value;
}
inline void ReadChunkRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkRequest.offset)
}

// int64 length = 3;
inline void ReadChunkRequest::clear_length() {
  _impl_.length_ = int64_t{0};
}
inline int64_t ReadChunkRequest::_internal_length() const {
  return _impl_.length_;
}
inline int64_t ReadChunkRequest::length() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkRequest.length)
  return _internal_length();
}
inline void ReadChunkRequest::_internal_set_length(int64_t value) {
  
  _impl_.length_ = value;
}
inline void ReadChunkRequest::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkRequest.length)
}

// -------------------------------------------------------------------

// ReadChunkReply

// string data = 1;
inline void ReadChunkReply::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& ReadChunkReply::data() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkReply.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadChunkReply::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkReply.data)
}
inline std::string* ReadChunkReply::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Rpc.ReadChunkReply.data)
  return _s;
}
inline const std::string& ReadChunkReply::_internal_data() const {
  return _impl_.data_.Get();
}
inline void ReadChunkReply::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* ReadChunkReply::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* ReadChunkReply::release_data() {
  // @@protoc_insertion_point(field_release:Rpc.ReadChunkReply.data)
  return _impl_.data_.Release();
}
inline void ReadChunkReply::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.ReadChunkReply.data)
}

// int64 bytes_read = 2;
inline void ReadChunkReply::clear_bytes_read() {
  _impl_.bytes_read_ = int64_t{0};
}
inline int64_t ReadChunkReply::_internal_bytes_read() const {
  return _impl_.bytes_read_;
}
inline int64_t ReadChunkReply::bytes_read() const {
  // @@protoc_insertion_point(field_get:Rpc.ReadChunkReply.bytes_read)
  return _internal_bytes_read();
}
inline void ReadChunkReply::_internal_set_bytes_read(int64_t value) {
  
  _impl_.bytes_read_ = value;
}
inline void ReadChunkReply::set_bytes_read(int64_t value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:Rpc.ReadChunkReply.bytes_read)
}

// -------------------------------------------------------------------

// DataNodeLocation

// string location = 1;
inline void DataNodeLocation::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& DataNodeLocation::location() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNodeLocation.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataNodeLocation::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.DataNodeLocation.location)
}
inline std::string* DataNodeLocation::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.DataNodeLocation.location)
  return _s;
}
inline const std::string& DataNodeLocation::_internal_location() const {
  return _impl_.location_.Get();
}
inline void DataNodeLocation::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* DataNodeLocation::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* DataNodeLocation::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.DataNodeLocation.location)
  return _impl_.location_.Release();
}
inline void DataNodeLocation::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.DataNodeLocation.location)
}

// -------------------------------------------------------------------

// DataNode

// string location = 1;
inline void DataNode::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& DataNode::location() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataNode::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.DataNode.location)
}
inline std::string* DataNode::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.DataNode.location)
  return _s;
}
inline const std::string& DataNode::_internal_location() const {
  return _impl_.location_.Get();
}
inline void DataNode::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* DataNode::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* DataNode::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.DataNode.location)
  return _impl_.location_.Release();
}
inline void DataNode::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.DataNode.location)
}

// uint32 available_size = 2;
inline void DataNode::clear_available_size() {
  _impl_.available_size_ = 0u;
}
inline uint32_t DataNode::_internal_available_size() const {
  return _impl_.available_size_;
}
inline uint32_t DataNode::available_size() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.available_size)
  return _internal_available_size();
}
inline void DataNode::_internal_set_available_size(uint32_t value) {
  
  _impl_.available_size_ = value;
}
inline void DataNode::set_available_size(uint32_t value) {
  _internal_set_available_size(value);
  // @@protoc_insertion_point(field_set:Rpc.DataNode.available_size)
}

// repeated int64 stored_chunk_handles = 3;
inline int DataNode::_internal_stored_chunk_handles_size() const {
  return _impl_.stored_chunk_handles_.size();
}
inline int DataNode::stored_chunk_handles_size() const {
  return _internal_stored_chunk_handles_size();
}
inline void DataNode::clear_stored_chunk_handles() {
  _impl_.stored_chunk_handles_.Clear();
}
inline int64_t DataNode::_internal_stored_chunk_handles(int index) const {
  return _impl_.stored_chunk_handles_.Get(index);
}
inline int64_t DataNode::stored_chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.stored_chunk_handles)
  return _internal_stored_chunk_handles(index);
}
inline void DataNode::set_stored_chunk_handles(int index, int64_t value) {
  _impl_.stored_chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.DataNode.stored_chunk_handles)
}
inline void DataNode::_internal_add_stored_chunk_handles(int64_t value) {
  _impl_.stored_chunk_handles_.Add(value);
}
inline void DataNode::add_stored_chunk_handles(int64_t value) {
  _internal_add_stored_chunk_handles(value);
  // @@protoc_insertion_point(field_add:Rpc.DataNode.stored_chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DataNode::_internal_stored_chunk_handles() const {
  return _impl_.stored_chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DataNode::stored_chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.DataNode.stored_chunk_handles)
  return _internal_stored_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DataNode::_internal_mutable_stored_chunk_handles() {
  return &_impl_.stored_chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DataNode::mutable_stored_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.DataNode.stored_chunk_handles)
  return _internal_mutable_stored_chunk_handles();
}

// -------------------------------------------------------------------

// Chunk

// int64 chunk_handle = 1;
inline void Chunk::clear_chunk_handle() {
  _impl_.chunk_handle_ = int64_t{0};
}
inline int64_t Chunk::_internal_chunk_handle() const {
  return _impl_.chunk_handle_;
}
inline int64_t Chunk::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.chunk_handle)
  return _internal_chunk_handle();
}
inline void Chunk::_internal_set_chunk_handle(int64_t value) {
  
  _impl_.chunk_handle_ = value;
}
inline void Chunk::set_chunk_handle(int64_t value) {
  _internal_set_chunk_handle(value);
  // @@protoc_insertion_point(field_set:Rpc.Chunk.chunk_handle)
}

// repeated string location = 2;
inline int Chunk::_internal_location_size() const {
  return _impl_.location_.size();
}
inline int Chunk::location_size() const {
  return _internal_location_size();
}
inline void Chunk::clear_location() {
  _impl_.location_.Clear();
}
inline std::string* Chunk::add_location() {
  std::string* _s = _internal_add_location();
  // @@protoc_insertion_point(field_add_mutable:Rpc.Chunk.location)
  return _s;
}
inline const std::string& Chunk::_internal_location(int index) const {
  return _impl_.location_.Get(index);
}
inline const std::string& Chunk::location(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.location)
  return _internal_location(index);
}
inline std::string* Chunk::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.Chunk.location)
  return _impl_.location_.Mutable(index);
}
inline void Chunk::set_location(int index, const std::string& value) {
  _impl_.location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, std::string&& value) {
  _impl_.location_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, const char* value, size_t size) {
  _impl_.location_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.Chunk.location)
}
inline std::string* Chunk::_internal_add_location() {
  return _impl_.location_.Add();
}
inline void Chunk::add_location(const std::string& value) {
  _impl_.location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.Chunk.location)
}
inline void Chunk::add_location(std::string&& value) {
  _impl_.location_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.Chunk.location)
}
inline void Chunk::add_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.Chunk.location)
}
inline void Chunk::add_location(const char* value, size_t size) {
  _impl_.location_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.Chunk.location)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Chunk::location() const {
  // @@protoc_insertion_point(field_list:Rpc.Chunk.location)
  return _impl_.location_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Chunk::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.Chunk.location)
  return &_impl_.location_;
}

// int64 size = 3;
inline void Chunk::clear_size() {
  _impl_.size_ = int64_t{0};
}
inline int64_t Chunk::_internal_size() const {
  return _impl_.size_;
}
inline int64_t Chunk::size() const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.size)
  return _internal_size();
}
inline void Chunk::_internal_set_size(int64_t value) {
  
  _impl_.size_ = value;
}
inline void Chunk::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Rpc.Chunk.size)
}

// -------------------------------------------------------------------

// ReportDataNodeRequest

// string location = 1;
inline void ReportDataNodeRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& ReportDataNodeRequest::location() const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReportDataNodeRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.ReportDataNodeRequest.location)
}
inline std::string* ReportDataNodeRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.ReportDataNodeRequest.location)
  return _s;
}
inline const std::string& ReportDataNodeRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void ReportDataNodeRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* ReportDataNodeRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* ReportDataNodeRequest::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.ReportDataNodeRequest.location)
  return _impl_.location_.Release();
}
inline void ReportDataNodeRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.ReportDataNodeRequest.location)
}

// uint32 available_size = 2;
inline void ReportDataNodeRequest::clear_available_size() {
  _impl_.available_size_ = 0u;
}
inline uint32_t ReportDataNodeRequest::_internal_available_size() const {
  return _impl_.available_size_;
}
inline uint32_t ReportDataNodeRequest::available_size() const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.available_size)
  return _internal_available_size();
}
inline void ReportDataNodeRequest::_internal_set_available_size(uint32_t value) {
  
  _impl_.available_size_ = value;
}
inline void ReportDataNodeRequest::set_available_size(uint32_t value) {
  _internal_set_available_size(value);
  // @@protoc_insertion_point(field_set:Rpc.ReportDataNodeRequest.available_size)
}

// repeated int64 stored_chunk_handles = 3;
inline int ReportDataNodeRequest::_internal_stored_chunk_handles_size() const {
  return _impl_.stored_chunk_handles_.size();
}
inline int ReportDataNodeRequest::stored_chunk_handles_size() const {
  return _internal_stored_chunk_handles_size();
}
inline void ReportDataNodeRequest::clear_stored_chunk_handles() {
  _impl_.stored_chunk_handles_.Clear();
}
inline int64_t ReportDataNodeRequest::_internal_stored_chunk_handles(int index) const {
  return _impl_.stored_chunk_handles_.Get(index);
}
inline int64_t ReportDataNodeRequest::stored_chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.stored_chunk_handles)
  return _internal_stored_chunk_handles(index);
}
inline void ReportDataNodeRequest::set_stored_chunk_handles(int index, int64_t value) {
  _impl_.stored_chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.ReportDataNodeRequest.stored_chunk_handles)
}
inline void ReportDataNodeRequest::_internal_add_stored_chunk_handles(int64_t value) {
  _impl_.stored_chunk_handles_.Add(value);
}
inline void ReportDataNodeRequest::add_stored_chunk_handles(int64_t value) {
  _internal_add_stored_chunk_handles(value);
  // @@protoc_insertion_point(field_add:Rpc.ReportDataNodeRequest.stored_chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ReportDataNodeRequest::_internal_stored_chunk_handles() const {
  return _impl_.stored_chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
ReportDataNodeRequest::stored_chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.ReportDataNodeRequest.stored_chunk_handles)
  return _internal_stored_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ReportDataNodeRequest::_internal_mutable_stored_chunk_handles() {
  return &_impl_.stored_chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
ReportDataNodeRequest::mutable_stored_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.ReportDataNodeRequest.stored_chunk_handles)
  return _internal_mutable_stored_chunk_handles();
}

// -------------------------------------------------------------------

// ReportDataNodeReply

// -------------------------------------------------------------------

// HeartbeatRequest

// -------------------------------------------------------------------

// HeartbeatReply

// .Rpc.HeartbeatRequest request = 1;
inline bool HeartbeatReply::_internal_has_request() const {
  return this != internal_default_instance() && _impl_.request_ != nullptr;
}
inline bool HeartbeatReply::has_request() const {
  return _internal_has_request();
}
inline void HeartbeatReply::clear_request() {
  if (GetArenaForAllocation() == nullptr && _impl_.request_ != nullptr) {
    delete _impl_.request_;
  }
  _impl_.request_ = nullptr;
}
inline const ::Rpc::HeartbeatRequest& HeartbeatReply::_internal_request() const {
  const ::Rpc::HeartbeatRequest* p = _impl_.request_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rpc::HeartbeatRequest&>(
      ::Rpc::_HeartbeatRequest_default_instance_);
}
inline const ::Rpc::HeartbeatRequest& HeartbeatReply::request() const {
  // @@protoc_insertion_point(field_get:Rpc.HeartbeatReply.request)
  return _internal_request();
}
inline void HeartbeatReply::unsafe_arena_set_allocated_request(
    ::Rpc::HeartbeatRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.request_);
  }
  _impl_.request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rpc.HeartbeatReply.request)
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::release_request() {
  
  ::Rpc::HeartbeatRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:Rpc.HeartbeatReply.request)
  
  ::Rpc::HeartbeatRequest* temp = _impl_.request_;
  _impl_.request_ = nullptr;
  return temp;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::_internal_mutable_request() {
  
  if (_impl_.request_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rpc::HeartbeatRequest>(GetArenaForAllocation());
    _impl_.request_ = p;
  }
  return _impl_.request_;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::mutable_request() {
  ::Rpc::HeartbeatRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:Rpc.HeartbeatReply.request)
  return _msg;
}
inline void HeartbeatReply::set_allocated_request(::Rpc::HeartbeatRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.request_ = request;
  // @@protoc_insertion_point(field_set_allocated:Rpc.HeartbeatReply.request)
}

// -------------------------------------------------------------------

// CopyChunkRequest

// string location = 1;
inline void CopyChunkRequest::clear_location() {
  _impl_.location_.ClearToEmpty();
}
inline const std::string& CopyChunkRequest::location() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyChunkRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 _impl_.location_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkRequest.location)
}
inline std::string* CopyChunkRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.CopyChunkRequest.location)
  return _s;
}
inline const std::string& CopyChunkRequest::_internal_location() const {
  return _impl_.location_.Get();
}
inline void CopyChunkRequest::_internal_set_location(const std::string& value) {
  
  _impl_.location_.Set(value, GetArenaForAllocation());
}
inline std::string* CopyChunkRequest::_internal_mutable_location() {
  
  return _impl_.location_.Mutable(GetArenaForAllocation());
}
inline std::string* CopyChunkRequest::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.CopyChunkRequest.location)
  return _impl_.location_.Release();
}
inline void CopyChunkRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  _impl_.location_.SetAllocated(location, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.location_.IsDefault()) {
    _impl_.location_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.CopyChunkRequest.location)
}

// int64 chunk_handle = 2;
inline void CopyChunkRequest::clear_chunk_handle() {
  _impl_.chunk_handle_ = int64_t{0};
}
inline int64_t CopyChunkRequest::_internal_chunk_handle() const {
  return _impl_.chunk_handle_;
}
inline int64_t CopyChunkRequest::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkRequest.chunk_handle)
  return _internal_chunk_handle();
}
inline void CopyChunkRequest::_internal_set_chunk_handle(int64_t value) {
  
  _impl_.chunk_handle_ = value;
}
inline void CopyChunkRequest::set_chunk_handle(int64_t value) {
  _internal_set_chunk_handle(value);
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkRequest.chunk_handle)
}

// -------------------------------------------------------------------

// CopyChunkReply

// -------------------------------------------------------------------

// MultiWriteRequest

// int64 client_id = 1;
inline void MultiWriteRequest::clear_client_id() {
  _impl_.client_id_ = int64_t{0};
}
inline int64_t MultiWriteRequest::_internal_client_id() const {
  return _impl_.client_id_;
}
inline int64_t MultiWriteRequest::client_id() const {
  // @@protoc_insertion_point(field_get:Rpc.MultiWriteRequest.client_id)
  return _internal_client_id();
}
inline void MultiWriteRequest::_internal_set_client_id(int64_t value) {
  
  _impl_.client_id_ = value;
}
inline void MultiWriteRequest::set_client_id(int64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:Rpc.MultiWriteRequest.client_id)
}

// int64 chunkhandle = 2;
inline void MultiWriteRequest::clear_chunkhandle() {
  _impl_.chunkhandle_ = int64_t{0};
}
inline int64_t MultiWriteRequest::_internal_chunkhandle() const {
  return _impl_.chunkhandle_;
}
inline int64_t MultiWriteRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:Rpc.MultiWriteRequest.chunkhandle)
  return _internal_chunkhandle();
}
inline void MultiWriteRequest::_internal_set_chunkhandle(int64_t value) {
  
  _impl_.chunkhandle_ = value;
}
inline void MultiWriteRequest::set_chunkhandle(int64_t value) {
  _internal_set_chunkhandle(value);
  // @@protoc_insertion_point(field_set:Rpc.MultiWriteRequest.chunkhandle)
}

// int64 offset = 3;
inline void MultiWriteRequest::clear_offset() {
  _impl_.offset_ = int64_t{0};
}
inline int64_t MultiWriteRequest::_internal_offset() const {
  return _impl_.offset_;
}
inline int64_t MultiWriteRequest::offset() const {
  // @@protoc_insertion_point(field_get:Rpc.MultiWriteRequest.offset)
  return _internal_offset();
}
inline void MultiWriteRequest::_internal_set_offset(int64_t value) {
  
  _impl_.offset_ = value;
}
inline void MultiWriteRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Rpc.MultiWriteRequest.offset)
}

// bool padded_chunk = 4;
inline void MultiWriteRequest::clear_padded_chunk() {
  _impl_.padded_chunk_ = false;
}
inline bool MultiWriteRequest::_internal_padded_chunk() const {
  return _impl_.padded_chunk_;
}
inline bool MultiWriteRequest::padded_chunk() const {
  // @@protoc_insertion_point(field_get:Rpc.MultiWriteRequest.padded_chunk)
  return _internal_padded_chunk();
}
inline void MultiWriteRequest::_internal_set_padded_chunk(bool value) {
  
  _impl_.padded_chunk_ = value;
}
inline void MultiWriteRequest::set_padded_chunk(bool value) {
  _internal_set_padded_chunk(value);
  // @@protoc_insertion_point(field_set:Rpc.MultiWriteRequest.padded_chunk)
}

// bytes data = 5;
inline void MultiWriteRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& MultiWriteRequest::data() const {
  // @@protoc_insertion_point(field_get:Rpc.MultiWriteRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MultiWriteRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.MultiWriteRequest.data)
}
inline std::string* MultiWriteRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Rpc.MultiWriteRequest.data)
  return _s;
}
inline const std::string& MultiWriteRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void MultiWriteRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* MultiWriteRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* MultiWriteRequest::release_data() {
  // @@protoc_insertion_point(field_release:Rpc.MultiWriteRequest.data)
  return _impl_.data_.Release();
}
inline void MultiWriteRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.MultiWriteRequest.data)
}

// -------------------------------------------------------------------

// MultiWriteReply

// int64 bytes_written = 1;
inline void MultiWriteReply::clear_bytes_written() {
  _impl_.bytes_written_ = int64_t{0};
}
inline int64_t MultiWriteReply::_internal_bytes_written() const {
  return _impl_.bytes_written_;
}
inline int64_t MultiWriteReply::bytes_written() const {
  // @@protoc_insertion_point(field_get:Rpc.MultiWriteReply.bytes_written)
  return _internal_bytes_written();
}
inline void MultiWriteReply::_internal_set_bytes_written(int64_t value) {
  
  _impl_.bytes_written_ = value;
}
inline void MultiWriteReply::set_bytes_written(int64_t value) {
  _internal_set_bytes_written(value);
  // @@protoc_insertion_point(field_set:Rpc.MultiWriteReply.bytes_written)
}

// -------------------------------------------------------------------

// CopyChunkWriteRequest

// bytes data = 1;
inline void CopyChunkWriteRequest::clear_data() {
  _impl_.data_.ClearToEmpty();
}
inline const std::string& CopyChunkWriteRequest::data() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkWriteRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyChunkWriteRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 _impl_.data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkWriteRequest.data)
}
inline std::string* CopyChunkWriteRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:Rpc.CopyChunkWriteRequest.data)
  return _s;
}
inline const std::string& CopyChunkWriteRequest::_internal_data() const {
  return _impl_.data_.Get();
}
inline void CopyChunkWriteRequest::_internal_set_data(const std::string& value) {
  
  _impl_.data_.Set(value, GetArenaForAllocation());
}
inline std::string* CopyChunkWriteRequest::_internal_mutable_data() {
  
  return _impl_.data_.Mutable(GetArenaForAllocation());
}
inline std::string* CopyChunkWriteRequest::release_data() {
  // @@protoc_insertion_point(field_release:Rpc.CopyChunkWriteRequest.data)
  return _impl_.data_.Release();
}
inline void CopyChunkWriteRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  _impl_.data_.SetAllocated(data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.data_.IsDefault()) {
    _impl_.data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.CopyChunkWriteRequest.data)
}

// int64 chunk_handle = 2;
inline void CopyChunkWriteRequest::clear_chunk_handle() {
  _impl_.chunk_handle_ = int64_t{0};
}
inline int64_t CopyChunkWriteRequest::_internal_chunk_handle() const {
  return _impl_.chunk_handle_;
}
inline int64_t CopyChunkWriteRequest::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkWriteRequest.chunk_handle)
  return _internal_chunk_handle();
}
inline void CopyChunkWriteRequest::_internal_set_chunk_handle(int64_t value) {
  
  _impl_.chunk_handle_ = value;
}
inline void CopyChunkWriteRequest::set_chunk_handle(int64_t value) {
  _internal_set_chunk_handle(value);
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkWriteRequest.chunk_handle)
}

// -------------------------------------------------------------------

// CopyChunkWriteReply

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Rpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_final_2eproto
