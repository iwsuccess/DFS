// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cli2ser.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_cli2ser_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_cli2ser_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_cli2ser_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_cli2ser_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[20]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_cli2ser_2eproto;
class DeleteReply;
struct DeleteReplyDefaultTypeInternal;
extern DeleteReplyDefaultTypeInternal _DeleteReply_default_instance_;
class DeleteRequest;
struct DeleteRequestDefaultTypeInternal;
extern DeleteRequestDefaultTypeInternal _DeleteRequest_default_instance_;
class FindAddrReply;
struct FindAddrReplyDefaultTypeInternal;
extern FindAddrReplyDefaultTypeInternal _FindAddrReply_default_instance_;
class FindAddrReply_ReplicaAddrs;
struct FindAddrReply_ReplicaAddrsDefaultTypeInternal;
extern FindAddrReply_ReplicaAddrsDefaultTypeInternal _FindAddrReply_ReplicaAddrs_default_instance_;
class FindAddrRequest;
struct FindAddrRequestDefaultTypeInternal;
extern FindAddrRequestDefaultTypeInternal _FindAddrRequest_default_instance_;
class GetSubDirPathsReply;
struct GetSubDirPathsReplyDefaultTypeInternal;
extern GetSubDirPathsReplyDefaultTypeInternal _GetSubDirPathsReply_default_instance_;
class GetSubDirPathsRequest;
struct GetSubDirPathsRequestDefaultTypeInternal;
extern GetSubDirPathsRequestDefaultTypeInternal _GetSubDirPathsRequest_default_instance_;
class GetWriteAddrReply;
struct GetWriteAddrReplyDefaultTypeInternal;
extern GetWriteAddrReplyDefaultTypeInternal _GetWriteAddrReply_default_instance_;
class GetWriteAddrReply_ReplicaAddrs;
struct GetWriteAddrReply_ReplicaAddrsDefaultTypeInternal;
extern GetWriteAddrReply_ReplicaAddrsDefaultTypeInternal _GetWriteAddrReply_ReplicaAddrs_default_instance_;
class GetWriteAddrRequest;
struct GetWriteAddrRequestDefaultTypeInternal;
extern GetWriteAddrRequestDefaultTypeInternal _GetWriteAddrRequest_default_instance_;
class MkdirReply;
struct MkdirReplyDefaultTypeInternal;
extern MkdirReplyDefaultTypeInternal _MkdirReply_default_instance_;
class MkdirRequest;
struct MkdirRequestDefaultTypeInternal;
extern MkdirRequestDefaultTypeInternal _MkdirRequest_default_instance_;
class ReadChunkReply;
struct ReadChunkReplyDefaultTypeInternal;
extern ReadChunkReplyDefaultTypeInternal _ReadChunkReply_default_instance_;
class ReadChunkRequest;
struct ReadChunkRequestDefaultTypeInternal;
extern ReadChunkRequestDefaultTypeInternal _ReadChunkRequest_default_instance_;
class RenameReply;
struct RenameReplyDefaultTypeInternal;
extern RenameReplyDefaultTypeInternal _RenameReply_default_instance_;
class RenameRequest;
struct RenameRequestDefaultTypeInternal;
extern RenameRequestDefaultTypeInternal _RenameRequest_default_instance_;
class StatReply;
struct StatReplyDefaultTypeInternal;
extern StatReplyDefaultTypeInternal _StatReply_default_instance_;
class StatRequest;
struct StatRequestDefaultTypeInternal;
extern StatRequestDefaultTypeInternal _StatRequest_default_instance_;
class WriteChunkReply;
struct WriteChunkReplyDefaultTypeInternal;
extern WriteChunkReplyDefaultTypeInternal _WriteChunkReply_default_instance_;
class WriteChunkRequest;
struct WriteChunkRequestDefaultTypeInternal;
extern WriteChunkRequestDefaultTypeInternal _WriteChunkRequest_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::DeleteReply* Arena::CreateMaybeMessage<::DeleteReply>(Arena*);
template<> ::DeleteRequest* Arena::CreateMaybeMessage<::DeleteRequest>(Arena*);
template<> ::FindAddrReply* Arena::CreateMaybeMessage<::FindAddrReply>(Arena*);
template<> ::FindAddrReply_ReplicaAddrs* Arena::CreateMaybeMessage<::FindAddrReply_ReplicaAddrs>(Arena*);
template<> ::FindAddrRequest* Arena::CreateMaybeMessage<::FindAddrRequest>(Arena*);
template<> ::GetSubDirPathsReply* Arena::CreateMaybeMessage<::GetSubDirPathsReply>(Arena*);
template<> ::GetSubDirPathsRequest* Arena::CreateMaybeMessage<::GetSubDirPathsRequest>(Arena*);
template<> ::GetWriteAddrReply* Arena::CreateMaybeMessage<::GetWriteAddrReply>(Arena*);
template<> ::GetWriteAddrReply_ReplicaAddrs* Arena::CreateMaybeMessage<::GetWriteAddrReply_ReplicaAddrs>(Arena*);
template<> ::GetWriteAddrRequest* Arena::CreateMaybeMessage<::GetWriteAddrRequest>(Arena*);
template<> ::MkdirReply* Arena::CreateMaybeMessage<::MkdirReply>(Arena*);
template<> ::MkdirRequest* Arena::CreateMaybeMessage<::MkdirRequest>(Arena*);
template<> ::ReadChunkReply* Arena::CreateMaybeMessage<::ReadChunkReply>(Arena*);
template<> ::ReadChunkRequest* Arena::CreateMaybeMessage<::ReadChunkRequest>(Arena*);
template<> ::RenameReply* Arena::CreateMaybeMessage<::RenameReply>(Arena*);
template<> ::RenameRequest* Arena::CreateMaybeMessage<::RenameRequest>(Arena*);
template<> ::StatReply* Arena::CreateMaybeMessage<::StatReply>(Arena*);
template<> ::StatRequest* Arena::CreateMaybeMessage<::StatRequest>(Arena*);
template<> ::WriteChunkReply* Arena::CreateMaybeMessage<::WriteChunkReply>(Arena*);
template<> ::WriteChunkRequest* Arena::CreateMaybeMessage<::WriteChunkRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class FindAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FindAddrRequest) */ {
 public:
  inline FindAddrRequest() : FindAddrRequest(nullptr) {}
  ~FindAddrRequest() override;
  explicit constexpr FindAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAddrRequest(const FindAddrRequest& from);
  FindAddrRequest(FindAddrRequest&& from) noexcept
    : FindAddrRequest() {
    *this = ::std::move(from);
  }

  inline FindAddrRequest& operator=(const FindAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAddrRequest& operator=(FindAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAddrRequest* internal_default_instance() {
    return reinterpret_cast<const FindAddrRequest*>(
               &_FindAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(FindAddrRequest& a, FindAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAddrRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindAddrRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FindAddrRequest";
  }
  protected:
  explicit FindAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
  };
  // string file_path = 1;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // @@protoc_insertion_point(class_scope:FindAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class FindAddrReply_ReplicaAddrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FindAddrReply.ReplicaAddrs) */ {
 public:
  inline FindAddrReply_ReplicaAddrs() : FindAddrReply_ReplicaAddrs(nullptr) {}
  ~FindAddrReply_ReplicaAddrs() override;
  explicit constexpr FindAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAddrReply_ReplicaAddrs(const FindAddrReply_ReplicaAddrs& from);
  FindAddrReply_ReplicaAddrs(FindAddrReply_ReplicaAddrs&& from) noexcept
    : FindAddrReply_ReplicaAddrs() {
    *this = ::std::move(from);
  }

  inline FindAddrReply_ReplicaAddrs& operator=(const FindAddrReply_ReplicaAddrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAddrReply_ReplicaAddrs& operator=(FindAddrReply_ReplicaAddrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAddrReply_ReplicaAddrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAddrReply_ReplicaAddrs* internal_default_instance() {
    return reinterpret_cast<const FindAddrReply_ReplicaAddrs*>(
               &_FindAddrReply_ReplicaAddrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FindAddrReply_ReplicaAddrs& a, FindAddrReply_ReplicaAddrs& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAddrReply_ReplicaAddrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAddrReply_ReplicaAddrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAddrReply_ReplicaAddrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindAddrReply_ReplicaAddrs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrReply_ReplicaAddrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FindAddrReply.ReplicaAddrs";
  }
  protected:
  explicit FindAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpPortsFieldNumber = 1,
  };
  // repeated string ip_ports = 1;
  int ip_ports_size() const;
  private:
  int _internal_ip_ports_size() const;
  public:
  void clear_ip_ports();
  const std::string& ip_ports(int index) const;
  std::string* mutable_ip_ports(int index);
  void set_ip_ports(int index, const std::string& value);
  void set_ip_ports(int index, std::string&& value);
  void set_ip_ports(int index, const char* value);
  void set_ip_ports(int index, const char* value, size_t size);
  std::string* add_ip_ports();
  void add_ip_ports(const std::string& value);
  void add_ip_ports(std::string&& value);
  void add_ip_ports(const char* value);
  void add_ip_ports(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_ports();
  private:
  const std::string& _internal_ip_ports(int index) const;
  std::string* _internal_add_ip_ports();
  public:

  // @@protoc_insertion_point(class_scope:FindAddrReply.ReplicaAddrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_ports_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class FindAddrReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FindAddrReply) */ {
 public:
  inline FindAddrReply() : FindAddrReply(nullptr) {}
  ~FindAddrReply() override;
  explicit constexpr FindAddrReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FindAddrReply(const FindAddrReply& from);
  FindAddrReply(FindAddrReply&& from) noexcept
    : FindAddrReply() {
    *this = ::std::move(from);
  }

  inline FindAddrReply& operator=(const FindAddrReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline FindAddrReply& operator=(FindAddrReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FindAddrReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const FindAddrReply* internal_default_instance() {
    return reinterpret_cast<const FindAddrReply*>(
               &_FindAddrReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FindAddrReply& a, FindAddrReply& b) {
    a.Swap(&b);
  }
  inline void Swap(FindAddrReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FindAddrReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FindAddrReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FindAddrReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FindAddrReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FindAddrReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindAddrReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FindAddrReply";
  }
  protected:
  explicit FindAddrReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef FindAddrReply_ReplicaAddrs ReplicaAddrs;

  // accessors -------------------------------------------------------

  enum : int {
    kChunkHandlesFieldNumber = 1,
    kAddrsFieldNumber = 2,
  };
  // repeated int64 chunk_handles = 1;
  int chunk_handles_size() const;
  private:
  int _internal_chunk_handles_size() const;
  public:
  void clear_chunk_handles();
  private:
  int64_t _internal_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_chunk_handles() const;
  void _internal_add_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_chunk_handles();
  public:
  int64_t chunk_handles(int index) const;
  void set_chunk_handles(int index, int64_t value);
  void add_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_chunk_handles();

  // repeated .FindAddrReply.ReplicaAddrs addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  ::FindAddrReply_ReplicaAddrs* mutable_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FindAddrReply_ReplicaAddrs >*
      mutable_addrs();
  private:
  const ::FindAddrReply_ReplicaAddrs& _internal_addrs(int index) const;
  ::FindAddrReply_ReplicaAddrs* _internal_add_addrs();
  public:
  const ::FindAddrReply_ReplicaAddrs& addrs(int index) const;
  ::FindAddrReply_ReplicaAddrs* add_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FindAddrReply_ReplicaAddrs >&
      addrs() const;

  // @@protoc_insertion_point(class_scope:FindAddrReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > chunk_handles_;
  mutable std::atomic<int> _chunk_handles_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FindAddrReply_ReplicaAddrs > addrs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class GetWriteAddrRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetWriteAddrRequest) */ {
 public:
  inline GetWriteAddrRequest() : GetWriteAddrRequest(nullptr) {}
  ~GetWriteAddrRequest() override;
  explicit constexpr GetWriteAddrRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWriteAddrRequest(const GetWriteAddrRequest& from);
  GetWriteAddrRequest(GetWriteAddrRequest&& from) noexcept
    : GetWriteAddrRequest() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrRequest& operator=(const GetWriteAddrRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWriteAddrRequest& operator=(GetWriteAddrRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWriteAddrRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWriteAddrRequest* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrRequest*>(
               &_GetWriteAddrRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetWriteAddrRequest& a, GetWriteAddrRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWriteAddrRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWriteAddrRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWriteAddrRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWriteAddrRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWriteAddrRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetWriteAddrRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetWriteAddrRequest";
  }
  protected:
  explicit GetWriteAddrRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteFilePathFieldNumber = 1,
    kWriteDataSizeFieldNumber = 2,
  };
  // string remote_file_path = 1;
  void clear_remote_file_path();
  const std::string& remote_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_file_path();
  PROTOBUF_NODISCARD std::string* release_remote_file_path();
  void set_allocated_remote_file_path(std::string* remote_file_path);
  private:
  const std::string& _internal_remote_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_file_path(const std::string& value);
  std::string* _internal_mutable_remote_file_path();
  public:

  // int64 write_data_size = 2;
  void clear_write_data_size();
  int64_t write_data_size() const;
  void set_write_data_size(int64_t value);
  private:
  int64_t _internal_write_data_size() const;
  void _internal_set_write_data_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetWriteAddrRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_file_path_;
  int64_t write_data_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class GetWriteAddrReply_ReplicaAddrs final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetWriteAddrReply.ReplicaAddrs) */ {
 public:
  inline GetWriteAddrReply_ReplicaAddrs() : GetWriteAddrReply_ReplicaAddrs(nullptr) {}
  ~GetWriteAddrReply_ReplicaAddrs() override;
  explicit constexpr GetWriteAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWriteAddrReply_ReplicaAddrs(const GetWriteAddrReply_ReplicaAddrs& from);
  GetWriteAddrReply_ReplicaAddrs(GetWriteAddrReply_ReplicaAddrs&& from) noexcept
    : GetWriteAddrReply_ReplicaAddrs() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrReply_ReplicaAddrs& operator=(const GetWriteAddrReply_ReplicaAddrs& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWriteAddrReply_ReplicaAddrs& operator=(GetWriteAddrReply_ReplicaAddrs&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWriteAddrReply_ReplicaAddrs& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWriteAddrReply_ReplicaAddrs* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrReply_ReplicaAddrs*>(
               &_GetWriteAddrReply_ReplicaAddrs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetWriteAddrReply_ReplicaAddrs& a, GetWriteAddrReply_ReplicaAddrs& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWriteAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWriteAddrReply_ReplicaAddrs* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWriteAddrReply_ReplicaAddrs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWriteAddrReply_ReplicaAddrs>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWriteAddrReply_ReplicaAddrs& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetWriteAddrReply_ReplicaAddrs& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrReply_ReplicaAddrs* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetWriteAddrReply.ReplicaAddrs";
  }
  protected:
  explicit GetWriteAddrReply_ReplicaAddrs(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpPortsFieldNumber = 1,
  };
  // repeated string ip_ports = 1;
  int ip_ports_size() const;
  private:
  int _internal_ip_ports_size() const;
  public:
  void clear_ip_ports();
  const std::string& ip_ports(int index) const;
  std::string* mutable_ip_ports(int index);
  void set_ip_ports(int index, const std::string& value);
  void set_ip_ports(int index, std::string&& value);
  void set_ip_ports(int index, const char* value);
  void set_ip_ports(int index, const char* value, size_t size);
  std::string* add_ip_ports();
  void add_ip_ports(const std::string& value);
  void add_ip_ports(std::string&& value);
  void add_ip_ports(const char* value);
  void add_ip_ports(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_ports() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_ports();
  private:
  const std::string& _internal_ip_ports(int index) const;
  std::string* _internal_add_ip_ports();
  public:

  // @@protoc_insertion_point(class_scope:GetWriteAddrReply.ReplicaAddrs)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_ports_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class GetWriteAddrReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetWriteAddrReply) */ {
 public:
  inline GetWriteAddrReply() : GetWriteAddrReply(nullptr) {}
  ~GetWriteAddrReply() override;
  explicit constexpr GetWriteAddrReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetWriteAddrReply(const GetWriteAddrReply& from);
  GetWriteAddrReply(GetWriteAddrReply&& from) noexcept
    : GetWriteAddrReply() {
    *this = ::std::move(from);
  }

  inline GetWriteAddrReply& operator=(const GetWriteAddrReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetWriteAddrReply& operator=(GetWriteAddrReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetWriteAddrReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetWriteAddrReply* internal_default_instance() {
    return reinterpret_cast<const GetWriteAddrReply*>(
               &_GetWriteAddrReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetWriteAddrReply& a, GetWriteAddrReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetWriteAddrReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetWriteAddrReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetWriteAddrReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetWriteAddrReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetWriteAddrReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetWriteAddrReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetWriteAddrReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetWriteAddrReply";
  }
  protected:
  explicit GetWriteAddrReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetWriteAddrReply_ReplicaAddrs ReplicaAddrs;

  // accessors -------------------------------------------------------

  enum : int {
    kChunkHandlesFieldNumber = 1,
    kAddrsFieldNumber = 2,
  };
  // repeated int64 chunk_handles = 1;
  int chunk_handles_size() const;
  private:
  int _internal_chunk_handles_size() const;
  public:
  void clear_chunk_handles();
  private:
  int64_t _internal_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_chunk_handles() const;
  void _internal_add_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_chunk_handles();
  public:
  int64_t chunk_handles(int index) const;
  void set_chunk_handles(int index, int64_t value);
  void add_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_chunk_handles();

  // repeated .GetWriteAddrReply.ReplicaAddrs addrs = 2;
  int addrs_size() const;
  private:
  int _internal_addrs_size() const;
  public:
  void clear_addrs();
  ::GetWriteAddrReply_ReplicaAddrs* mutable_addrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetWriteAddrReply_ReplicaAddrs >*
      mutable_addrs();
  private:
  const ::GetWriteAddrReply_ReplicaAddrs& _internal_addrs(int index) const;
  ::GetWriteAddrReply_ReplicaAddrs* _internal_add_addrs();
  public:
  const ::GetWriteAddrReply_ReplicaAddrs& addrs(int index) const;
  ::GetWriteAddrReply_ReplicaAddrs* add_addrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetWriteAddrReply_ReplicaAddrs >&
      addrs() const;

  // @@protoc_insertion_point(class_scope:GetWriteAddrReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > chunk_handles_;
  mutable std::atomic<int> _chunk_handles_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetWriteAddrReply_ReplicaAddrs > addrs_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class GetSubDirPathsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetSubDirPathsRequest) */ {
 public:
  inline GetSubDirPathsRequest() : GetSubDirPathsRequest(nullptr) {}
  ~GetSubDirPathsRequest() override;
  explicit constexpr GetSubDirPathsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubDirPathsRequest(const GetSubDirPathsRequest& from);
  GetSubDirPathsRequest(GetSubDirPathsRequest&& from) noexcept
    : GetSubDirPathsRequest() {
    *this = ::std::move(from);
  }

  inline GetSubDirPathsRequest& operator=(const GetSubDirPathsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubDirPathsRequest& operator=(GetSubDirPathsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubDirPathsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubDirPathsRequest* internal_default_instance() {
    return reinterpret_cast<const GetSubDirPathsRequest*>(
               &_GetSubDirPathsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GetSubDirPathsRequest& a, GetSubDirPathsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubDirPathsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubDirPathsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubDirPathsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubDirPathsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubDirPathsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSubDirPathsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubDirPathsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetSubDirPathsRequest";
  }
  protected:
  explicit GetSubDirPathsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
  };
  // string file_path = 1;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // @@protoc_insertion_point(class_scope:GetSubDirPathsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class GetSubDirPathsReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetSubDirPathsReply) */ {
 public:
  inline GetSubDirPathsReply() : GetSubDirPathsReply(nullptr) {}
  ~GetSubDirPathsReply() override;
  explicit constexpr GetSubDirPathsReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetSubDirPathsReply(const GetSubDirPathsReply& from);
  GetSubDirPathsReply(GetSubDirPathsReply&& from) noexcept
    : GetSubDirPathsReply() {
    *this = ::std::move(from);
  }

  inline GetSubDirPathsReply& operator=(const GetSubDirPathsReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetSubDirPathsReply& operator=(GetSubDirPathsReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetSubDirPathsReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetSubDirPathsReply* internal_default_instance() {
    return reinterpret_cast<const GetSubDirPathsReply*>(
               &_GetSubDirPathsReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetSubDirPathsReply& a, GetSubDirPathsReply& b) {
    a.Swap(&b);
  }
  inline void Swap(GetSubDirPathsReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetSubDirPathsReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetSubDirPathsReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetSubDirPathsReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetSubDirPathsReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetSubDirPathsReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetSubDirPathsReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetSubDirPathsReply";
  }
  protected:
  explicit GetSubDirPathsReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSubdirFilePathsFieldNumber = 1,
  };
  // repeated string subdir_file_paths = 1;
  int subdir_file_paths_size() const;
  private:
  int _internal_subdir_file_paths_size() const;
  public:
  void clear_subdir_file_paths();
  const std::string& subdir_file_paths(int index) const;
  std::string* mutable_subdir_file_paths(int index);
  void set_subdir_file_paths(int index, const std::string& value);
  void set_subdir_file_paths(int index, std::string&& value);
  void set_subdir_file_paths(int index, const char* value);
  void set_subdir_file_paths(int index, const char* value, size_t size);
  std::string* add_subdir_file_paths();
  void add_subdir_file_paths(const std::string& value);
  void add_subdir_file_paths(std::string&& value);
  void add_subdir_file_paths(const char* value);
  void add_subdir_file_paths(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& subdir_file_paths() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_subdir_file_paths();
  private:
  const std::string& _internal_subdir_file_paths(int index) const;
  std::string* _internal_add_subdir_file_paths();
  public:

  // @@protoc_insertion_point(class_scope:GetSubDirPathsReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> subdir_file_paths_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class MkdirRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:MkdirRequest) */ {
 public:
  inline MkdirRequest() : MkdirRequest(nullptr) {}
  ~MkdirRequest() override;
  explicit constexpr MkdirRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirRequest(const MkdirRequest& from);
  MkdirRequest(MkdirRequest&& from) noexcept
    : MkdirRequest() {
    *this = ::std::move(from);
  }

  inline MkdirRequest& operator=(const MkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirRequest& operator=(MkdirRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirRequest* internal_default_instance() {
    return reinterpret_cast<const MkdirRequest*>(
               &_MkdirRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(MkdirRequest& a, MkdirRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MkdirRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const MkdirRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MkdirRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MkdirRequest";
  }
  protected:
  explicit MkdirRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewFilePathFieldNumber = 1,
  };
  // string new_file_path = 1;
  void clear_new_file_path();
  const std::string& new_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_file_path();
  PROTOBUF_NODISCARD std::string* release_new_file_path();
  void set_allocated_new_file_path(std::string* new_file_path);
  private:
  const std::string& _internal_new_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_file_path(const std::string& value);
  std::string* _internal_mutable_new_file_path();
  public:

  // @@protoc_insertion_point(class_scope:MkdirRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_file_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class MkdirReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:MkdirReply) */ {
 public:
  inline MkdirReply() : MkdirReply(nullptr) {}
  explicit constexpr MkdirReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MkdirReply(const MkdirReply& from);
  MkdirReply(MkdirReply&& from) noexcept
    : MkdirReply() {
    *this = ::std::move(from);
  }

  inline MkdirReply& operator=(const MkdirReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline MkdirReply& operator=(MkdirReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MkdirReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const MkdirReply* internal_default_instance() {
    return reinterpret_cast<const MkdirReply*>(
               &_MkdirReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(MkdirReply& a, MkdirReply& b) {
    a.Swap(&b);
  }
  inline void Swap(MkdirReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MkdirReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MkdirReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MkdirReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const MkdirReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const MkdirReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "MkdirReply";
  }
  protected:
  explicit MkdirReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:MkdirReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class RenameRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RenameRequest) */ {
 public:
  inline RenameRequest() : RenameRequest(nullptr) {}
  ~RenameRequest() override;
  explicit constexpr RenameRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameRequest(const RenameRequest& from);
  RenameRequest(RenameRequest&& from) noexcept
    : RenameRequest() {
    *this = ::std::move(from);
  }

  inline RenameRequest& operator=(const RenameRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameRequest& operator=(RenameRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameRequest* internal_default_instance() {
    return reinterpret_cast<const RenameRequest*>(
               &_RenameRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RenameRequest& a, RenameRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RenameRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RenameRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RenameRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RenameRequest";
  }
  protected:
  explicit RenameRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcPathFieldNumber = 1,
    kDesPathFieldNumber = 2,
  };
  // string src_path = 1;
  void clear_src_path();
  const std::string& src_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_src_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_src_path();
  PROTOBUF_NODISCARD std::string* release_src_path();
  void set_allocated_src_path(std::string* src_path);
  private:
  const std::string& _internal_src_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_src_path(const std::string& value);
  std::string* _internal_mutable_src_path();
  public:

  // string des_path = 2;
  void clear_des_path();
  const std::string& des_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_des_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_des_path();
  PROTOBUF_NODISCARD std::string* release_des_path();
  void set_allocated_des_path(std::string* des_path);
  private:
  const std::string& _internal_des_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_des_path(const std::string& value);
  std::string* _internal_mutable_des_path();
  public:

  // @@protoc_insertion_point(class_scope:RenameRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr src_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr des_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class RenameReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RenameReply) */ {
 public:
  inline RenameReply() : RenameReply(nullptr) {}
  explicit constexpr RenameReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RenameReply(const RenameReply& from);
  RenameReply(RenameReply&& from) noexcept
    : RenameReply() {
    *this = ::std::move(from);
  }

  inline RenameReply& operator=(const RenameReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline RenameReply& operator=(RenameReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RenameReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const RenameReply* internal_default_instance() {
    return reinterpret_cast<const RenameReply*>(
               &_RenameReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(RenameReply& a, RenameReply& b) {
    a.Swap(&b);
  }
  inline void Swap(RenameReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RenameReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RenameReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RenameReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const RenameReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const RenameReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RenameReply";
  }
  protected:
  explicit RenameReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RenameReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class DeleteRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:DeleteRequest) */ {
 public:
  inline DeleteRequest() : DeleteRequest(nullptr) {}
  ~DeleteRequest() override;
  explicit constexpr DeleteRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteRequest(const DeleteRequest& from);
  DeleteRequest(DeleteRequest&& from) noexcept
    : DeleteRequest() {
    *this = ::std::move(from);
  }

  inline DeleteRequest& operator=(const DeleteRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteRequest& operator=(DeleteRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteRequest*>(
               &_DeleteRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(DeleteRequest& a, DeleteRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DeleteRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeleteRequest";
  }
  protected:
  explicit DeleteRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRemoteFilePathFieldNumber = 1,
  };
  // string remote_file_path = 1;
  void clear_remote_file_path();
  const std::string& remote_file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_remote_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_remote_file_path();
  PROTOBUF_NODISCARD std::string* release_remote_file_path();
  void set_allocated_remote_file_path(std::string* remote_file_path);
  private:
  const std::string& _internal_remote_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_remote_file_path(const std::string& value);
  std::string* _internal_mutable_remote_file_path();
  public:

  // @@protoc_insertion_point(class_scope:DeleteRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr remote_file_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class DeleteReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:DeleteReply) */ {
 public:
  inline DeleteReply() : DeleteReply(nullptr) {}
  explicit constexpr DeleteReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteReply(const DeleteReply& from);
  DeleteReply(DeleteReply&& from) noexcept
    : DeleteReply() {
    *this = ::std::move(from);
  }

  inline DeleteReply& operator=(const DeleteReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteReply& operator=(DeleteReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteReply* internal_default_instance() {
    return reinterpret_cast<const DeleteReply*>(
               &_DeleteReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(DeleteReply& a, DeleteReply& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const DeleteReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const DeleteReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "DeleteReply";
  }
  protected:
  explicit DeleteReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:DeleteReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class StatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatRequest) */ {
 public:
  inline StatRequest() : StatRequest(nullptr) {}
  ~StatRequest() override;
  explicit constexpr StatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatRequest(const StatRequest& from);
  StatRequest(StatRequest&& from) noexcept
    : StatRequest() {
    *this = ::std::move(from);
  }

  inline StatRequest& operator=(const StatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatRequest& operator=(StatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatRequest* internal_default_instance() {
    return reinterpret_cast<const StatRequest*>(
               &_StatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StatRequest& a, StatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatRequest";
  }
  protected:
  explicit StatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 1,
  };
  // string file_path = 1;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // @@protoc_insertion_point(class_scope:StatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class StatReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StatReply) */ {
 public:
  inline StatReply() : StatReply(nullptr) {}
  ~StatReply() override;
  explicit constexpr StatReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StatReply(const StatReply& from);
  StatReply(StatReply&& from) noexcept
    : StatReply() {
    *this = ::std::move(from);
  }

  inline StatReply& operator=(const StatReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline StatReply& operator=(StatReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StatReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const StatReply* internal_default_instance() {
    return reinterpret_cast<const StatReply*>(
               &_StatReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StatReply& a, StatReply& b) {
    a.Swap(&b);
  }
  inline void Swap(StatReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StatReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StatReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StatReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StatReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StatReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StatReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StatReply";
  }
  protected:
  explicit StatReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilePathFieldNumber = 2,
    kFileSizeFieldNumber = 3,
    kExistedFieldNumber = 1,
  };
  // string file_path = 2;
  void clear_file_path();
  const std::string& file_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_path();
  PROTOBUF_NODISCARD std::string* release_file_path();
  void set_allocated_file_path(std::string* file_path);
  private:
  const std::string& _internal_file_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_path(const std::string& value);
  std::string* _internal_mutable_file_path();
  public:

  // uint64 file_size = 3;
  void clear_file_size();
  uint64_t file_size() const;
  void set_file_size(uint64_t value);
  private:
  uint64_t _internal_file_size() const;
  void _internal_set_file_size(uint64_t value);
  public:

  // bool existed = 1;
  void clear_existed();
  bool existed() const;
  void set_existed(bool value);
  private:
  bool _internal_existed() const;
  void _internal_set_existed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StatReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_path_;
  uint64_t file_size_;
  bool existed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class WriteChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteChunkRequest) */ {
 public:
  inline WriteChunkRequest() : WriteChunkRequest(nullptr) {}
  ~WriteChunkRequest() override;
  explicit constexpr WriteChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteChunkRequest(const WriteChunkRequest& from);
  WriteChunkRequest(WriteChunkRequest&& from) noexcept
    : WriteChunkRequest() {
    *this = ::std::move(from);
  }

  inline WriteChunkRequest& operator=(const WriteChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteChunkRequest& operator=(WriteChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteChunkRequest* internal_default_instance() {
    return reinterpret_cast<const WriteChunkRequest*>(
               &_WriteChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(WriteChunkRequest& a, WriteChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteChunkRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteChunkRequest";
  }
  protected:
  explicit WriteChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 4,
    kChunkhandleFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // string data = 4;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 chunkhandle = 1;
  void clear_chunkhandle();
  int64_t chunkhandle() const;
  void set_chunkhandle(int64_t value);
  private:
  int64_t _internal_chunkhandle() const;
  void _internal_set_chunkhandle(int64_t value);
  public:

  // int64 offset = 2;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 length = 3;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:WriteChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int64_t chunkhandle_;
  int64_t offset_;
  int64_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class WriteChunkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:WriteChunkReply) */ {
 public:
  inline WriteChunkReply() : WriteChunkReply(nullptr) {}
  ~WriteChunkReply() override;
  explicit constexpr WriteChunkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WriteChunkReply(const WriteChunkReply& from);
  WriteChunkReply(WriteChunkReply&& from) noexcept
    : WriteChunkReply() {
    *this = ::std::move(from);
  }

  inline WriteChunkReply& operator=(const WriteChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline WriteChunkReply& operator=(WriteChunkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WriteChunkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const WriteChunkReply* internal_default_instance() {
    return reinterpret_cast<const WriteChunkReply*>(
               &_WriteChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(WriteChunkReply& a, WriteChunkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(WriteChunkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WriteChunkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WriteChunkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WriteChunkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WriteChunkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const WriteChunkReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WriteChunkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "WriteChunkReply";
  }
  protected:
  explicit WriteChunkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBytesWriteFieldNumber = 1,
  };
  // int64 bytes_write = 1;
  void clear_bytes_write();
  int64_t bytes_write() const;
  void set_bytes_write(int64_t value);
  private:
  int64_t _internal_bytes_write() const;
  void _internal_set_bytes_write(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:WriteChunkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t bytes_write_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class ReadChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadChunkRequest) */ {
 public:
  inline ReadChunkRequest() : ReadChunkRequest(nullptr) {}
  ~ReadChunkRequest() override;
  explicit constexpr ReadChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadChunkRequest(const ReadChunkRequest& from);
  ReadChunkRequest(ReadChunkRequest&& from) noexcept
    : ReadChunkRequest() {
    *this = ::std::move(from);
  }

  inline ReadChunkRequest& operator=(const ReadChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadChunkRequest& operator=(ReadChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadChunkRequest* internal_default_instance() {
    return reinterpret_cast<const ReadChunkRequest*>(
               &_ReadChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(ReadChunkRequest& a, ReadChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadChunkRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadChunkRequest";
  }
  protected:
  explicit ReadChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkhandleFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kLengthFieldNumber = 3,
  };
  // int64 chunkhandle = 1;
  void clear_chunkhandle();
  int64_t chunkhandle() const;
  void set_chunkhandle(int64_t value);
  private:
  int64_t _internal_chunkhandle() const;
  void _internal_set_chunkhandle(int64_t value);
  public:

  // int64 offset = 2;
  void clear_offset();
  int64_t offset() const;
  void set_offset(int64_t value);
  private:
  int64_t _internal_offset() const;
  void _internal_set_offset(int64_t value);
  public:

  // int64 length = 3;
  void clear_length();
  int64_t length() const;
  void set_length(int64_t value);
  private:
  int64_t _internal_length() const;
  void _internal_set_length(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReadChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int64_t chunkhandle_;
  int64_t offset_;
  int64_t length_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// -------------------------------------------------------------------

class ReadChunkReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ReadChunkReply) */ {
 public:
  inline ReadChunkReply() : ReadChunkReply(nullptr) {}
  ~ReadChunkReply() override;
  explicit constexpr ReadChunkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReadChunkReply(const ReadChunkReply& from);
  ReadChunkReply(ReadChunkReply&& from) noexcept
    : ReadChunkReply() {
    *this = ::std::move(from);
  }

  inline ReadChunkReply& operator=(const ReadChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReadChunkReply& operator=(ReadChunkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReadChunkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReadChunkReply* internal_default_instance() {
    return reinterpret_cast<const ReadChunkReply*>(
               &_ReadChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(ReadChunkReply& a, ReadChunkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ReadChunkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReadChunkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReadChunkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReadChunkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReadChunkReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReadChunkReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReadChunkReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ReadChunkReply";
  }
  protected:
  explicit ReadChunkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kBytesReadFieldNumber = 2,
  };
  // string data = 1;
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // int64 bytes_read = 2;
  void clear_bytes_read();
  int64_t bytes_read() const;
  void set_bytes_read(int64_t value);
  private:
  int64_t _internal_bytes_read() const;
  void _internal_set_bytes_read(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:ReadChunkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int64_t bytes_read_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_cli2ser_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// FindAddrRequest

// string file_path = 1;
inline void FindAddrRequest::clear_file_path() {
  file_path_.ClearToEmpty();
}
inline const std::string& FindAddrRequest::file_path() const {
  // @@protoc_insertion_point(field_get:FindAddrRequest.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FindAddrRequest::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FindAddrRequest.file_path)
}
inline std::string* FindAddrRequest::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:FindAddrRequest.file_path)
  return _s;
}
inline const std::string& FindAddrRequest::_internal_file_path() const {
  return file_path_.Get();
}
inline void FindAddrRequest::_internal_set_file_path(const std::string& value) {
  
  file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FindAddrRequest::_internal_mutable_file_path() {
  
  return file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FindAddrRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:FindAddrRequest.file_path)
  return file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FindAddrRequest::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:FindAddrRequest.file_path)
}

// -------------------------------------------------------------------

// FindAddrReply_ReplicaAddrs

// repeated string ip_ports = 1;
inline int FindAddrReply_ReplicaAddrs::_internal_ip_ports_size() const {
  return ip_ports_.size();
}
inline int FindAddrReply_ReplicaAddrs::ip_ports_size() const {
  return _internal_ip_ports_size();
}
inline void FindAddrReply_ReplicaAddrs::clear_ip_ports() {
  ip_ports_.Clear();
}
inline std::string* FindAddrReply_ReplicaAddrs::add_ip_ports() {
  std::string* _s = _internal_add_ip_ports();
  // @@protoc_insertion_point(field_add_mutable:FindAddrReply.ReplicaAddrs.ip_ports)
  return _s;
}
inline const std::string& FindAddrReply_ReplicaAddrs::_internal_ip_ports(int index) const {
  return ip_ports_.Get(index);
}
inline const std::string& FindAddrReply_ReplicaAddrs::ip_ports(int index) const {
  // @@protoc_insertion_point(field_get:FindAddrReply.ReplicaAddrs.ip_ports)
  return _internal_ip_ports(index);
}
inline std::string* FindAddrReply_ReplicaAddrs::mutable_ip_ports(int index) {
  // @@protoc_insertion_point(field_mutable:FindAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Mutable(index);
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const std::string& value) {
  ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, std::string&& value) {
  ip_ports_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value, size_t size) {
  ip_ports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline std::string* FindAddrReply_ReplicaAddrs::_internal_add_ip_ports() {
  return ip_ports_.Add();
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const std::string& value) {
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(std::string&& value) {
  ip_ports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline void FindAddrReply_ReplicaAddrs::add_ip_ports(const char* value, size_t size) {
  ip_ports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:FindAddrReply.ReplicaAddrs.ip_ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
FindAddrReply_ReplicaAddrs::ip_ports() const {
  // @@protoc_insertion_point(field_list:FindAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
FindAddrReply_ReplicaAddrs::mutable_ip_ports() {
  // @@protoc_insertion_point(field_mutable_list:FindAddrReply.ReplicaAddrs.ip_ports)
  return &ip_ports_;
}

// -------------------------------------------------------------------

// FindAddrReply

// repeated int64 chunk_handles = 1;
inline int FindAddrReply::_internal_chunk_handles_size() const {
  return chunk_handles_.size();
}
inline int FindAddrReply::chunk_handles_size() const {
  return _internal_chunk_handles_size();
}
inline void FindAddrReply::clear_chunk_handles() {
  chunk_handles_.Clear();
}
inline int64_t FindAddrReply::_internal_chunk_handles(int index) const {
  return chunk_handles_.Get(index);
}
inline int64_t FindAddrReply::chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:FindAddrReply.chunk_handles)
  return _internal_chunk_handles(index);
}
inline void FindAddrReply::set_chunk_handles(int index, int64_t value) {
  chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:FindAddrReply.chunk_handles)
}
inline void FindAddrReply::_internal_add_chunk_handles(int64_t value) {
  chunk_handles_.Add(value);
}
inline void FindAddrReply::add_chunk_handles(int64_t value) {
  _internal_add_chunk_handles(value);
  // @@protoc_insertion_point(field_add:FindAddrReply.chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
FindAddrReply::_internal_chunk_handles() const {
  return chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
FindAddrReply::chunk_handles() const {
  // @@protoc_insertion_point(field_list:FindAddrReply.chunk_handles)
  return _internal_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
FindAddrReply::_internal_mutable_chunk_handles() {
  return &chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
FindAddrReply::mutable_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:FindAddrReply.chunk_handles)
  return _internal_mutable_chunk_handles();
}

// repeated .FindAddrReply.ReplicaAddrs addrs = 2;
inline int FindAddrReply::_internal_addrs_size() const {
  return addrs_.size();
}
inline int FindAddrReply::addrs_size() const {
  return _internal_addrs_size();
}
inline void FindAddrReply::clear_addrs() {
  addrs_.Clear();
}
inline ::FindAddrReply_ReplicaAddrs* FindAddrReply::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:FindAddrReply.addrs)
  return addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FindAddrReply_ReplicaAddrs >*
FindAddrReply::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:FindAddrReply.addrs)
  return &addrs_;
}
inline const ::FindAddrReply_ReplicaAddrs& FindAddrReply::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const ::FindAddrReply_ReplicaAddrs& FindAddrReply::addrs(int index) const {
  // @@protoc_insertion_point(field_get:FindAddrReply.addrs)
  return _internal_addrs(index);
}
inline ::FindAddrReply_ReplicaAddrs* FindAddrReply::_internal_add_addrs() {
  return addrs_.Add();
}
inline ::FindAddrReply_ReplicaAddrs* FindAddrReply::add_addrs() {
  ::FindAddrReply_ReplicaAddrs* _add = _internal_add_addrs();
  // @@protoc_insertion_point(field_add:FindAddrReply.addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::FindAddrReply_ReplicaAddrs >&
FindAddrReply::addrs() const {
  // @@protoc_insertion_point(field_list:FindAddrReply.addrs)
  return addrs_;
}

// -------------------------------------------------------------------

// GetWriteAddrRequest

// string remote_file_path = 1;
inline void GetWriteAddrRequest::clear_remote_file_path() {
  remote_file_path_.ClearToEmpty();
}
inline const std::string& GetWriteAddrRequest::remote_file_path() const {
  // @@protoc_insertion_point(field_get:GetWriteAddrRequest.remote_file_path)
  return _internal_remote_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetWriteAddrRequest::set_remote_file_path(ArgT0&& arg0, ArgT... args) {
 
 remote_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetWriteAddrRequest.remote_file_path)
}
inline std::string* GetWriteAddrRequest::mutable_remote_file_path() {
  std::string* _s = _internal_mutable_remote_file_path();
  // @@protoc_insertion_point(field_mutable:GetWriteAddrRequest.remote_file_path)
  return _s;
}
inline const std::string& GetWriteAddrRequest::_internal_remote_file_path() const {
  return remote_file_path_.Get();
}
inline void GetWriteAddrRequest::_internal_set_remote_file_path(const std::string& value) {
  
  remote_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetWriteAddrRequest::_internal_mutable_remote_file_path() {
  
  return remote_file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetWriteAddrRequest::release_remote_file_path() {
  // @@protoc_insertion_point(field_release:GetWriteAddrRequest.remote_file_path)
  return remote_file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetWriteAddrRequest::set_allocated_remote_file_path(std::string* remote_file_path) {
  if (remote_file_path != nullptr) {
    
  } else {
    
  }
  remote_file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetWriteAddrRequest.remote_file_path)
}

// int64 write_data_size = 2;
inline void GetWriteAddrRequest::clear_write_data_size() {
  write_data_size_ = int64_t{0};
}
inline int64_t GetWriteAddrRequest::_internal_write_data_size() const {
  return write_data_size_;
}
inline int64_t GetWriteAddrRequest::write_data_size() const {
  // @@protoc_insertion_point(field_get:GetWriteAddrRequest.write_data_size)
  return _internal_write_data_size();
}
inline void GetWriteAddrRequest::_internal_set_write_data_size(int64_t value) {
  
  write_data_size_ = value;
}
inline void GetWriteAddrRequest::set_write_data_size(int64_t value) {
  _internal_set_write_data_size(value);
  // @@protoc_insertion_point(field_set:GetWriteAddrRequest.write_data_size)
}

// -------------------------------------------------------------------

// GetWriteAddrReply_ReplicaAddrs

// repeated string ip_ports = 1;
inline int GetWriteAddrReply_ReplicaAddrs::_internal_ip_ports_size() const {
  return ip_ports_.size();
}
inline int GetWriteAddrReply_ReplicaAddrs::ip_ports_size() const {
  return _internal_ip_ports_size();
}
inline void GetWriteAddrReply_ReplicaAddrs::clear_ip_ports() {
  ip_ports_.Clear();
}
inline std::string* GetWriteAddrReply_ReplicaAddrs::add_ip_ports() {
  std::string* _s = _internal_add_ip_ports();
  // @@protoc_insertion_point(field_add_mutable:GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return _s;
}
inline const std::string& GetWriteAddrReply_ReplicaAddrs::_internal_ip_ports(int index) const {
  return ip_ports_.Get(index);
}
inline const std::string& GetWriteAddrReply_ReplicaAddrs::ip_ports(int index) const {
  // @@protoc_insertion_point(field_get:GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return _internal_ip_ports(index);
}
inline std::string* GetWriteAddrReply_ReplicaAddrs::mutable_ip_ports(int index) {
  // @@protoc_insertion_point(field_mutable:GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_.Mutable(index);
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const std::string& value) {
  ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, std::string&& value) {
  ip_ports_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_ports_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::set_ip_ports(int index, const char* value, size_t size) {
  ip_ports_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline std::string* GetWriteAddrReply_ReplicaAddrs::_internal_add_ip_ports() {
  return ip_ports_.Add();
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const std::string& value) {
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(std::string&& value) {
  ip_ports_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_ports_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline void GetWriteAddrReply_ReplicaAddrs::add_ip_ports(const char* value, size_t size) {
  ip_ports_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GetWriteAddrReply.ReplicaAddrs.ip_ports)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetWriteAddrReply_ReplicaAddrs::ip_ports() const {
  // @@protoc_insertion_point(field_list:GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return ip_ports_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetWriteAddrReply_ReplicaAddrs::mutable_ip_ports() {
  // @@protoc_insertion_point(field_mutable_list:GetWriteAddrReply.ReplicaAddrs.ip_ports)
  return &ip_ports_;
}

// -------------------------------------------------------------------

// GetWriteAddrReply

// repeated int64 chunk_handles = 1;
inline int GetWriteAddrReply::_internal_chunk_handles_size() const {
  return chunk_handles_.size();
}
inline int GetWriteAddrReply::chunk_handles_size() const {
  return _internal_chunk_handles_size();
}
inline void GetWriteAddrReply::clear_chunk_handles() {
  chunk_handles_.Clear();
}
inline int64_t GetWriteAddrReply::_internal_chunk_handles(int index) const {
  return chunk_handles_.Get(index);
}
inline int64_t GetWriteAddrReply::chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:GetWriteAddrReply.chunk_handles)
  return _internal_chunk_handles(index);
}
inline void GetWriteAddrReply::set_chunk_handles(int index, int64_t value) {
  chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:GetWriteAddrReply.chunk_handles)
}
inline void GetWriteAddrReply::_internal_add_chunk_handles(int64_t value) {
  chunk_handles_.Add(value);
}
inline void GetWriteAddrReply::add_chunk_handles(int64_t value) {
  _internal_add_chunk_handles(value);
  // @@protoc_insertion_point(field_add:GetWriteAddrReply.chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
GetWriteAddrReply::_internal_chunk_handles() const {
  return chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
GetWriteAddrReply::chunk_handles() const {
  // @@protoc_insertion_point(field_list:GetWriteAddrReply.chunk_handles)
  return _internal_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
GetWriteAddrReply::_internal_mutable_chunk_handles() {
  return &chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
GetWriteAddrReply::mutable_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:GetWriteAddrReply.chunk_handles)
  return _internal_mutable_chunk_handles();
}

// repeated .GetWriteAddrReply.ReplicaAddrs addrs = 2;
inline int GetWriteAddrReply::_internal_addrs_size() const {
  return addrs_.size();
}
inline int GetWriteAddrReply::addrs_size() const {
  return _internal_addrs_size();
}
inline void GetWriteAddrReply::clear_addrs() {
  addrs_.Clear();
}
inline ::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::mutable_addrs(int index) {
  // @@protoc_insertion_point(field_mutable:GetWriteAddrReply.addrs)
  return addrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetWriteAddrReply_ReplicaAddrs >*
GetWriteAddrReply::mutable_addrs() {
  // @@protoc_insertion_point(field_mutable_list:GetWriteAddrReply.addrs)
  return &addrs_;
}
inline const ::GetWriteAddrReply_ReplicaAddrs& GetWriteAddrReply::_internal_addrs(int index) const {
  return addrs_.Get(index);
}
inline const ::GetWriteAddrReply_ReplicaAddrs& GetWriteAddrReply::addrs(int index) const {
  // @@protoc_insertion_point(field_get:GetWriteAddrReply.addrs)
  return _internal_addrs(index);
}
inline ::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::_internal_add_addrs() {
  return addrs_.Add();
}
inline ::GetWriteAddrReply_ReplicaAddrs* GetWriteAddrReply::add_addrs() {
  ::GetWriteAddrReply_ReplicaAddrs* _add = _internal_add_addrs();
  // @@protoc_insertion_point(field_add:GetWriteAddrReply.addrs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetWriteAddrReply_ReplicaAddrs >&
GetWriteAddrReply::addrs() const {
  // @@protoc_insertion_point(field_list:GetWriteAddrReply.addrs)
  return addrs_;
}

// -------------------------------------------------------------------

// GetSubDirPathsRequest

// string file_path = 1;
inline void GetSubDirPathsRequest::clear_file_path() {
  file_path_.ClearToEmpty();
}
inline const std::string& GetSubDirPathsRequest::file_path() const {
  // @@protoc_insertion_point(field_get:GetSubDirPathsRequest.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetSubDirPathsRequest::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetSubDirPathsRequest.file_path)
}
inline std::string* GetSubDirPathsRequest::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:GetSubDirPathsRequest.file_path)
  return _s;
}
inline const std::string& GetSubDirPathsRequest::_internal_file_path() const {
  return file_path_.Get();
}
inline void GetSubDirPathsRequest::_internal_set_file_path(const std::string& value) {
  
  file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetSubDirPathsRequest::_internal_mutable_file_path() {
  
  return file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetSubDirPathsRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:GetSubDirPathsRequest.file_path)
  return file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetSubDirPathsRequest::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetSubDirPathsRequest.file_path)
}

// -------------------------------------------------------------------

// GetSubDirPathsReply

// repeated string subdir_file_paths = 1;
inline int GetSubDirPathsReply::_internal_subdir_file_paths_size() const {
  return subdir_file_paths_.size();
}
inline int GetSubDirPathsReply::subdir_file_paths_size() const {
  return _internal_subdir_file_paths_size();
}
inline void GetSubDirPathsReply::clear_subdir_file_paths() {
  subdir_file_paths_.Clear();
}
inline std::string* GetSubDirPathsReply::add_subdir_file_paths() {
  std::string* _s = _internal_add_subdir_file_paths();
  // @@protoc_insertion_point(field_add_mutable:GetSubDirPathsReply.subdir_file_paths)
  return _s;
}
inline const std::string& GetSubDirPathsReply::_internal_subdir_file_paths(int index) const {
  return subdir_file_paths_.Get(index);
}
inline const std::string& GetSubDirPathsReply::subdir_file_paths(int index) const {
  // @@protoc_insertion_point(field_get:GetSubDirPathsReply.subdir_file_paths)
  return _internal_subdir_file_paths(index);
}
inline std::string* GetSubDirPathsReply::mutable_subdir_file_paths(int index) {
  // @@protoc_insertion_point(field_mutable:GetSubDirPathsReply.subdir_file_paths)
  return subdir_file_paths_.Mutable(index);
}
inline void GetSubDirPathsReply::set_subdir_file_paths(int index, const std::string& value) {
  subdir_file_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:GetSubDirPathsReply.subdir_file_paths)
}
inline void GetSubDirPathsReply::set_subdir_file_paths(int index, std::string&& value) {
  subdir_file_paths_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:GetSubDirPathsReply.subdir_file_paths)
}
inline void GetSubDirPathsReply::set_subdir_file_paths(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  subdir_file_paths_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:GetSubDirPathsReply.subdir_file_paths)
}
inline void GetSubDirPathsReply::set_subdir_file_paths(int index, const char* value, size_t size) {
  subdir_file_paths_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:GetSubDirPathsReply.subdir_file_paths)
}
inline std::string* GetSubDirPathsReply::_internal_add_subdir_file_paths() {
  return subdir_file_paths_.Add();
}
inline void GetSubDirPathsReply::add_subdir_file_paths(const std::string& value) {
  subdir_file_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:GetSubDirPathsReply.subdir_file_paths)
}
inline void GetSubDirPathsReply::add_subdir_file_paths(std::string&& value) {
  subdir_file_paths_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:GetSubDirPathsReply.subdir_file_paths)
}
inline void GetSubDirPathsReply::add_subdir_file_paths(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  subdir_file_paths_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:GetSubDirPathsReply.subdir_file_paths)
}
inline void GetSubDirPathsReply::add_subdir_file_paths(const char* value, size_t size) {
  subdir_file_paths_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:GetSubDirPathsReply.subdir_file_paths)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetSubDirPathsReply::subdir_file_paths() const {
  // @@protoc_insertion_point(field_list:GetSubDirPathsReply.subdir_file_paths)
  return subdir_file_paths_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetSubDirPathsReply::mutable_subdir_file_paths() {
  // @@protoc_insertion_point(field_mutable_list:GetSubDirPathsReply.subdir_file_paths)
  return &subdir_file_paths_;
}

// -------------------------------------------------------------------

// MkdirRequest

// string new_file_path = 1;
inline void MkdirRequest::clear_new_file_path() {
  new_file_path_.ClearToEmpty();
}
inline const std::string& MkdirRequest::new_file_path() const {
  // @@protoc_insertion_point(field_get:MkdirRequest.new_file_path)
  return _internal_new_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void MkdirRequest::set_new_file_path(ArgT0&& arg0, ArgT... args) {
 
 new_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:MkdirRequest.new_file_path)
}
inline std::string* MkdirRequest::mutable_new_file_path() {
  std::string* _s = _internal_mutable_new_file_path();
  // @@protoc_insertion_point(field_mutable:MkdirRequest.new_file_path)
  return _s;
}
inline const std::string& MkdirRequest::_internal_new_file_path() const {
  return new_file_path_.Get();
}
inline void MkdirRequest::_internal_set_new_file_path(const std::string& value) {
  
  new_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* MkdirRequest::_internal_mutable_new_file_path() {
  
  return new_file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* MkdirRequest::release_new_file_path() {
  // @@protoc_insertion_point(field_release:MkdirRequest.new_file_path)
  return new_file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void MkdirRequest::set_allocated_new_file_path(std::string* new_file_path) {
  if (new_file_path != nullptr) {
    
  } else {
    
  }
  new_file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:MkdirRequest.new_file_path)
}

// -------------------------------------------------------------------

// MkdirReply

// -------------------------------------------------------------------

// RenameRequest

// string src_path = 1;
inline void RenameRequest::clear_src_path() {
  src_path_.ClearToEmpty();
}
inline const std::string& RenameRequest::src_path() const {
  // @@protoc_insertion_point(field_get:RenameRequest.src_path)
  return _internal_src_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_src_path(ArgT0&& arg0, ArgT... args) {
 
 src_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameRequest.src_path)
}
inline std::string* RenameRequest::mutable_src_path() {
  std::string* _s = _internal_mutable_src_path();
  // @@protoc_insertion_point(field_mutable:RenameRequest.src_path)
  return _s;
}
inline const std::string& RenameRequest::_internal_src_path() const {
  return src_path_.Get();
}
inline void RenameRequest::_internal_set_src_path(const std::string& value) {
  
  src_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_src_path() {
  
  return src_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameRequest::release_src_path() {
  // @@protoc_insertion_point(field_release:RenameRequest.src_path)
  return src_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameRequest::set_allocated_src_path(std::string* src_path) {
  if (src_path != nullptr) {
    
  } else {
    
  }
  src_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), src_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (src_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    src_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameRequest.src_path)
}

// string des_path = 2;
inline void RenameRequest::clear_des_path() {
  des_path_.ClearToEmpty();
}
inline const std::string& RenameRequest::des_path() const {
  // @@protoc_insertion_point(field_get:RenameRequest.des_path)
  return _internal_des_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RenameRequest::set_des_path(ArgT0&& arg0, ArgT... args) {
 
 des_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RenameRequest.des_path)
}
inline std::string* RenameRequest::mutable_des_path() {
  std::string* _s = _internal_mutable_des_path();
  // @@protoc_insertion_point(field_mutable:RenameRequest.des_path)
  return _s;
}
inline const std::string& RenameRequest::_internal_des_path() const {
  return des_path_.Get();
}
inline void RenameRequest::_internal_set_des_path(const std::string& value) {
  
  des_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RenameRequest::_internal_mutable_des_path() {
  
  return des_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RenameRequest::release_des_path() {
  // @@protoc_insertion_point(field_release:RenameRequest.des_path)
  return des_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RenameRequest::set_allocated_des_path(std::string* des_path) {
  if (des_path != nullptr) {
    
  } else {
    
  }
  des_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), des_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (des_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    des_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RenameRequest.des_path)
}

// -------------------------------------------------------------------

// RenameReply

// -------------------------------------------------------------------

// DeleteRequest

// string remote_file_path = 1;
inline void DeleteRequest::clear_remote_file_path() {
  remote_file_path_.ClearToEmpty();
}
inline const std::string& DeleteRequest::remote_file_path() const {
  // @@protoc_insertion_point(field_get:DeleteRequest.remote_file_path)
  return _internal_remote_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DeleteRequest::set_remote_file_path(ArgT0&& arg0, ArgT... args) {
 
 remote_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:DeleteRequest.remote_file_path)
}
inline std::string* DeleteRequest::mutable_remote_file_path() {
  std::string* _s = _internal_mutable_remote_file_path();
  // @@protoc_insertion_point(field_mutable:DeleteRequest.remote_file_path)
  return _s;
}
inline const std::string& DeleteRequest::_internal_remote_file_path() const {
  return remote_file_path_.Get();
}
inline void DeleteRequest::_internal_set_remote_file_path(const std::string& value) {
  
  remote_file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DeleteRequest::_internal_mutable_remote_file_path() {
  
  return remote_file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DeleteRequest::release_remote_file_path() {
  // @@protoc_insertion_point(field_release:DeleteRequest.remote_file_path)
  return remote_file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DeleteRequest::set_allocated_remote_file_path(std::string* remote_file_path) {
  if (remote_file_path != nullptr) {
    
  } else {
    
  }
  remote_file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), remote_file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (remote_file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    remote_file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:DeleteRequest.remote_file_path)
}

// -------------------------------------------------------------------

// DeleteReply

// -------------------------------------------------------------------

// StatRequest

// string file_path = 1;
inline void StatRequest::clear_file_path() {
  file_path_.ClearToEmpty();
}
inline const std::string& StatRequest::file_path() const {
  // @@protoc_insertion_point(field_get:StatRequest.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatRequest::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatRequest.file_path)
}
inline std::string* StatRequest::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:StatRequest.file_path)
  return _s;
}
inline const std::string& StatRequest::_internal_file_path() const {
  return file_path_.Get();
}
inline void StatRequest::_internal_set_file_path(const std::string& value) {
  
  file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatRequest::_internal_mutable_file_path() {
  
  return file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatRequest::release_file_path() {
  // @@protoc_insertion_point(field_release:StatRequest.file_path)
  return file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatRequest::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StatRequest.file_path)
}

// -------------------------------------------------------------------

// StatReply

// bool existed = 1;
inline void StatReply::clear_existed() {
  existed_ = false;
}
inline bool StatReply::_internal_existed() const {
  return existed_;
}
inline bool StatReply::existed() const {
  // @@protoc_insertion_point(field_get:StatReply.existed)
  return _internal_existed();
}
inline void StatReply::_internal_set_existed(bool value) {
  
  existed_ = value;
}
inline void StatReply::set_existed(bool value) {
  _internal_set_existed(value);
  // @@protoc_insertion_point(field_set:StatReply.existed)
}

// string file_path = 2;
inline void StatReply::clear_file_path() {
  file_path_.ClearToEmpty();
}
inline const std::string& StatReply::file_path() const {
  // @@protoc_insertion_point(field_get:StatReply.file_path)
  return _internal_file_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StatReply::set_file_path(ArgT0&& arg0, ArgT... args) {
 
 file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StatReply.file_path)
}
inline std::string* StatReply::mutable_file_path() {
  std::string* _s = _internal_mutable_file_path();
  // @@protoc_insertion_point(field_mutable:StatReply.file_path)
  return _s;
}
inline const std::string& StatReply::_internal_file_path() const {
  return file_path_.Get();
}
inline void StatReply::_internal_set_file_path(const std::string& value) {
  
  file_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StatReply::_internal_mutable_file_path() {
  
  return file_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StatReply::release_file_path() {
  // @@protoc_insertion_point(field_release:StatReply.file_path)
  return file_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void StatReply::set_allocated_file_path(std::string* file_path) {
  if (file_path != nullptr) {
    
  } else {
    
  }
  file_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StatReply.file_path)
}

// uint64 file_size = 3;
inline void StatReply::clear_file_size() {
  file_size_ = uint64_t{0u};
}
inline uint64_t StatReply::_internal_file_size() const {
  return file_size_;
}
inline uint64_t StatReply::file_size() const {
  // @@protoc_insertion_point(field_get:StatReply.file_size)
  return _internal_file_size();
}
inline void StatReply::_internal_set_file_size(uint64_t value) {
  
  file_size_ = value;
}
inline void StatReply::set_file_size(uint64_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:StatReply.file_size)
}

// -------------------------------------------------------------------

// WriteChunkRequest

// int64 chunkhandle = 1;
inline void WriteChunkRequest::clear_chunkhandle() {
  chunkhandle_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_chunkhandle() const {
  return chunkhandle_;
}
inline int64_t WriteChunkRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:WriteChunkRequest.chunkhandle)
  return _internal_chunkhandle();
}
inline void WriteChunkRequest::_internal_set_chunkhandle(int64_t value) {
  
  chunkhandle_ = value;
}
inline void WriteChunkRequest::set_chunkhandle(int64_t value) {
  _internal_set_chunkhandle(value);
  // @@protoc_insertion_point(field_set:WriteChunkRequest.chunkhandle)
}

// int64 offset = 2;
inline void WriteChunkRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_offset() const {
  return offset_;
}
inline int64_t WriteChunkRequest::offset() const {
  // @@protoc_insertion_point(field_get:WriteChunkRequest.offset)
  return _internal_offset();
}
inline void WriteChunkRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void WriteChunkRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:WriteChunkRequest.offset)
}

// int64 length = 3;
inline void WriteChunkRequest::clear_length() {
  length_ = int64_t{0};
}
inline int64_t WriteChunkRequest::_internal_length() const {
  return length_;
}
inline int64_t WriteChunkRequest::length() const {
  // @@protoc_insertion_point(field_get:WriteChunkRequest.length)
  return _internal_length();
}
inline void WriteChunkRequest::_internal_set_length(int64_t value) {
  
  length_ = value;
}
inline void WriteChunkRequest::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:WriteChunkRequest.length)
}

// string data = 4;
inline void WriteChunkRequest::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& WriteChunkRequest::data() const {
  // @@protoc_insertion_point(field_get:WriteChunkRequest.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WriteChunkRequest::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:WriteChunkRequest.data)
}
inline std::string* WriteChunkRequest::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:WriteChunkRequest.data)
  return _s;
}
inline const std::string& WriteChunkRequest::_internal_data() const {
  return data_.Get();
}
inline void WriteChunkRequest::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* WriteChunkRequest::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* WriteChunkRequest::release_data() {
  // @@protoc_insertion_point(field_release:WriteChunkRequest.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void WriteChunkRequest::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:WriteChunkRequest.data)
}

// -------------------------------------------------------------------

// WriteChunkReply

// int64 bytes_write = 1;
inline void WriteChunkReply::clear_bytes_write() {
  bytes_write_ = int64_t{0};
}
inline int64_t WriteChunkReply::_internal_bytes_write() const {
  return bytes_write_;
}
inline int64_t WriteChunkReply::bytes_write() const {
  // @@protoc_insertion_point(field_get:WriteChunkReply.bytes_write)
  return _internal_bytes_write();
}
inline void WriteChunkReply::_internal_set_bytes_write(int64_t value) {
  
  bytes_write_ = value;
}
inline void WriteChunkReply::set_bytes_write(int64_t value) {
  _internal_set_bytes_write(value);
  // @@protoc_insertion_point(field_set:WriteChunkReply.bytes_write)
}

// -------------------------------------------------------------------

// ReadChunkRequest

// int64 chunkhandle = 1;
inline void ReadChunkRequest::clear_chunkhandle() {
  chunkhandle_ = int64_t{0};
}
inline int64_t ReadChunkRequest::_internal_chunkhandle() const {
  return chunkhandle_;
}
inline int64_t ReadChunkRequest::chunkhandle() const {
  // @@protoc_insertion_point(field_get:ReadChunkRequest.chunkhandle)
  return _internal_chunkhandle();
}
inline void ReadChunkRequest::_internal_set_chunkhandle(int64_t value) {
  
  chunkhandle_ = value;
}
inline void ReadChunkRequest::set_chunkhandle(int64_t value) {
  _internal_set_chunkhandle(value);
  // @@protoc_insertion_point(field_set:ReadChunkRequest.chunkhandle)
}

// int64 offset = 2;
inline void ReadChunkRequest::clear_offset() {
  offset_ = int64_t{0};
}
inline int64_t ReadChunkRequest::_internal_offset() const {
  return offset_;
}
inline int64_t ReadChunkRequest::offset() const {
  // @@protoc_insertion_point(field_get:ReadChunkRequest.offset)
  return _internal_offset();
}
inline void ReadChunkRequest::_internal_set_offset(int64_t value) {
  
  offset_ = value;
}
inline void ReadChunkRequest::set_offset(int64_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:ReadChunkRequest.offset)
}

// int64 length = 3;
inline void ReadChunkRequest::clear_length() {
  length_ = int64_t{0};
}
inline int64_t ReadChunkRequest::_internal_length() const {
  return length_;
}
inline int64_t ReadChunkRequest::length() const {
  // @@protoc_insertion_point(field_get:ReadChunkRequest.length)
  return _internal_length();
}
inline void ReadChunkRequest::_internal_set_length(int64_t value) {
  
  length_ = value;
}
inline void ReadChunkRequest::set_length(int64_t value) {
  _internal_set_length(value);
  // @@protoc_insertion_point(field_set:ReadChunkRequest.length)
}

// -------------------------------------------------------------------

// ReadChunkReply

// string data = 1;
inline void ReadChunkReply::clear_data() {
  data_.ClearToEmpty();
}
inline const std::string& ReadChunkReply::data() const {
  // @@protoc_insertion_point(field_get:ReadChunkReply.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ReadChunkReply::set_data(ArgT0&& arg0, ArgT... args) {
 
 data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ReadChunkReply.data)
}
inline std::string* ReadChunkReply::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:ReadChunkReply.data)
  return _s;
}
inline const std::string& ReadChunkReply::_internal_data() const {
  return data_.Get();
}
inline void ReadChunkReply::_internal_set_data(const std::string& value) {
  
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ReadChunkReply::_internal_mutable_data() {
  
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ReadChunkReply::release_data() {
  // @@protoc_insertion_point(field_release:ReadChunkReply.data)
  return data_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ReadChunkReply::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    
  } else {
    
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ReadChunkReply.data)
}

// int64 bytes_read = 2;
inline void ReadChunkReply::clear_bytes_read() {
  bytes_read_ = int64_t{0};
}
inline int64_t ReadChunkReply::_internal_bytes_read() const {
  return bytes_read_;
}
inline int64_t ReadChunkReply::bytes_read() const {
  // @@protoc_insertion_point(field_get:ReadChunkReply.bytes_read)
  return _internal_bytes_read();
}
inline void ReadChunkReply::_internal_set_bytes_read(int64_t value) {
  
  bytes_read_ = value;
}
inline void ReadChunkReply::set_bytes_read(int64_t value) {
  _internal_set_bytes_read(value);
  // @@protoc_insertion_point(field_set:ReadChunkReply.bytes_read)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_cli2ser_2eproto
