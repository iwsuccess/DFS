// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: namenode_datanode_service.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_namenode_5fdatanode_5fservice_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_namenode_5fdatanode_5fservice_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_namenode_5fdatanode_5fservice_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_namenode_5fdatanode_5fservice_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[9]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_namenode_5fdatanode_5fservice_2eproto;
namespace Rpc {
class Chunk;
struct ChunkDefaultTypeInternal;
extern ChunkDefaultTypeInternal _Chunk_default_instance_;
class CopyChunkReply;
struct CopyChunkReplyDefaultTypeInternal;
extern CopyChunkReplyDefaultTypeInternal _CopyChunkReply_default_instance_;
class CopyChunkRequest;
struct CopyChunkRequestDefaultTypeInternal;
extern CopyChunkRequestDefaultTypeInternal _CopyChunkRequest_default_instance_;
class DataNode;
struct DataNodeDefaultTypeInternal;
extern DataNodeDefaultTypeInternal _DataNode_default_instance_;
class DataNodeLocation;
struct DataNodeLocationDefaultTypeInternal;
extern DataNodeLocationDefaultTypeInternal _DataNodeLocation_default_instance_;
class HeartbeatReply;
struct HeartbeatReplyDefaultTypeInternal;
extern HeartbeatReplyDefaultTypeInternal _HeartbeatReply_default_instance_;
class HeartbeatRequest;
struct HeartbeatRequestDefaultTypeInternal;
extern HeartbeatRequestDefaultTypeInternal _HeartbeatRequest_default_instance_;
class ReportDataNodeReply;
struct ReportDataNodeReplyDefaultTypeInternal;
extern ReportDataNodeReplyDefaultTypeInternal _ReportDataNodeReply_default_instance_;
class ReportDataNodeRequest;
struct ReportDataNodeRequestDefaultTypeInternal;
extern ReportDataNodeRequestDefaultTypeInternal _ReportDataNodeRequest_default_instance_;
}  // namespace Rpc
PROTOBUF_NAMESPACE_OPEN
template<> ::Rpc::Chunk* Arena::CreateMaybeMessage<::Rpc::Chunk>(Arena*);
template<> ::Rpc::CopyChunkReply* Arena::CreateMaybeMessage<::Rpc::CopyChunkReply>(Arena*);
template<> ::Rpc::CopyChunkRequest* Arena::CreateMaybeMessage<::Rpc::CopyChunkRequest>(Arena*);
template<> ::Rpc::DataNode* Arena::CreateMaybeMessage<::Rpc::DataNode>(Arena*);
template<> ::Rpc::DataNodeLocation* Arena::CreateMaybeMessage<::Rpc::DataNodeLocation>(Arena*);
template<> ::Rpc::HeartbeatReply* Arena::CreateMaybeMessage<::Rpc::HeartbeatReply>(Arena*);
template<> ::Rpc::HeartbeatRequest* Arena::CreateMaybeMessage<::Rpc::HeartbeatRequest>(Arena*);
template<> ::Rpc::ReportDataNodeReply* Arena::CreateMaybeMessage<::Rpc::ReportDataNodeReply>(Arena*);
template<> ::Rpc::ReportDataNodeRequest* Arena::CreateMaybeMessage<::Rpc::ReportDataNodeRequest>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Rpc {

// ===================================================================

class DataNodeLocation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.DataNodeLocation) */ {
 public:
  inline DataNodeLocation() : DataNodeLocation(nullptr) {}
  ~DataNodeLocation() override;
  explicit constexpr DataNodeLocation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataNodeLocation(const DataNodeLocation& from);
  DataNodeLocation(DataNodeLocation&& from) noexcept
    : DataNodeLocation() {
    *this = ::std::move(from);
  }

  inline DataNodeLocation& operator=(const DataNodeLocation& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataNodeLocation& operator=(DataNodeLocation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataNodeLocation& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataNodeLocation* internal_default_instance() {
    return reinterpret_cast<const DataNodeLocation*>(
               &_DataNodeLocation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(DataNodeLocation& a, DataNodeLocation& b) {
    a.Swap(&b);
  }
  inline void Swap(DataNodeLocation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataNodeLocation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataNodeLocation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataNodeLocation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataNodeLocation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataNodeLocation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataNodeLocation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.DataNodeLocation";
  }
  protected:
  explicit DataNodeLocation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // @@protoc_insertion_point(class_scope:Rpc.DataNodeLocation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class DataNode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.DataNode) */ {
 public:
  inline DataNode() : DataNode(nullptr) {}
  ~DataNode() override;
  explicit constexpr DataNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DataNode(const DataNode& from);
  DataNode(DataNode&& from) noexcept
    : DataNode() {
    *this = ::std::move(from);
  }

  inline DataNode& operator=(const DataNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline DataNode& operator=(DataNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DataNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const DataNode* internal_default_instance() {
    return reinterpret_cast<const DataNode*>(
               &_DataNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DataNode& a, DataNode& b) {
    a.Swap(&b);
  }
  inline void Swap(DataNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DataNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DataNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DataNode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DataNode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const DataNode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DataNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.DataNode";
  }
  protected:
  explicit DataNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoredChunkHandlesFieldNumber = 3,
    kLocationFieldNumber = 1,
    kAvailableSizeFieldNumber = 2,
  };
  // repeated int64 stored_chunk_handles = 3;
  int stored_chunk_handles_size() const;
  private:
  int _internal_stored_chunk_handles_size() const;
  public:
  void clear_stored_chunk_handles();
  private:
  int64_t _internal_stored_chunk_handles(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_stored_chunk_handles() const;
  void _internal_add_stored_chunk_handles(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_stored_chunk_handles();
  public:
  int64_t stored_chunk_handles(int index) const;
  void set_stored_chunk_handles(int index, int64_t value);
  void add_stored_chunk_handles(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      stored_chunk_handles() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_stored_chunk_handles();

  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // uint32 available_size = 2;
  void clear_available_size();
  uint32_t available_size() const;
  void set_available_size(uint32_t value);
  private:
  uint32_t _internal_available_size() const;
  void _internal_set_available_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.DataNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > stored_chunk_handles_;
  mutable std::atomic<int> _stored_chunk_handles_cached_byte_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  uint32_t available_size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class Chunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.Chunk) */ {
 public:
  inline Chunk() : Chunk(nullptr) {}
  ~Chunk() override;
  explicit constexpr Chunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chunk(const Chunk& from);
  Chunk(Chunk&& from) noexcept
    : Chunk() {
    *this = ::std::move(from);
  }

  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chunk& operator=(Chunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chunk* internal_default_instance() {
    return reinterpret_cast<const Chunk*>(
               &_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Chunk& a, Chunk& b) {
    a.Swap(&b);
  }
  inline void Swap(Chunk* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Chunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Chunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Chunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chunk* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.Chunk";
  }
  protected:
  explicit Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 2,
    kChunkHandleFieldNumber = 1,
    kSizeFieldNumber = 3,
  };
  // repeated string location = 2;
  int location_size() const;
  private:
  int _internal_location_size() const;
  public:
  void clear_location();
  const std::string& location(int index) const;
  std::string* mutable_location(int index);
  void set_location(int index, const std::string& value);
  void set_location(int index, std::string&& value);
  void set_location(int index, const char* value);
  void set_location(int index, const char* value, size_t size);
  std::string* add_location();
  void add_location(const std::string& value);
  void add_location(std::string&& value);
  void add_location(const char* value);
  void add_location(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& location() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_location();
  private:
  const std::string& _internal_location(int index) const;
  std::string* _internal_add_location();
  public:

  // int64 chunk_handle = 1;
  void clear_chunk_handle();
  int64_t chunk_handle() const;
  void set_chunk_handle(int64_t value);
  private:
  int64_t _internal_chunk_handle() const;
  void _internal_set_chunk_handle(int64_t value);
  public:

  // int64 size = 3;
  void clear_size();
  int64_t size() const;
  void set_size(int64_t value);
  private:
  int64_t _internal_size() const;
  void _internal_set_size(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.Chunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> location_;
  int64_t chunk_handle_;
  int64_t size_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReportDataNodeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.ReportDataNodeRequest) */ {
 public:
  inline ReportDataNodeRequest() : ReportDataNodeRequest(nullptr) {}
  ~ReportDataNodeRequest() override;
  explicit constexpr ReportDataNodeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportDataNodeRequest(const ReportDataNodeRequest& from);
  ReportDataNodeRequest(ReportDataNodeRequest&& from) noexcept
    : ReportDataNodeRequest() {
    *this = ::std::move(from);
  }

  inline ReportDataNodeRequest& operator=(const ReportDataNodeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportDataNodeRequest& operator=(ReportDataNodeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportDataNodeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportDataNodeRequest* internal_default_instance() {
    return reinterpret_cast<const ReportDataNodeRequest*>(
               &_ReportDataNodeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ReportDataNodeRequest& a, ReportDataNodeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportDataNodeRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportDataNodeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportDataNodeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportDataNodeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ReportDataNodeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ReportDataNodeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ReportDataNodeRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.ReportDataNodeRequest";
  }
  protected:
  explicit ReportDataNodeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDatanodeFieldNumber = 1,
  };
  // .Rpc.DataNode datanode = 1;
  bool has_datanode() const;
  private:
  bool _internal_has_datanode() const;
  public:
  void clear_datanode();
  const ::Rpc::DataNode& datanode() const;
  PROTOBUF_NODISCARD ::Rpc::DataNode* release_datanode();
  ::Rpc::DataNode* mutable_datanode();
  void set_allocated_datanode(::Rpc::DataNode* datanode);
  private:
  const ::Rpc::DataNode& _internal_datanode() const;
  ::Rpc::DataNode* _internal_mutable_datanode();
  public:
  void unsafe_arena_set_allocated_datanode(
      ::Rpc::DataNode* datanode);
  ::Rpc::DataNode* unsafe_arena_release_datanode();

  // @@protoc_insertion_point(class_scope:Rpc.ReportDataNodeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Rpc::DataNode* datanode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class ReportDataNodeReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.ReportDataNodeReply) */ {
 public:
  inline ReportDataNodeReply() : ReportDataNodeReply(nullptr) {}
  explicit constexpr ReportDataNodeReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ReportDataNodeReply(const ReportDataNodeReply& from);
  ReportDataNodeReply(ReportDataNodeReply&& from) noexcept
    : ReportDataNodeReply() {
    *this = ::std::move(from);
  }

  inline ReportDataNodeReply& operator=(const ReportDataNodeReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline ReportDataNodeReply& operator=(ReportDataNodeReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ReportDataNodeReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const ReportDataNodeReply* internal_default_instance() {
    return reinterpret_cast<const ReportDataNodeReply*>(
               &_ReportDataNodeReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(ReportDataNodeReply& a, ReportDataNodeReply& b) {
    a.Swap(&b);
  }
  inline void Swap(ReportDataNodeReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ReportDataNodeReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ReportDataNodeReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ReportDataNodeReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const ReportDataNodeReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const ReportDataNodeReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.ReportDataNodeReply";
  }
  protected:
  explicit ReportDataNodeReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.ReportDataNodeReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.HeartbeatRequest) */ {
 public:
  inline HeartbeatRequest() : HeartbeatRequest(nullptr) {}
  explicit constexpr HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatRequest(const HeartbeatRequest& from);
  HeartbeatRequest(HeartbeatRequest&& from) noexcept
    : HeartbeatRequest() {
    *this = ::std::move(from);
  }

  inline HeartbeatRequest& operator=(const HeartbeatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatRequest& operator=(HeartbeatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatRequest* internal_default_instance() {
    return reinterpret_cast<const HeartbeatRequest*>(
               &_HeartbeatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(HeartbeatRequest& a, HeartbeatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const HeartbeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const HeartbeatRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.HeartbeatRequest";
  }
  protected:
  explicit HeartbeatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.HeartbeatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class HeartbeatReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.HeartbeatReply) */ {
 public:
  inline HeartbeatReply() : HeartbeatReply(nullptr) {}
  ~HeartbeatReply() override;
  explicit constexpr HeartbeatReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HeartbeatReply(const HeartbeatReply& from);
  HeartbeatReply(HeartbeatReply&& from) noexcept
    : HeartbeatReply() {
    *this = ::std::move(from);
  }

  inline HeartbeatReply& operator=(const HeartbeatReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline HeartbeatReply& operator=(HeartbeatReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HeartbeatReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const HeartbeatReply* internal_default_instance() {
    return reinterpret_cast<const HeartbeatReply*>(
               &_HeartbeatReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(HeartbeatReply& a, HeartbeatReply& b) {
    a.Swap(&b);
  }
  inline void Swap(HeartbeatReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HeartbeatReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  HeartbeatReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<HeartbeatReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HeartbeatReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HeartbeatReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HeartbeatReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.HeartbeatReply";
  }
  protected:
  explicit HeartbeatReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestFieldNumber = 1,
  };
  // .Rpc.HeartbeatRequest request = 1;
  bool has_request() const;
  private:
  bool _internal_has_request() const;
  public:
  void clear_request();
  const ::Rpc::HeartbeatRequest& request() const;
  PROTOBUF_NODISCARD ::Rpc::HeartbeatRequest* release_request();
  ::Rpc::HeartbeatRequest* mutable_request();
  void set_allocated_request(::Rpc::HeartbeatRequest* request);
  private:
  const ::Rpc::HeartbeatRequest& _internal_request() const;
  ::Rpc::HeartbeatRequest* _internal_mutable_request();
  public:
  void unsafe_arena_set_allocated_request(
      ::Rpc::HeartbeatRequest* request);
  ::Rpc::HeartbeatRequest* unsafe_arena_release_request();

  // @@protoc_insertion_point(class_scope:Rpc.HeartbeatReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Rpc::HeartbeatRequest* request_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CopyChunkRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkRequest) */ {
 public:
  inline CopyChunkRequest() : CopyChunkRequest(nullptr) {}
  ~CopyChunkRequest() override;
  explicit constexpr CopyChunkRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyChunkRequest(const CopyChunkRequest& from);
  CopyChunkRequest(CopyChunkRequest&& from) noexcept
    : CopyChunkRequest() {
    *this = ::std::move(from);
  }

  inline CopyChunkRequest& operator=(const CopyChunkRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyChunkRequest& operator=(CopyChunkRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyChunkRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyChunkRequest* internal_default_instance() {
    return reinterpret_cast<const CopyChunkRequest*>(
               &_CopyChunkRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CopyChunkRequest& a, CopyChunkRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyChunkRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyChunkRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyChunkRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyChunkRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CopyChunkRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CopyChunkRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CopyChunkRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.CopyChunkRequest";
  }
  protected:
  explicit CopyChunkRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocationFieldNumber = 1,
    kChunkHandleFieldNumber = 2,
  };
  // string location = 1;
  void clear_location();
  const std::string& location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_location();
  PROTOBUF_NODISCARD std::string* release_location();
  void set_allocated_location(std::string* location);
  private:
  const std::string& _internal_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_location(const std::string& value);
  std::string* _internal_mutable_location();
  public:

  // int64 chunk_handle = 2;
  void clear_chunk_handle();
  int64_t chunk_handle() const;
  void set_chunk_handle(int64_t value);
  private:
  int64_t _internal_chunk_handle() const;
  void _internal_set_chunk_handle(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr location_;
  int64_t chunk_handle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// -------------------------------------------------------------------

class CopyChunkReply final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:Rpc.CopyChunkReply) */ {
 public:
  inline CopyChunkReply() : CopyChunkReply(nullptr) {}
  explicit constexpr CopyChunkReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CopyChunkReply(const CopyChunkReply& from);
  CopyChunkReply(CopyChunkReply&& from) noexcept
    : CopyChunkReply() {
    *this = ::std::move(from);
  }

  inline CopyChunkReply& operator=(const CopyChunkReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CopyChunkReply& operator=(CopyChunkReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CopyChunkReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CopyChunkReply* internal_default_instance() {
    return reinterpret_cast<const CopyChunkReply*>(
               &_CopyChunkReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CopyChunkReply& a, CopyChunkReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CopyChunkReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CopyChunkReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CopyChunkReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CopyChunkReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CopyChunkReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CopyChunkReply& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Rpc.CopyChunkReply";
  }
  protected:
  explicit CopyChunkReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:Rpc.CopyChunkReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_namenode_5fdatanode_5fservice_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DataNodeLocation

// string location = 1;
inline void DataNodeLocation::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& DataNodeLocation::location() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNodeLocation.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataNodeLocation::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.DataNodeLocation.location)
}
inline std::string* DataNodeLocation::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.DataNodeLocation.location)
  return _s;
}
inline const std::string& DataNodeLocation::_internal_location() const {
  return location_.Get();
}
inline void DataNodeLocation::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataNodeLocation::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataNodeLocation::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.DataNodeLocation.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataNodeLocation::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.DataNodeLocation.location)
}

// -------------------------------------------------------------------

// DataNode

// string location = 1;
inline void DataNode::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& DataNode::location() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DataNode::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.DataNode.location)
}
inline std::string* DataNode::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.DataNode.location)
  return _s;
}
inline const std::string& DataNode::_internal_location() const {
  return location_.Get();
}
inline void DataNode::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* DataNode::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* DataNode::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.DataNode.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void DataNode::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.DataNode.location)
}

// uint32 available_size = 2;
inline void DataNode::clear_available_size() {
  available_size_ = 0u;
}
inline uint32_t DataNode::_internal_available_size() const {
  return available_size_;
}
inline uint32_t DataNode::available_size() const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.available_size)
  return _internal_available_size();
}
inline void DataNode::_internal_set_available_size(uint32_t value) {
  
  available_size_ = value;
}
inline void DataNode::set_available_size(uint32_t value) {
  _internal_set_available_size(value);
  // @@protoc_insertion_point(field_set:Rpc.DataNode.available_size)
}

// repeated int64 stored_chunk_handles = 3;
inline int DataNode::_internal_stored_chunk_handles_size() const {
  return stored_chunk_handles_.size();
}
inline int DataNode::stored_chunk_handles_size() const {
  return _internal_stored_chunk_handles_size();
}
inline void DataNode::clear_stored_chunk_handles() {
  stored_chunk_handles_.Clear();
}
inline int64_t DataNode::_internal_stored_chunk_handles(int index) const {
  return stored_chunk_handles_.Get(index);
}
inline int64_t DataNode::stored_chunk_handles(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.DataNode.stored_chunk_handles)
  return _internal_stored_chunk_handles(index);
}
inline void DataNode::set_stored_chunk_handles(int index, int64_t value) {
  stored_chunk_handles_.Set(index, value);
  // @@protoc_insertion_point(field_set:Rpc.DataNode.stored_chunk_handles)
}
inline void DataNode::_internal_add_stored_chunk_handles(int64_t value) {
  stored_chunk_handles_.Add(value);
}
inline void DataNode::add_stored_chunk_handles(int64_t value) {
  _internal_add_stored_chunk_handles(value);
  // @@protoc_insertion_point(field_add:Rpc.DataNode.stored_chunk_handles)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DataNode::_internal_stored_chunk_handles() const {
  return stored_chunk_handles_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
DataNode::stored_chunk_handles() const {
  // @@protoc_insertion_point(field_list:Rpc.DataNode.stored_chunk_handles)
  return _internal_stored_chunk_handles();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DataNode::_internal_mutable_stored_chunk_handles() {
  return &stored_chunk_handles_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
DataNode::mutable_stored_chunk_handles() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.DataNode.stored_chunk_handles)
  return _internal_mutable_stored_chunk_handles();
}

// -------------------------------------------------------------------

// Chunk

// int64 chunk_handle = 1;
inline void Chunk::clear_chunk_handle() {
  chunk_handle_ = int64_t{0};
}
inline int64_t Chunk::_internal_chunk_handle() const {
  return chunk_handle_;
}
inline int64_t Chunk::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.chunk_handle)
  return _internal_chunk_handle();
}
inline void Chunk::_internal_set_chunk_handle(int64_t value) {
  
  chunk_handle_ = value;
}
inline void Chunk::set_chunk_handle(int64_t value) {
  _internal_set_chunk_handle(value);
  // @@protoc_insertion_point(field_set:Rpc.Chunk.chunk_handle)
}

// repeated string location = 2;
inline int Chunk::_internal_location_size() const {
  return location_.size();
}
inline int Chunk::location_size() const {
  return _internal_location_size();
}
inline void Chunk::clear_location() {
  location_.Clear();
}
inline std::string* Chunk::add_location() {
  std::string* _s = _internal_add_location();
  // @@protoc_insertion_point(field_add_mutable:Rpc.Chunk.location)
  return _s;
}
inline const std::string& Chunk::_internal_location(int index) const {
  return location_.Get(index);
}
inline const std::string& Chunk::location(int index) const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.location)
  return _internal_location(index);
}
inline std::string* Chunk::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:Rpc.Chunk.location)
  return location_.Mutable(index);
}
inline void Chunk::set_location(int index, const std::string& value) {
  location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, std::string&& value) {
  location_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  location_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Rpc.Chunk.location)
}
inline void Chunk::set_location(int index, const char* value, size_t size) {
  location_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Rpc.Chunk.location)
}
inline std::string* Chunk::_internal_add_location() {
  return location_.Add();
}
inline void Chunk::add_location(const std::string& value) {
  location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Rpc.Chunk.location)
}
inline void Chunk::add_location(std::string&& value) {
  location_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Rpc.Chunk.location)
}
inline void Chunk::add_location(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  location_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Rpc.Chunk.location)
}
inline void Chunk::add_location(const char* value, size_t size) {
  location_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Rpc.Chunk.location)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Chunk::location() const {
  // @@protoc_insertion_point(field_list:Rpc.Chunk.location)
  return location_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Chunk::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:Rpc.Chunk.location)
  return &location_;
}

// int64 size = 3;
inline void Chunk::clear_size() {
  size_ = int64_t{0};
}
inline int64_t Chunk::_internal_size() const {
  return size_;
}
inline int64_t Chunk::size() const {
  // @@protoc_insertion_point(field_get:Rpc.Chunk.size)
  return _internal_size();
}
inline void Chunk::_internal_set_size(int64_t value) {
  
  size_ = value;
}
inline void Chunk::set_size(int64_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:Rpc.Chunk.size)
}

// -------------------------------------------------------------------

// ReportDataNodeRequest

// .Rpc.DataNode datanode = 1;
inline bool ReportDataNodeRequest::_internal_has_datanode() const {
  return this != internal_default_instance() && datanode_ != nullptr;
}
inline bool ReportDataNodeRequest::has_datanode() const {
  return _internal_has_datanode();
}
inline void ReportDataNodeRequest::clear_datanode() {
  if (GetArenaForAllocation() == nullptr && datanode_ != nullptr) {
    delete datanode_;
  }
  datanode_ = nullptr;
}
inline const ::Rpc::DataNode& ReportDataNodeRequest::_internal_datanode() const {
  const ::Rpc::DataNode* p = datanode_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rpc::DataNode&>(
      ::Rpc::_DataNode_default_instance_);
}
inline const ::Rpc::DataNode& ReportDataNodeRequest::datanode() const {
  // @@protoc_insertion_point(field_get:Rpc.ReportDataNodeRequest.datanode)
  return _internal_datanode();
}
inline void ReportDataNodeRequest::unsafe_arena_set_allocated_datanode(
    ::Rpc::DataNode* datanode) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(datanode_);
  }
  datanode_ = datanode;
  if (datanode) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rpc.ReportDataNodeRequest.datanode)
}
inline ::Rpc::DataNode* ReportDataNodeRequest::release_datanode() {
  
  ::Rpc::DataNode* temp = datanode_;
  datanode_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rpc::DataNode* ReportDataNodeRequest::unsafe_arena_release_datanode() {
  // @@protoc_insertion_point(field_release:Rpc.ReportDataNodeRequest.datanode)
  
  ::Rpc::DataNode* temp = datanode_;
  datanode_ = nullptr;
  return temp;
}
inline ::Rpc::DataNode* ReportDataNodeRequest::_internal_mutable_datanode() {
  
  if (datanode_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rpc::DataNode>(GetArenaForAllocation());
    datanode_ = p;
  }
  return datanode_;
}
inline ::Rpc::DataNode* ReportDataNodeRequest::mutable_datanode() {
  ::Rpc::DataNode* _msg = _internal_mutable_datanode();
  // @@protoc_insertion_point(field_mutable:Rpc.ReportDataNodeRequest.datanode)
  return _msg;
}
inline void ReportDataNodeRequest::set_allocated_datanode(::Rpc::DataNode* datanode) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete datanode_;
  }
  if (datanode) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Rpc::DataNode>::GetOwningArena(datanode);
    if (message_arena != submessage_arena) {
      datanode = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, datanode, submessage_arena);
    }
    
  } else {
    
  }
  datanode_ = datanode;
  // @@protoc_insertion_point(field_set_allocated:Rpc.ReportDataNodeRequest.datanode)
}

// -------------------------------------------------------------------

// ReportDataNodeReply

// -------------------------------------------------------------------

// HeartbeatRequest

// -------------------------------------------------------------------

// HeartbeatReply

// .Rpc.HeartbeatRequest request = 1;
inline bool HeartbeatReply::_internal_has_request() const {
  return this != internal_default_instance() && request_ != nullptr;
}
inline bool HeartbeatReply::has_request() const {
  return _internal_has_request();
}
inline void HeartbeatReply::clear_request() {
  if (GetArenaForAllocation() == nullptr && request_ != nullptr) {
    delete request_;
  }
  request_ = nullptr;
}
inline const ::Rpc::HeartbeatRequest& HeartbeatReply::_internal_request() const {
  const ::Rpc::HeartbeatRequest* p = request_;
  return p != nullptr ? *p : reinterpret_cast<const ::Rpc::HeartbeatRequest&>(
      ::Rpc::_HeartbeatRequest_default_instance_);
}
inline const ::Rpc::HeartbeatRequest& HeartbeatReply::request() const {
  // @@protoc_insertion_point(field_get:Rpc.HeartbeatReply.request)
  return _internal_request();
}
inline void HeartbeatReply::unsafe_arena_set_allocated_request(
    ::Rpc::HeartbeatRequest* request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(request_);
  }
  request_ = request;
  if (request) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Rpc.HeartbeatReply.request)
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::release_request() {
  
  ::Rpc::HeartbeatRequest* temp = request_;
  request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::unsafe_arena_release_request() {
  // @@protoc_insertion_point(field_release:Rpc.HeartbeatReply.request)
  
  ::Rpc::HeartbeatRequest* temp = request_;
  request_ = nullptr;
  return temp;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::_internal_mutable_request() {
  
  if (request_ == nullptr) {
    auto* p = CreateMaybeMessage<::Rpc::HeartbeatRequest>(GetArenaForAllocation());
    request_ = p;
  }
  return request_;
}
inline ::Rpc::HeartbeatRequest* HeartbeatReply::mutable_request() {
  ::Rpc::HeartbeatRequest* _msg = _internal_mutable_request();
  // @@protoc_insertion_point(field_mutable:Rpc.HeartbeatReply.request)
  return _msg;
}
inline void HeartbeatReply::set_allocated_request(::Rpc::HeartbeatRequest* request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete request_;
  }
  if (request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::Rpc::HeartbeatRequest>::GetOwningArena(request);
    if (message_arena != submessage_arena) {
      request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, request, submessage_arena);
    }
    
  } else {
    
  }
  request_ = request;
  // @@protoc_insertion_point(field_set_allocated:Rpc.HeartbeatReply.request)
}

// -------------------------------------------------------------------

// CopyChunkRequest

// string location = 1;
inline void CopyChunkRequest::clear_location() {
  location_.ClearToEmpty();
}
inline const std::string& CopyChunkRequest::location() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkRequest.location)
  return _internal_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CopyChunkRequest::set_location(ArgT0&& arg0, ArgT... args) {
 
 location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkRequest.location)
}
inline std::string* CopyChunkRequest::mutable_location() {
  std::string* _s = _internal_mutable_location();
  // @@protoc_insertion_point(field_mutable:Rpc.CopyChunkRequest.location)
  return _s;
}
inline const std::string& CopyChunkRequest::_internal_location() const {
  return location_.Get();
}
inline void CopyChunkRequest::_internal_set_location(const std::string& value) {
  
  location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CopyChunkRequest::_internal_mutable_location() {
  
  return location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CopyChunkRequest::release_location() {
  // @@protoc_insertion_point(field_release:Rpc.CopyChunkRequest.location)
  return location_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CopyChunkRequest::set_allocated_location(std::string* location) {
  if (location != nullptr) {
    
  } else {
    
  }
  location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Rpc.CopyChunkRequest.location)
}

// int64 chunk_handle = 2;
inline void CopyChunkRequest::clear_chunk_handle() {
  chunk_handle_ = int64_t{0};
}
inline int64_t CopyChunkRequest::_internal_chunk_handle() const {
  return chunk_handle_;
}
inline int64_t CopyChunkRequest::chunk_handle() const {
  // @@protoc_insertion_point(field_get:Rpc.CopyChunkRequest.chunk_handle)
  return _internal_chunk_handle();
}
inline void CopyChunkRequest::_internal_set_chunk_handle(int64_t value) {
  
  chunk_handle_ = value;
}
inline void CopyChunkRequest::set_chunk_handle(int64_t value) {
  _internal_set_chunk_handle(value);
  // @@protoc_insertion_point(field_set:Rpc.CopyChunkRequest.chunk_handle)
}

// -------------------------------------------------------------------

// CopyChunkReply

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Rpc

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_namenode_5fdatanode_5fservice_2eproto
